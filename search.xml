<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C language Relearning-String</title>
    <url>/2024/08/08/C%20language%20Relearning-String/</url>
    <content><![CDATA[<ul>
<li><p>sticky是<code>sticky</code> 值越大，顶置的文章越靠前</p>
</li>
<li><p>thumbnail: “IMAGE_LINK”</p>
<p>redefine对首页文章添加缩略图</p>
</li>
<li><p>摘要</p>
<p>excerpt: “这是文章摘要 This is the excerpt of the post”或者直接设置为false</p>
</li>
<li><p>massage: 文章的密码的提示，但是似乎没有什么用，总是显示Hey,password is required here.</p>
</li>
</ul>
<h1 id="字符串赋值问题"><a href="#字符串赋值问题" class="headerlink" title="字符串赋值问题"></a>字符串赋值问题</h1><p>C语言中，没有字符串类型，只有字符串数组，可以用来表示字符串。</p>
<ul>
<li><p>错误示范</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">name=<span class="string">&quot;Cris&quot;</span>;<span class="comment">//错误一</span></span><br><span class="line">name[<span class="number">20</span>]=<span class="string">&quot;Cris&quot;</span>;<span class="comment">//错误二</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明字符串（字符数组）的时候，可以直接初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[]=<span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1=%s\n&quot;</span>,s1);  </span><br><span class="line">	</span><br><span class="line"><span class="type">char</span> s2[<span class="number">20</span>] = <span class="string">&quot;America&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2=%s\n&quot;</span>, s2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过strcpy函数赋值</p>
<p>需要引用头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s3[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s3, <span class="string">&quot;Russia&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s3=%s\n&quot;</span>, s3);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过指针赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* <span class="built_in">string</span> = <span class="string">&quot;I Love China&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;string  = %s&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何理解这段代码：<br>①程序定义了一个char <em>类型的指针变量（字符指针变量）string，在C语言中，<em>*指针 = 地址</em></em>，顾名思义，指针变量存放着地址<br>②字符串常量”I Love China”，C语言在处理字符串常量是按字符数组来处理的。<br>③结合上两点可以知道，该字符指针存放的是字符常量第一个元素的地址<br>因此，输出时，只需告诉编译器字符常量首元素的地址即可</p>
</li>
</ul>
<h1 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h1><h2 id="Scanf分隔符"><a href="#Scanf分隔符" class="headerlink" title="Scanf分隔符"></a>Scanf分隔符</h2><p>scanf()如果不指定分隔符，<strong>默认的分隔符是空格、制表符和换行符。</strong></p>
<h2 id="getchar-amp-putchar"><a href="#getchar-amp-putchar" class="headerlink" title="getchar()&amp;putchar()"></a>getchar()&amp;putchar()</h2><p><strong>int getchar(void)</strong> 函数从屏幕读取下一个可用的字符，并把它<strong>返回为一个整数</strong>。这个函数在同一个时间内只会读取一个单一的字符。您<strong>可以在循环内使用</strong>这个方法，以便从屏幕上读取多个字符。</p>
<p><strong>int putchar(int c)</strong> 函数把字符输出到屏幕上，并<strong>返回相同的字符</strong>。这个函数在同一个时间内只会<strong>输出一个单一的字符</strong>。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<p>例程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">   <span class="built_in">putchar</span>( c );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="puts-amp-gets"><a href="#puts-amp-gets" class="headerlink" title="puts&amp;gets"></a>puts&amp;gets</h2><p><strong>gets(string)读取一个字符串直到换行符(换行符也会读取进去）。</strong></p>
<p><strong>puts(string)向屏幕输出一个字符串(换行符也会输出)</strong></p>
<p>例程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n-----------------输入输出测试---------------\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line">gets(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是你输入的a\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;检测是否有换行符&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n-----------------输入输出测试---------------\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/shanglala/article/details/108559314">C语言字符串赋值的方法-CSDN博客</a></p>
<p><a href="https://www.runoob.com/cprogramming/c-input-output.html">C 输入 &#038; 输出 | 菜鸟教程</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Butterfly主题魔改日记</title>
    <url>/2024/10/12/Butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Butterfly下载"><a href="#Butterfly下载" class="headerlink" title="Butterfly下载"></a>Butterfly下载</h1><h2 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h2><p>在<code>hexo</code>根目录下，打开命令行，运行下列命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此方法只支持 Hexo 5.0.0 以上版本,通過 npm 安裝並不會在 themes 裏生成主題文件夾，而是在 node_modules 裏生成</p>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>Github链接在这里 ：<a href="https://github.com/jerryc127/hexo-theme-butterfly.git">Butterfly</a></p>
<h1 id="鼠标指针修改"><a href="#鼠标指针修改" class="headerlink" title="鼠标指针修改"></a>鼠标指针修改</h1><h2 id="下载鼠标指针文件"><a href="#下载鼠标指针文件" class="headerlink" title="下载鼠标指针文件"></a>下载鼠标指针文件</h2><p>可以在<a href="https://zhutix.com/tag/cursors/">致美化</a>网站中下载鼠标指针样式。解压缩后，在<code>hexo-butterfly-theme/source/img/chamber</code>路径(如果没有，就新建一个文件夹)下，将解压后的<code>.cur</code>文件放入。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>在 <code>hexo-theme-butterfly/source/css/</code>文件夹下，新建<code>cursors.css</code>文件，里面写入以下内容:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 下面的文件均在hexo-butterfly-theme/source/img/chamber路径下 */</span></span><br><span class="line"><span class="comment">/* 全局默认鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/normal.cur&#x27;</span>), auto <span class="meta">!important</span>; <span class="comment">/* 使用 normal.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 悬停图片时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/diag1.cur&#x27;</span>), auto <span class="meta">!important</span>; <span class="comment">/* 使用 diag1.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择链接标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/link.cur&#x27;</span>), auto; <span class="comment">/* 使用 link.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选中输入框时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/text.cur&#x27;</span>), auto; <span class="comment">/* 使用 text.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 悬停按钮时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/handwriting.cur&#x27;</span>), auto; <span class="comment">/* 使用 handwriting.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 悬停列表标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">i</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/precision.cur&#x27;</span>), auto; <span class="comment">/* 使用 precision.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#footer-wrap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/link.cur&#x27;</span>), auto; <span class="comment">/* 使用 link.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 悬停页码时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-class">.page-number</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/diag2.cur&#x27;</span>), auto; <span class="comment">/* 使用 diag2.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 悬停菜单栏时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.site-page</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;/img/chamber/move.cur&#x27;</span>), auto; <span class="comment">/* 使用 move.cur */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存。</p>
<p>在<code>hexo-theme-butterfly</code>中，找到<code>config.yml</code>文件，找到大概<code>inject:</code>，把下面的语句插入<code>bottom</code>里面，最后效果如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/cursors.css&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，<code>hexo</code>三连即可。</p>
<h1 id="随鼠标移动的星星特效"><a href="#随鼠标移动的星星特效" class="headerlink" title="随鼠标移动的星星特效"></a>随鼠标移动的星星特效</h1><h2 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h2><p>在 <code>hexo-theme-butterfly/source/js</code>路径下创建一个名为 <code>fairyDustCursor</code>的文件，里面写入以下内容:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(function fairyDustCursor() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">var</span> possibleColors = <span class="selector-attr">[<span class="string">&quot;#D61C59&quot;</span>, <span class="string">&quot;#E7D84B&quot;</span>, <span class="string">&quot;#1B8798&quot;</span>]</span></span><br><span class="line">  <span class="selector-tag">var</span> <span class="attribute">width</span> = window<span class="selector-class">.innerWidth</span>;</span><br><span class="line">  <span class="selector-tag">var</span> <span class="attribute">height</span> = window<span class="selector-class">.innerHeight</span>;</span><br><span class="line">  <span class="selector-tag">var</span> <span class="attribute">cursor</span> = &#123;<span class="attribute">x</span>: width/<span class="number">2</span>, y: width/<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="selector-tag">var</span> particles = <span class="selector-attr">[]</span>;</span><br><span class="line"></span><br><span class="line">  function init() &#123;</span><br><span class="line">    bindEvents();</span><br><span class="line">    loop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Bind events that are needed</span><br><span class="line">  function bindEvents() &#123;</span><br><span class="line">    document<span class="selector-class">.addEventListener</span>(&#x27;mousemove&#x27;, onMouseMove);</span><br><span class="line">    document<span class="selector-class">.addEventListener</span>(&#x27;touchmove&#x27;, onTouchMove);</span><br><span class="line">    document<span class="selector-class">.addEventListener</span>(&#x27;touchstart&#x27;, onTouchMove);</span><br><span class="line"></span><br><span class="line">    window<span class="selector-class">.addEventListener</span>(&#x27;<span class="attribute">resize</span>&#x27;, onWindowResize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onWindowResize(e) &#123;</span><br><span class="line">    <span class="attribute">width</span> = window<span class="selector-class">.innerWidth</span>;</span><br><span class="line">    <span class="attribute">height</span> = window<span class="selector-class">.innerHeight</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onTouchMove(e) &#123;</span><br><span class="line">    if( e<span class="selector-class">.touches</span><span class="selector-class">.length</span> &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">      for( <span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; e<span class="selector-class">.touches</span><span class="selector-class">.length</span>; <span class="selector-tag">i</span>++ ) &#123;</span><br><span class="line">        addParticle( e<span class="selector-class">.touches</span><span class="selector-attr">[i]</span><span class="selector-class">.clientX</span>, e<span class="selector-class">.touches</span><span class="selector-attr">[i]</span><span class="selector-class">.clientY</span>, possibleColors<span class="selector-attr">[Math.floor(Math.random()*possibleColors.length)]</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onMouseMove(e) &#123;</span><br><span class="line">    <span class="attribute">cursor</span><span class="selector-class">.x</span> = e<span class="selector-class">.clientX</span>;</span><br><span class="line">    <span class="attribute">cursor</span><span class="selector-class">.y</span> = e<span class="selector-class">.clientY</span>;</span><br><span class="line"></span><br><span class="line">    addParticle( <span class="attribute">cursor</span><span class="selector-class">.x</span>, <span class="attribute">cursor</span><span class="selector-class">.y</span>, possibleColors<span class="selector-attr">[Math.floor(Math.random()*possibleColors.length)]</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addParticle(<span class="attribute">x</span>, <span class="attribute">y</span>, <span class="attribute">color</span>) &#123;</span><br><span class="line">    <span class="selector-tag">var</span> particle = new Particle();</span><br><span class="line">    particle<span class="selector-class">.init</span>(<span class="attribute">x</span>, <span class="attribute">y</span>, <span class="attribute">color</span>);</span><br><span class="line">    particles<span class="selector-class">.push</span>(particle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function updateParticles() &#123;</span><br><span class="line"></span><br><span class="line">    for( <span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; particles<span class="selector-class">.length</span>; <span class="selector-tag">i</span>++ ) &#123;</span><br><span class="line">      particles<span class="selector-attr">[i]</span><span class="selector-class">.update</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for( <span class="selector-tag">var</span> <span class="selector-tag">i</span> = particles<span class="selector-class">.length</span> -<span class="number">1</span>; <span class="selector-tag">i</span> &gt;= <span class="number">0</span>; <span class="selector-tag">i</span>-- ) &#123;</span><br><span class="line">      if( particles<span class="selector-attr">[i]</span><span class="selector-class">.lifeSpan</span> &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        particles<span class="selector-attr">[i]</span><span class="selector-class">.die</span>();</span><br><span class="line">        particles<span class="selector-class">.splice</span>(<span class="selector-tag">i</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function loop() &#123;</span><br><span class="line">    requestAnimationFrame(loop);</span><br><span class="line">    updateParticles();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Particle() &#123;</span><br><span class="line"></span><br><span class="line">    this<span class="selector-class">.character</span> = &quot;*&quot;;</span><br><span class="line">    this<span class="selector-class">.lifeSpan</span> = <span class="number">120</span>; //ms</span><br><span class="line">    this<span class="selector-class">.initialStyles</span> =&#123;</span><br><span class="line">      &quot;<span class="attribute">position</span>&quot;: <span class="string">&quot;fixed&quot;</span>,</span><br><span class="line">      <span class="string">&quot;top&quot;</span>: <span class="string">&quot;0&quot;</span>, //必须加</span><br><span class="line">      <span class="string">&quot;display&quot;</span>: <span class="string">&quot;block&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pointerEvents&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">      <span class="string">&quot;z-index&quot;</span>: <span class="string">&quot;10000000&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fontSize&quot;</span>: <span class="string">&quot;20px&quot;</span>,</span><br><span class="line">      <span class="string">&quot;will-change&quot;</span>: <span class="string">&quot;transform&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this<span class="selector-class">.init</span> = function(<span class="attribute">x</span>, <span class="attribute">y</span>, <span class="attribute">color</span>) &#123;</span><br><span class="line"></span><br><span class="line">      this<span class="selector-class">.velocity</span> = &#123;</span><br><span class="line">        <span class="attribute">x</span>:  (Math.<span class="built_in">random</span>() &lt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>) * (Math.<span class="built_in">random</span>() / <span class="number">2</span>),</span><br><span class="line">        y: <span class="number">1</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      this<span class="selector-class">.position</span> = &#123;<span class="attribute">x</span>: x - <span class="number">10</span>, y: y - <span class="number">20</span>&#125;;</span><br><span class="line">      this<span class="selector-class">.initialStyles</span><span class="selector-class">.color</span> = <span class="attribute">color</span>;</span><br><span class="line">      console<span class="selector-class">.log</span>(<span class="attribute">color</span>);</span><br><span class="line"></span><br><span class="line">      this<span class="selector-class">.element</span> = document<span class="selector-class">.createElement</span>(&#x27;<span class="selector-tag">span</span>&#x27;);</span><br><span class="line">      this<span class="selector-class">.element</span><span class="selector-class">.innerHTML</span> = this<span class="selector-class">.character</span>;</span><br><span class="line">      applyProperties(this<span class="selector-class">.element</span>, this<span class="selector-class">.initialStyles</span>);</span><br><span class="line">      this<span class="selector-class">.update</span>();</span><br><span class="line"></span><br><span class="line">      document<span class="selector-class">.body</span><span class="selector-class">.appendChild</span>(this<span class="selector-class">.element</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this<span class="selector-class">.update</span> = function() &#123;</span><br><span class="line">      this<span class="selector-class">.position</span><span class="selector-class">.x</span> += this<span class="selector-class">.velocity</span><span class="selector-class">.x</span>;</span><br><span class="line">      this<span class="selector-class">.position</span><span class="selector-class">.y</span> += this<span class="selector-class">.velocity</span><span class="selector-class">.y</span>;</span><br><span class="line">      this<span class="selector-class">.lifeSpan--</span>;</span><br><span class="line"></span><br><span class="line">      this<span class="selector-class">.element</span><span class="selector-class">.style</span><span class="selector-class">.transform</span> = &quot;translate3d(&quot; + this<span class="selector-class">.position</span><span class="selector-class">.x</span> + &quot;px,&quot; + this<span class="selector-class">.position</span><span class="selector-class">.y</span> + &quot;px,<span class="number">0</span>) <span class="attribute">scale</span>(&quot; + (this<span class="selector-class">.lifeSpan</span> / <span class="number">120</span>) + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this<span class="selector-class">.die</span> = function() &#123;</span><br><span class="line">      this<span class="selector-class">.element</span><span class="selector-class">.parentNode</span><span class="selector-class">.removeChild</span>(this<span class="selector-class">.element</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function applyProperties( target, properties ) &#123;</span><br><span class="line">    for( <span class="selector-tag">var</span> key in properties ) &#123;</span><br><span class="line">      target<span class="selector-class">.style</span><span class="selector-attr">[ key ]</span> = properties<span class="selector-attr">[ key ]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在<code>hexo-theme-butterfly</code>中，找到<code>config.yml</code>文件，在底部引入:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">     <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;  #这一行是示例</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;/js/fairyDustCursor.js&quot;&gt;&lt;/script&gt;</span>  <span class="comment"># 随鼠标移动的星星特效</span></span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>效果如下:</p>
<img src="/2024/10/12/Butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%97%A5%E8%AE%B0/image-20241012180531419.png" class="" alt="image-20241012180531419">
<h1 id="看板娘（角落人物）"><a href="#看板娘（角落人物）" class="headerlink" title="看板娘（角落人物）"></a>看板娘（角落人物）</h1><h1 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h1><h2 id="字体下载"><a href="#字体下载" class="headerlink" title="字体下载"></a>字体下载</h2><p>如果需要用复古一点的字体，可以参考下面的链接，去下载：<a href="https://wumanzoo.com/10-retro-fonts-for-free-download/?_ga=2.244060812.867738960.1728729929-1489437564.1728729929#%E5%8C%AF%E6%96%87%E6%98%8E%E6%9C%9D%E9%AB%94">10+ 款可免費商業使用的復古字體推薦</a></p>
<p>下载好之后，得到<code>.ttf</code>格式的字体文件。</p>
<h2 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h2><p>在 <code>hexo-theme-butterfly/source/css/</code>文件夹下，新建一个文件夹，起名为<code>fontDiy</code>,把需要导入的字体文件，放入其中，并且在里面创建一个<code>fontDiy.css</code>文件，里面写入以下内容:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 导入第一个字体 */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;qiji&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;qiji-combo.ttf&#x27;</span>); <span class="comment">/* 自定义字体1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导入第二个字体 */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;NewTegomin&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;NewTegomin-Regular.ttf&#x27;</span>); <span class="comment">/* 自定义字体2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导入第三个字体 */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Iansui-Regular&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;Iansui-Regular.ttf&#x27;</span>); <span class="comment">/* 自定义字体2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导入第四个字体 */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Jinghualaosongti&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;Jinghualaosongti-v2.002.ttf&#x27;</span>); <span class="comment">/* 自定义字体2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 body 的字体优先级 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: qiji, NewTegomin,ModernSerif,Iansui-Regular, -apple-system, BlinkMacSystemFont, <span class="string">&quot;Segoe UI&quot;</span>, <span class="string">&quot;Helvetica Neue&quot;</span>, Lato, Roboto, <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;STZhongsong&quot;</span>, <span class="string">&quot;Lantinghei SC&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>; <span class="comment">/* 设定相对于根元素的字体大小 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* font-size: 16px;：设置 body 的字体大小为16像素。你可以根据需要调整这个值，比如 14px、18px 等。</span></span><br><span class="line"><span class="comment">px（像素）是常见的单位，除此之外，你还可以使用其他单位，比如：</span></span><br><span class="line"><span class="comment">em：相对于父元素字体大小的单位。</span></span><br><span class="line"><span class="comment">rem：相对于根元素（HTML）的字体大小。</span></span><br><span class="line"><span class="comment">%：相对于父元素的百分比*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>font-family</code>可以随便起名字。</p>
<p>body里面设置字体显示的优先级。</p>
<p><code>font-size</code>可以设置字体的大小，但是:warning:此处修改了，其他非字体的显示也会放大缩小。</p>
<p><code>font-size: 16px;</code>设置 body 的字体大小为16像素。</p>
<blockquote>
<p>你可以根据需要调整这个值，比如 14px、18px 等。<br>px（像素）是常见的单位，除此之外，你还可以使用其他单位，比如：<br>em：相对于父元素字体大小的单位。<br>rem：相对于根元素（HTML）的字体大小。<br>%：相对于父元素的百分比</p>
</blockquote>
<p>接着在<code>inject</code>的头部引入即可:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/fontDiy/fontDiy.css&quot;&gt;</span> <span class="comment">#  更改字体样式</span></span><br></pre></td></tr></table></figure>
<h1 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h1><h2 id="B站视频"><a href="#B站视频" class="headerlink" title="B站视频"></a>B站视频</h2><img src="/2024/10/12/Butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%97%A5%E8%AE%B0/image-20241023125257937.png" class="" alt="image-20241023125257937">
<p>分享-&gt;嵌入代码即可。然后把复制好的代码放到文章中。</p>
<h2 id="本地视频"><a href="#本地视频" class="headerlink" title="本地视频"></a>本地视频</h2><p>把视频放到一个文件夹中，然后输入下面的代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%</span><br><span class="line">    dplayer     </span><br><span class="line">    &quot;url=/resources/video/scenery.mp4&quot;  //设置视频目录，这里我放在了网站根目录下面，也就是public目录下面 </span><br><span class="line">    &quot;pic=/resources/images/scenery_three.jpeg&quot; //设置封面图，同样是放在根目录下面 </span><br><span class="line">    &quot;loop=yes&quot;  //循环播放</span><br><span class="line">    &quot;theme=#FADFA3&quot;   //主题</span><br><span class="line">    &quot;autoplay=true&quot;  //自动播放</span><br><span class="line">    &quot;screenshot=true&quot; //允许截屏</span><br><span class="line">    &quot;hotkey=true&quot; //允许hotKey，比如点击空格暂停视频等操作</span><br><span class="line">    &quot;preload=auto&quot; //预加载：auto</span><br><span class="line">    &quot;volume=0.9&quot;  //初始音量</span><br><span class="line">    &quot;playbackSpeed=1&quot;//播放速度1倍速，可以选择1.5,2等</span><br><span class="line">    &quot;lang=zh-cn&quot;//语言</span><br><span class="line">    &quot;mutex=true&quot;//播放互斥，就比如其他视频播放就会导致这个视频自动暂停</span><br><span class="line"></span><br><span class="line">    //下面是弹幕相关</span><br><span class="line">    &quot;id=9E2E3368B56CD123BB4&quot;</span><br><span class="line">    &quot;api=https://api.prprpr.me/dplayer/&quot;</span><br><span class="line">    &quot;token=tokendemo&quot;</span><br><span class="line">    &quot;maximum=1000&quot;</span><br><span class="line">    &quot;addition=[&#x27;https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142&#x27;]&quot;</span><br><span class="line">    &quot;user=DIYgod&quot;</span><br><span class="line">    &quot;bottom=15%&quot;</span><br><span class="line">    &quot;unlimited=true&quot;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure></p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/resources/video/scenery.mp4","pic":"/resources/images/scenery_three.jpeg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<h2 id="在线视频"><a href="#在线视频" class="headerlink" title="在线视频"></a>在线视频</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=90978812&cid=155358422&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div> 



<p>另一个示例,直接把B站的“嵌入代码”复制过来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=457559832&amp;bvid=BV1N5411L7yx&amp;cid=250915968&amp;p=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125; </span><br></pre></td></tr></table></figure>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=457559832&bvid=BV1N5411L7yx&cid=250915968&p=1&high_quality=1
scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div>
 
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://butterfly.js.org/">Butterfly官方网站</a></p>
<p><a href="https://9527zxl.github.io/2021/07/22/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%A0%B7%E5%BC%8F/#%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%A0%B7%E5%BC%8F%E6%9B%BF%E6%8D%A2">https://9527zxl.github.io/2021/07/22/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%A0%B7%E5%BC%8F/#%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%A0%B7%E5%BC%8F%E6%9B%BF%E6%8D%A2</a></p>
<p><a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">https://www.cnblogs.com/MoYu-zc/p/14395965.html</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>Casual Thoughts</title>
    <url>/2024/09/09/Casual%20Thoughts/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="400" height="86" src="//music.163.com/outchain/player?type=2&id=1895165581&auto=1&height=66" style="display: block; margin: auto;"></iframe>

<p>2024-11-2</p>
<div style="text-align: center; font-size: 24px; color: #126bae;">
同心而离居，忧伤以终老
</div>




]]></content>
      <categories>
        <category>余</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Vision-Feature points and their descriptors</title>
    <url>/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/</url>
    <content><![CDATA[<h1 id="特征点及其性质"><a href="#特征点及其性质" class="headerlink" title="特征点及其性质"></a>特征点及其性质</h1><h2 id="特征点定义"><a href="#特征点定义" class="headerlink" title="特征点定义"></a>特征点定义</h2><p>图像中具有独特局部性质的点。</p>
<h2 id="特征点性质"><a href="#特征点性质" class="headerlink" title="特征点性质"></a>特征点性质</h2><ul>
<li><strong>局部性</strong>：特征是局部的，对遮挡和混乱场景鲁棒</li>
<li><strong>数量</strong>：一幅图像中可以产生足够数量的特征点，比如成百上</li>
<li><strong>独特性</strong>：可以和其他图像中大多数点相区分</li>
<li><strong>高效性</strong>：能够进行实时的检测和比较</li>
<li><strong>可重复性</strong>：对图像进行旋转平移等操作后，仍能被检测到</li>
</ul>
<h1 id="特征点检测"><a href="#特征点检测" class="headerlink" title="特征点检测"></a>特征点检测</h1><h2 id="角点定义"><a href="#角点定义" class="headerlink" title="角点定义"></a>角点定义</h2><p>在一个以角点为中心的局部窗口内沿着 任意方向移动都会给亮度带来显著变化。</p>
<h2 id="局部窗口内的亮度变化"><a href="#局部窗口内的亮度变化" class="headerlink" title="局部窗口内的亮度变化"></a>局部窗口内的亮度变化</h2><p>某个以$(x,y)$为中心的局部窗口$𝑊$经过$(𝑢,𝑣)$的微小偏移后，窗口 内部亮度发生的变化量，可以用梯度近似$SSD$表示为</p>
<script type="math/tex; mode=display">
\begin{align}
E(u,v)&=\sum_{(x,y)\in W}\left(I(x+u,y+v)-I(x,y)\right)^{2} \\
&= \sum_{(u,v)\in W_{xy}}\left(I(u,v)-I(u+\delta u,v+\delta v)\right)^{2}
\end{align}</script><p>对图像 $I$ 进行一阶泰勒展开，</p>
<script type="math/tex; mode=display">
I(x+u,y+v)\approx I(x,y)+[I_x I_y]\left[\begin{array}{c}u\\v\end{array}\right]</script><p>其中，$I_x,I_y$ 分别是图像在 $x，y$ 方向的梯度，可以用Sobel算子等来计算，将其代入上式，可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
E(u,v) &= \sum_{(x,y)\in W}\left(I(x+u,y+v)-I(x,y)\right)^{2} \\
& \approx\sum_{(x,y)\in W}\left(I(x,y)+I_{x}(x,y)u+I_{y}(x,y)v-I(x,y)\right)^{2} \\
&\approx\sum_{(x,y)\in W}\left(I_{x}(x,y)u+I_{y}(x,y)v\right)^{2} \\
&\approx\sum_{(x,y)\in W}\left(I_{x}^{2}u^{2}+2I_{x}I_{y}uv+I_{y}^{2}v^{2}\right)\\
&=u^{2}\sum_{x,y}I_{x}^{2}+2u\nu\sum_{x,y}I_{x}I_{y}+\nu^{2}\sum_{x,y}I_{y}^{2} \\
&\left.=\left[\begin{array}{cc}{u}&{\nu}\\\end{array}\right.\right]\left[\begin{array}{cc}{\sum_{x,y}I_{x}^{2}}&{\sum_{x,y}I_{x}I_{y}}\\{\sum_{x,y}I_{x}I_{y}}&{\sum_{x,y}I_{y}^{2}}\\\end{array}\right]\left[\begin{array}{c}{u}\\{\nu}\\\end{array}\right]
\end{aligned}</script><p>如果将上式中的二阶矩矩阵的元素表示为：</p>
<script type="math/tex; mode=display">
A=\sum\limits_{(x,y)\in W}I_x^2\quad B=\sum\limits_{(x,y)\in W}I_xI_y\quad C=\sum\limits_{(x,y)\in W}I_y^2</script><p>那么，亮度变化可以近似为：</p>
<script type="math/tex; mode=display">
\left.E(u,v)\approx\left[\begin{array}{cc}u&v\end{array}\right.\right]\left[\begin{array}{cc}A&B\\B&C\end{array}\right]\left[\begin{array}{c}u\\v\end{array}\right]</script><h2 id="对该二阶矩矩阵的理解"><a href="#对该二阶矩矩阵的理解" class="headerlink" title="对该二阶矩矩阵的理解"></a>对该二阶矩矩阵的理解</h2><h3 id="水平方向的边缘"><a href="#水平方向的边缘" class="headerlink" title="水平方向的边缘"></a>水平方向的边缘</h3><img src="/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/image-20241016185533481.png" class="" alt="image-20241016185533481">
<h3 id="竖直方向的边缘"><a href="#竖直方向的边缘" class="headerlink" title="竖直方向的边缘"></a>竖直方向的边缘</h3><img src="/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/image-20241016185613607.png" class="" alt="image-20241016185613607">
<h2 id="与特征值的关系"><a href="#与特征值的关系" class="headerlink" title="与特征值的关系"></a>与特征值的关系</h2><p>我们知道，二次型对应一个椭圆。</p>
<p>当 $A$ 和 $C$ 都非 $0$ 时，对曲面 $E$ 进行横切，形成一个椭圆如下：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}u &v
\end{pmatrix}
H \begin{pmatrix}u\\v\end{pmatrix}=\mathrm{const}</script><p>椭圆的长短轴长度由二阶矩矩阵的特征值来决定，椭圆的角度由二阶矩矩阵的特征向量来决定：</p>
<script type="math/tex; mode=display">
Hx_{\max}=\lambda_{\max}x_{\max}\\Hx_{\min}=\lambda_{\min}x_{\min}</script><img src="/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/image-20241016190132885.png" class="" alt="image-20241016190132885">
<img src="/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/image-20241016190849937.png" class="" alt="image-20241016190849937">
<h2 id="特征值与角点检测"><a href="#特征值与角点检测" class="headerlink" title="特征值与角点检测"></a>特征值与角点检测</h2><img src="/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/image-20241016191337583.png" class="" alt="image-20241016191337583">
<p>概括来说，就是：</p>
<ul>
<li>$\lambda_1$ 和 $\lambda_2$ 都很大，且相差不大，$\rightarrow$ 角点</li>
<li>$\lambda_1$ 远远大于 $\lambda_2$ $\rightarrow$ 水平方向的边</li>
<li>$\lambda_2$ 远远大于 $\lambda_1$ $\rightarrow$ 竖直方向的边</li>
<li>$\lambda_1$ 和 $\lambda_2$ 都很小，且相差不大，$\rightarrow$ 平坦区域</li>
</ul>
<img src="/2024/10/16/Computer%20Vision-Feature%20points%20and%20their%20descriptors/image-20241016191034434.png" class="" alt="image-20241016191034434">
<h1 id="Harris角点检测器"><a href="#Harris角点检测器" class="headerlink" title="Harris角点检测器"></a>Harris角点检测器</h1><h2 id="Harris角点响应函数"><a href="#Harris角点响应函数" class="headerlink" title="Harris角点响应函数"></a>Harris角点响应函数</h2><p>定义如下:</p>
<script type="math/tex; mode=display">
\begin{align}
R&=\det(H)-k(\mathrm {Tr} (H))^2\\
&=\lambda_1\lambda_2-k(\lambda_1+\lambda_2)^2
\end{align}</script><p>其中，$k$ 一般取 $[0.04,0.06]$</p>
<p>实际计算 $H$ 时还可以根据与中心的距离进行加权</p>
<script type="math/tex; mode=display">
H=\sum\limits_{(x,y)\in W}w_{x,y}\left[\begin{array}{cc}I_x^2&I_xI_y\\I_xI_y&I_y^2\end{array}\right]</script><h2 id="用Harris角点响应函数检测"><a href="#用Harris角点响应函数检测" class="headerlink" title="用Harris角点响应函数检测"></a>用Harris角点响应函数检测</h2><h3 id="判据"><a href="#判据" class="headerlink" title="判据"></a>判据</h3><ul>
<li>$R&gt;0$ ，角点</li>
<li>$R&lt;0$ ，边</li>
<li>$|R|$ 很小，平坦区域</li>
</ul>
<h1 id="角点检测流程"><a href="#角点检测流程" class="headerlink" title="角点检测流程"></a>角点检测流程</h1><ul>
<li>计算图像梯度，比如Sobel算子</li>
<li>根据图像梯度为每个点计算二阶矩矩阵特征值或者Harris角点 响应函数</li>
<li>寻找具有较大响应的点（$\lambda_\min$ 或 $R$ 大于阈值）</li>
<li>选择那些 $\lambda_\min$ 或 $R$ 是局部最大值的点作为关键点（非最大值抑 制）</li>
</ul>
<h1 id="角点检测性质"><a href="#角点检测性质" class="headerlink" title="角点检测性质"></a>角点检测性质</h1><h2 id="旋转不变性-Rotation-Invariance"><a href="#旋转不变性-Rotation-Invariance" class="headerlink" title="旋转不变性 (Rotation Invariance)"></a><strong>旋转不变性</strong> (Rotation Invariance)</h2><p><strong>性质</strong>：Harris角点检测器对图像旋转具有不变性。这是因为角点的检测依赖于局部梯度的变化，而旋转不会改变局部结构的梯度大小或方向分布。因此，即使图像发生旋转，角点仍会被准确检测。</p>
<p><strong>举例</strong>：如果图像旋转了90度，角点的位置仍然能准确检测。</p>
<h2 id="平移不变性-Translation-Invariance"><a href="#平移不变性-Translation-Invariance" class="headerlink" title="平移不变性 (Translation Invariance)"></a><strong>平移不变性</strong> (Translation Invariance)</h2><ul>
<li><strong>性质</strong>：Harris角点检测器对图像的平移有很好的不变性。如果图像整体平移，局部的梯度信息和结构不会发生改变，因此角点的位置相对于图像区域会保持不变。</li>
<li><strong>举例</strong>：图像中某个局部区域的角点不会因为图像平移而丢失。</li>
</ul>
<h2 id="局部抗噪性-Local-Robustness-to-Noise"><a href="#局部抗噪性-Local-Robustness-to-Noise" class="headerlink" title="局部抗噪性 (Local Robustness to Noise)"></a><strong>局部抗噪性</strong> (Local Robustness to Noise)</h2><ul>
<li><strong>性质</strong>：通过高斯滤波平滑图像，Harris角点检测器在一定程度上能够减少噪声的影响，但并不完全对噪声不变。局部抗噪性是基于图像平滑处理的效果。</li>
</ul>
<p>但是，不具备下列性质</p>
<ol>
<li><strong>尺度不变性</strong> (Scale Invariance)<ul>
<li><strong>不足</strong>：Harris角点检测器不具备尺度不变性。当图像的尺度发生变化时，角点的检测结果会发生改变。原因在于其检测依赖于固定窗口的局部结构，而窗口大小不随尺度变化调整。因此，图像缩放会导致原来的角点被漏检或新角点被误检。</li>
<li><strong>举例</strong>：如果将图像缩小或放大，原本的角点可能会消失，或在不同位置检测到新的角点。</li>
</ul>
</li>
<li><strong>仿射不变性</strong> (Affine Invariance)<ul>
<li><strong>不足</strong>：Harris角点检测器不具备对仿射变换（如旋转加缩放、剪切等复杂变换）的不变性。仿射变换会改变图像中的几何结构，从而影响角点检测的结果。</li>
<li><strong>举例</strong>：在拍摄角度发生改变或者图像进行了仿射变换后，角点的检测结果可能不一致。</li>
</ul>
</li>
<li><strong>光照不变性</strong> (Illumination Invariance)<ul>
<li><strong>不足</strong>：Harris角点检测器对光照变化较为敏感。如果图像的光照条件发生明显变化（如亮度增加或减少、对比度变化等），角点的检测效果可能会受到影响。</li>
<li><strong>举例</strong>：在光照较暗或较亮的场景中，相同位置的角点可能会因为光照变化而检测不到</li>
</ul>
</li>
</ol>
<h1 id="尺度不变特征变换-Scale-Invariant-Feature-Transform-SIFT"><a href="#尺度不变特征变换-Scale-Invariant-Feature-Transform-SIFT" class="headerlink" title="尺度不变特征变换 (Scale-Invariant Feature  Transform, SIFT)"></a>尺度不变特征变换 (Scale-Invariant Feature  Transform, SIFT)</h1><h2 id="公式基础"><a href="#公式基础" class="headerlink" title="公式基础"></a>公式基础</h2><p>在图像处理和信号处理领域，<strong>unit impulse</strong>、<strong>Gaussian</strong>、<strong>Laplacian of Gaussian (LoG)</strong> 以及<strong>高斯差分 (DoG)</strong> 这些函数之间有紧密的联系。它们都涉及对图像的边缘、特征等信息的提取。以下是它们之间的联系和公式总结：</p>
<h3 id="1-Unit-Impulse-函数-δ函数"><a href="#1-Unit-Impulse-函数-δ函数" class="headerlink" title="1. Unit Impulse 函数 (δ函数)"></a>1. <strong>Unit Impulse 函数 (δ函数)</strong></h3><ul>
<li><strong>定义</strong>：单位脉冲函数，记作 (\delta(x))，在数学上是一个理想化的函数，具有无限高的尖峰，并且在 (x = 0) 处为1，其积分为1。它的作用是挑出函数中特定点的值。</li>
<li><strong>公式</strong>：<br>[<br>\delta(x) =<br>\begin{cases}<br>0, &amp; x \neq 0 \<br>\infty, &amp; x = 0<br>\end{cases}, \quad \int_{-\infty}^{\infty} \delta(x) dx = 1<br>]</li>
<li><strong>与其他函数的联系</strong>：可以看作是信号或图像在某点上的“瞬间激发”。Gaussian 函数和 LoG、DoG 都可以看作是对信号的平滑或差分，能够从信号中提取出更丰富的信息，而脉冲函数是这些操作的基础。</li>
</ul>
<h3 id="2-Gaussian-函数"><a href="#2-Gaussian-函数" class="headerlink" title="2. Gaussian 函数"></a>2. <strong>Gaussian 函数</strong></h3><ul>
<li><strong>定义</strong>：高斯函数是一种平滑函数，广泛应用于图像模糊、降噪等操作。它通过卷积来平滑图像，并压制噪声，使得边缘更加明显。</li>
<li><strong>公式</strong>（一维高斯函数）：<br>[<br>G(x) = \frac{1}{\sqrt{2\pi}\sigma} \exp\left(-\frac{x^2}{2\sigma^2}\right)<br>]<br>二维高斯函数：<br>[<br>G(x, y) = \frac{1}{2\pi\sigma^2} \exp\left(-\frac{x^2 + y^2}{2\sigma^2}\right)<br>]</li>
<li><strong>与Unit Impulse的联系</strong>：高斯函数可以看作是单位脉冲函数在空间域中进行平滑处理的结果，通过调节参数 (\sigma) 来控制平滑程度。</li>
<li><strong>与LoG和DoG的联系</strong>：Gaussian 是构建 LoG 和 DoG 的基础。它通过卷积核的形式应用于图像平滑，之后可以用于提取边缘信息。</li>
</ul>
<h3 id="3-Laplacian-of-Gaussian-LoG"><a href="#3-Laplacian-of-Gaussian-LoG" class="headerlink" title="3. Laplacian of Gaussian (LoG)"></a>3. <strong>Laplacian of Gaussian (LoG)</strong></h3><ul>
<li><strong>定义</strong>：Laplacian of Gaussian 是先对图像应用高斯平滑，然后计算其拉普拉斯算子，用于检测图像的边缘。Laplacian 是二阶微分算子，敏感于亮度快速变化的位置（即边缘）。</li>
<li><strong>公式</strong>：<br>结合高斯函数和拉普拉斯算子，二维 LoG 可以写作：<br>[<br>\text{LoG}(x, y) = \nabla^2 G(x, y) = \left(\frac{x^2 + y^2 - 2\sigma^2}{\sigma^4}\right) \exp\left(-\frac{x^2 + y^2}{2\sigma^2}\right)<br>]<br>其中，(\nabla^2) 表示拉普拉斯算子，它是二阶导数的和：<br>[<br>\nabla^2 f(x, y) = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}<br>]</li>
<li><strong>与Gaussian的联系</strong>：LoG 是对高斯函数先平滑图像，再用拉普拉斯算子来检测图像中的变化（如边缘）。通过高斯平滑抑制噪声，再使用拉普拉斯算子找到边缘位置。</li>
</ul>
<h3 id="4-高斯差分-Difference-of-Gaussian-DoG"><a href="#4-高斯差分-Difference-of-Gaussian-DoG" class="headerlink" title="4. 高斯差分 (Difference of Gaussian, DoG)"></a>4. <strong>高斯差分 (Difference of Gaussian, DoG)</strong></h3><ul>
<li><strong>定义</strong>：DoG 是通过对图像分别应用两个不同尺度的高斯模糊（不同 (\sigma) 值），然后计算它们的差分。DoG 是一种近似LoG的边缘检测方法，但计算更高效。</li>
<li><strong>公式</strong>：<br>给定两个不同尺度的高斯函数 (G(x, y, \sigma_1)) 和 (G(x, y, \sigma_2))，高斯差分为：<br>[<br>\text{DoG}(x, y) = G(x, y, \sigma_1) - G(x, y, \sigma_2)<br>]<br>在频域上，可以近似为：<br>[<br>\text{DoG}(x, y) \approx k \cdot \nabla^2 G(x, y)<br>]<br>其中 (k) 是常数。</li>
<li><strong>与Gaussian的联系</strong>：DoG 是两个不同尺度的高斯函数之差。它通过高效的差分操作，近似计算 LoG，从而实现快速边缘检测。</li>
</ul>
<h3 id="几个函数之间的联系总结："><a href="#几个函数之间的联系总结：" class="headerlink" title="几个函数之间的联系总结："></a>几个函数之间的联系总结：</h3><ul>
<li><strong>Unit Impulse (δ函数)</strong> 是理想的“点”操作基础，在信号处理中常用于理论分析。</li>
<li><strong>Gaussian (高斯函数)</strong> 是平滑滤波函数，通过模糊处理减小噪声，常作为卷积核进行信号平滑。</li>
<li><strong>Laplacian of Gaussian (LoG)</strong> 是对高斯平滑后的图像进行二阶导数，找到图像中快速变化的区域（即边缘），可以更准确地检测边缘。</li>
<li><strong>Difference of Gaussian (DoG)</strong> 是通过两个不同尺度的高斯函数求差，近似实现了 LoG 的边缘检测，但计算效率更高。</li>
</ul>
<p>因此，<strong>Gaussian 是构建 LoG 和 DoG 的基础函数</strong>，而 LoG 和 DoG 都可以用来进行边缘检测，不同之处在于 LoG 是通过二阶导数直接计算边缘，而 DoG 是通过不同尺度的高斯函数相减来近似这种效果。</p>
<h2 id="SIFT流程"><a href="#SIFT流程" class="headerlink" title="SIFT流程"></a>SIFT流程</h2><p>SIFT（尺度不变特征变换，Scale-Invariant Feature Transform）是一种经典的计算机视觉算法，能够检测图像中的关键点，并生成不受尺度、旋转等影响的特征描述子。SIFT描述子的流程分为几个主要步骤，详细说明如下：</p>
<h3 id="SIFT描述子的完整流程"><a href="#SIFT描述子的完整流程" class="headerlink" title="SIFT描述子的完整流程"></a>SIFT描述子的完整流程</h3><h4 id="1-构建尺度空间-Scale-Space-Construction"><a href="#1-构建尺度空间-Scale-Space-Construction" class="headerlink" title="1. 构建尺度空间 (Scale-Space Construction)"></a>1. <strong>构建尺度空间 (Scale-Space Construction)</strong></h4><ul>
<li><strong>目的</strong>：为了检测图像在不同尺度下的关键点，SIFT通过在图像的不同尺度下检测极值点，确保关键点对尺度变化具有不变性。</li>
<li><strong>步骤</strong>：<ul>
<li>通过高斯核对原始图像进行不同程度的模糊处理，生成一系列具有不同模糊程度的图像，称为“高斯金字塔”。</li>
<li>在每个尺度上，用差分高斯（Difference of Gaussian, DoG）图像来近似Laplacian算子，以此找到图像中的关键点。这些差分高斯图像是通过在不同模糊图像之间相减得到的。</li>
</ul>
</li>
</ul>
<h4 id="2-关键点检测-Keypoint-Detection"><a href="#2-关键点检测-Keypoint-Detection" class="headerlink" title="2. 关键点检测 (Keypoint Detection)"></a>2. <strong>关键点检测 (Keypoint Detection)</strong></h4><ul>
<li><strong>目的</strong>：通过在尺度空间中寻找局部极值点来检测关键点，确保这些点是图像中的显著特征。</li>
<li><strong>步骤</strong>：<ul>
<li>在DoG图像的每一个像素，SIFT会在其相邻的尺度层次和空间上搜索局部极值点。</li>
<li>如果一个像素点在它的8个邻域（同一尺度）以及上下两个尺度的相邻区域内都是最大或最小值，那么该像素点就被标记为潜在的关键点。</li>
</ul>
</li>
</ul>
<h4 id="3-关键点精确定位-Keypoint-Localization"><a href="#3-关键点精确定位-Keypoint-Localization" class="headerlink" title="3. 关键点精确定位 (Keypoint Localization)"></a>3. <strong>关键点精确定位 (Keypoint Localization)</strong></h4><ul>
<li><strong>目的</strong>：对初步检测出的关键点进行精确定位和过滤，排除那些低对比度的点和边缘响应较强的点（这些点通常不稳定）。</li>
<li><strong>步骤</strong>：<ul>
<li>使用泰勒展开式对检测到的局部极值点进行精确拟合，以确定其亚像素级别的精确位置。</li>
<li>计算该点的对比度值，如果低于设定的阈值，则将其去除。</li>
<li>同时，通过主曲率的比值来判断该点是否是边缘点，若边缘响应较强也将其去除。</li>
</ul>
</li>
</ul>
<h4 id="4-关键点方向分配-Orientation-Assignment"><a href="#4-关键点方向分配-Orientation-Assignment" class="headerlink" title="4. 关键点方向分配 (Orientation Assignment)"></a>4. <strong>关键点方向分配 (Orientation Assignment)</strong></h4><ul>
<li><strong>目的</strong>：为每个关键点分配一个主方向，确保关键点描述子对图像的旋转具有不变性。</li>
<li><strong>步骤</strong>：<ul>
<li>对每个关键点周围区域的图像梯度进行计算，包括梯度的幅度和方向。</li>
<li>统计梯度方向的直方图，并在360度范围内划分36个方向区间，找到具有最多数量的方向区域（主方向），并将其分配给该关键点。若有多个方向的响应接近主方向，则该关键点可以拥有多个方向。</li>
</ul>
</li>
</ul>
<h4 id="5-关键点描述子生成-Keypoint-Descriptor-Generation"><a href="#5-关键点描述子生成-Keypoint-Descriptor-Generation" class="headerlink" title="5. 关键点描述子生成 (Keypoint Descriptor Generation)"></a>5. <strong>关键点描述子生成 (Keypoint Descriptor Generation)</strong></h4><ul>
<li><strong>目的</strong>：生成具有旋转、尺度不变性的特征描述子，用于后续的图像匹配和识别。</li>
<li><strong>步骤</strong>：<ul>
<li>在每个关键点周围的区域内，取16x16的像素块作为窗口，计算每个窗口内的梯度信息，并将其划分为4x4的子块，每个子块为4x4像素。</li>
<li>对每个子块计算梯度方向直方图，通常将360度分成8个方向区间，每个子块生成一个8维的方向直方图。</li>
<li>对所有的4x4子块生成的8维直方图组合成128维的特征向量，称为SIFT描述子。</li>
</ul>
</li>
</ul>
<h4 id="6-特征向量归一化-Descriptor-Normalization"><a href="#6-特征向量归一化-Descriptor-Normalization" class="headerlink" title="6. 特征向量归一化 (Descriptor Normalization)"></a>6. <strong>特征向量归一化 (Descriptor Normalization)</strong></h4><ul>
<li><strong>目的</strong>：对特征向量进行归一化处理，增强其对光照变化和对比度变化的鲁棒性。</li>
<li><strong>步骤</strong>：<ul>
<li>将每个描述子的128维向量进行归一化，使其总长度为1（通常使用L2范数）。</li>
<li>通过归一化，SIFT描述子对光照变化具有更好的不变性。对于梯度幅度较大的值会进行截断（通常将最大值截断到0.2），然后再进行一次归一化。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SIFT描述子生成的主要流程包括：</p>
<ol>
<li><strong>构建尺度空间</strong>：使用高斯模糊和差分高斯图像检测图像的多尺度特征。</li>
<li><strong>关键点检测</strong>：找到图像中的局部极值点作为初步的关键点。</li>
<li><strong>关键点精确定位</strong>：精确确定关键点的位置并过滤掉不稳定点。</li>
<li><strong>方向分配</strong>：为每个关键点分配一个或多个主方向，确保旋转不变性。</li>
<li><strong>描述子生成</strong>：通过关键点周围的梯度方向信息生成128维的特征描述子。</li>
<li><strong>归一化处理</strong>：对特征向量进行归一化，以提升其对光照和对比度变化的鲁棒性。</li>
</ol>
<p>SIFT描述子生成的整个过程旨在确保关键点和描述子具有<strong>尺度、旋转、平移</strong>等不变性，广泛应用于图像匹配、物体识别等领域。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Vision-Image Histogram and Geometric Transformation</title>
    <url>/2024/09/26/Computer%20Vision-Image%20Histogram%20and%20Geometric%20Transformation/</url>
    <content><![CDATA[<h1 id="图像直方图和累计直方图"><a href="#图像直方图和累计直方图" class="headerlink" title="图像直方图和累计直方图"></a>图像直方图和累计直方图</h1><p>直方图: 横坐标为统计样本，每个柱条(bin)的宽度代表一 段<strong>取值范围</strong>，纵坐标为其对应的某个属性的度量</p>
<h2 id="图像直方图和累计图像直方图"><a href="#图像直方图和累计图像直方图" class="headerlink" title="图像直方图和累计图像直方图"></a>图像直方图和累计图像直方图</h2><blockquote>
<p>函数h代表统计个数，函数g的值是某个位置的像素值。</p>
</blockquote>
<p>图像直方图 $h(g)$ 定义为数值为 $g$ 的<strong>像素值的个数</strong>, 其统计意义为图像中随机一个像素它具有像素值$g$ 的概率：</p>
<script type="math/tex; mode=display">
p(g)=\dfrac{h(g)}{N}</script><p>计算的时候，计算复杂度和像素个数成正比，所以是$O(N)$.</p>
<p>累计直方图代表像素值小于某个值的像素个数。</p>
<script type="math/tex; mode=display">
H(g)=\sum\limits_{x=0}^{g}h(x)=满足条件g(i,j)\le g的像素个数</script><h2 id="概率密度函数和累积分布函数"><a href="#概率密度函数和累积分布函数" class="headerlink" title="概率密度函数和累积分布函数"></a>概率密度函数和累积分布函数</h2><p><span id="jump">概率密度函数</span>为  $p(g)=\tfrac{h(g)}{N}$</p>
<p><span id="累计分布函数">累计分布函数 </span>$F(g)=P(g(i,j)\le g)=\tfrac{H(g)}{N}$</p>
<h2 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h2><p><strong>均值</strong> (Mean):描述图像的<strong>亮度</strong>；</p>
<p><strong>方差</strong> (Variance):描述图像的<strong>对比度</strong>；</p>
<p><strong>中值</strong> (Median):描述图像的<strong>亮度</strong>，比均值<strong>更加鲁棒</strong>；</p>
<h1 id="图像直方图变换"><a href="#图像直方图变换" class="headerlink" title="图像直方图变换"></a>图像直方图变换</h1><h2 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h2><p>仅基于输入的单点像素值进行映射， 将其映射到一个新的像素值；对某一点像素值的映射只与它本身有 关，与其他位置的像素值无关。</p>
<script type="math/tex; mode=display">
v_{new}=f(v)\\
b(i,j)=f(a(i,j),\boldsymbol p)\quad [i,j] \in [1,\cdots,I]\times[1,\cdots,J]</script><p>其中，输入像素值为 $a(i,j)$ ,输出像素值为 $b(i,j)$ ,操作函数为 $f$,操作函数参数为 $\boldsymbol p$.</p>
<p>示例及效果：</p>
<script type="math/tex; mode=display">
\begin{aligned}f(a,\boldsymbol{p})&=\quad k+m a\quad\boldsymbol{p}=[k,m]^\top\\b(i,j)&=\quad k+m a(i,j)\end{aligned}</script><p>变换后的新图像的均值和方差分别为:$\mu_b=k+m \mu_a\quad\sigma_b=\left|m\right|\sigma_a$</p>
<p>参数改变对于图像的影响如下:</p>
<ul>
<li>k&gt;0 ,增大亮度；反之减小亮度。</li>
<li>$0<m<1$ 减小对比度，$m>1$增大对比度</li>
<li>$m=-1$ 亮变暗，暗变亮，对比度反转。</li>
</ul>
<h2 id="概率密度函数的转变"><a href="#概率密度函数的转变" class="headerlink" title="概率密度函数的转变"></a>概率密度函数的转变</h2><p>假定我们通过函数$f$把进行了图像变换，现在来讨论一下，原来图像的<a href="#jump">概率密度函数</a> $h_a(a)$ 和$f$ 函数作用后的概率密度函数$h_b(b)$ 的关系。</p>
<p>根据映射前和映射后区域面积相等，即 $h_a(a)\mathrm da=h_b(b)\mathrm db$</p>
<p>可以得到</p>
<script type="math/tex; mode=display">
\tag{2.2}
\begin{align}
h_b(b)&=\tfrac{h_a(a)}{|\tfrac{\mathrm db}{\mathrm da}|}\\
&=\tfrac{h_a(a)}{f'(a)}\\
&=\tfrac{h_a(f^{-1}(b))}{f'(f^{-1}(b))}
\end{align}</script><h2 id="直方图均衡化-Histogram-Equalization"><a href="#直方图均衡化-Histogram-Equalization" class="headerlink" title="直方图均衡化(Histogram Equalization)"></a>直方图均衡化(Histogram Equalization)</h2><p>其目标是使得直方图的每个柱条内的高度，即对应<strong>每个像素值的像素个数相等</strong>。即：</p>
<script type="math/tex; mode=display">
 h_b(b)=const</script><p>假设该常数为 $k$ ,将 $h_b(b)=k$ 带入式（2.2）可得：</p>
<script type="math/tex; mode=display">
\tag{2.3}
\mathrm d b=\frac{1}{k}h_a(a)\mathrm d a</script><p>这是一个微分方程，加上边界条件</p>
<script type="math/tex; mode=display">
\tag{边界条件}
f(0)=0\\
f(255)=255</script><p>我们可以求得式（2.3）的解为</p>
<script type="math/tex; mode=display">
\tag{解}
b=f(a)=\frac{1}{k}H(a)+C\\
k=\frac{N-H(0)}{255}\\
C=-H(0)\frac{255}{N-H(0)}</script><p>这里面的 $H(0)$ 即累计图像直方图</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Vision-齐次坐标和相机内外参</title>
    <url>/2024/11/15/Computer-Vision-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E5%92%8C%E7%9B%B8%E6%9C%BA%E5%86%85%E5%A4%96%E5%8F%82/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp-24-09-15</title>
    <url>/2024/09/15/Cpp-24-09-15/</url>
    <content><![CDATA[<h1 id="洛谷P1216"><a href="#洛谷P1216" class="headerlink" title="洛谷P1216"></a>洛谷P1216</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>最近有 n<em>n</em> 个不爽的事，每句话都有一个正整数刺痛值（心理承受力极差）。爱与愁大神想知道连续 m<em>m</em> 个刺痛值的和的最小值是多少，但是由于业务繁忙，爱与愁大神只好请你编个程序告诉他。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个用空格隔开的整数，分别代表 n和m。</p>
<p>第 22 到第 (n+1)行，每行一个整数，第 (i+1)行的整数 ai代表第 i件事的刺痛值 ai。</p>
<h2 id="提交答案-一重循环"><a href="#提交答案-一重循环" class="headerlink" title="提交答案(一重循环)"></a>提交答案(一重循环)</h2><p>```C++</p>
<h1 id="define-CRT-SECURE-NO-WARNINGS-1"><a href="#define-CRT-SECURE-NO-WARNINGS-1" class="headerlink" title="define _CRT_SECURE_NO_WARNINGS 1"></a>define _CRT_SECURE_NO_WARNINGS 1</h1><h1 id="include-cin-cout"><a href="#include-cin-cout" class="headerlink" title="include   // cin,cout"></a>include <iostream>  // cin,cout</h1><h1 id="include-数学函数"><a href="#include-数学函数" class="headerlink" title="include     //数学函数"></a>include <cmath>    //数学函数</h1><h1 id="include-C语言的printf，scanf"><a href="#include-C语言的printf，scanf" class="headerlink" title="include   //C语言的printf，scanf"></a>include<cstdio>   //C语言的printf，scanf</h1><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<cstring></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<string></h1><p>using namespace std;</p>
<p>int main() {<br>    int n, m;<br>    int sum=0;<br>    int min ;<br>    int a[3000] = {0};<br>    int tmp;<br>    cin &gt;&gt; n &gt;&gt; m;</p>
<pre><code>for (int i = 0; i &lt; n; i++) &#123;
    cin &gt;&gt; tmp;        //接受变量

    if (i &lt; m) &#123;
        //如果是刚开始输入的前m个数字，直接累加
        sum += tmp;
        min = sum;//暂时认为最小值是前m个的
    &#125;

    else
        sum = sum + tmp - a[i%m];//如果是后续输入的超过m个数字，累加之后减去前面的第m个
    a[i % m] = tmp;        //赋值给数组，必须在sum = sum + tmp - a[i%m];，之前，这样才是先计算sum，再覆盖数组的值。
    //判断是否是最短的    
    if (sum &lt; min)
        min = sum;


&#125;
cout &lt;&lt; min;
return 0;
</code></pre><p>}</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoDL使用教程</title>
    <url>/2024/08/19/AutoDL%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Pycharm-SSH连接"><a href="#Pycharm-SSH连接" class="headerlink" title="Pycharm-SSH连接"></a>Pycharm-SSH连接</h1><h2 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义:"></a>参数含义:</h2><p><code>ssh -p 38076 root@region-1.autodl.com</code></p>
<ul>
<li><p><strong>主机</strong>:region-1.autodl.com</p>
</li>
<li><p><strong>端口</strong>:38076</p>
</li>
<li><p><strong>用户名</strong>:root</p>
</li>
</ul>
<h2 id="连接方法"><a href="#连接方法" class="headerlink" title="连接方法:"></a>连接方法:</h2><h3 id="Case1：新建项目"><a href="#Case1：新建项目" class="headerlink" title="Case1：新建项目"></a>Case1：新建项目</h3><p>文件——&gt;新建项目——&gt;先前配置好的解释器 添加解释器 SSH </p>
<p>SSH连接选择“新建”(如果之前配置过这个服务器也可以选择”现有“)——&gt;输入主机、用户名、端口(注意不要输入多余的空格之类的)——等待”内省远程服务器”——&gt;”项目目录和Python运行时配置”,这一步选择远程服务器中的Python环境，解释器的默认位置是/root/miniconda3/bin/python，如果您在miniconda中安装了其他的虚拟环境，那么虚拟环境的python解释器路径在/root/miniconda3/envs/{对应的虚拟环境名称}/bin/python）</p>
<h3 id="Case2：现有的项目"><a href="#Case2：现有的项目" class="headerlink" title="Case2：现有的项目"></a>Case2：现有的项目</h3><p>重新配置Python解释器，选择新建,SSH连接，按照Case1的方式进行即可。</p>
<h2 id="连接成功后的交互问题"><a href="#连接成功后的交互问题" class="headerlink" title="连接成功后的交互问题"></a>连接成功后的交互问题</h2><h3 id="浏览远程主机"><a href="#浏览远程主机" class="headerlink" title="浏览远程主机"></a>浏览远程主机</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>Pycharm最上方”工具”，部署，浏览远程主机</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>Pycharm最右边，”远程主机”</p>
<h3 id="启动远程终端"><a href="#启动远程终端" class="headerlink" title="启动远程终端"></a>启动远程终端</h3><p>Pycharm最上方”工具”，启动SSH会话，选择你连接的服务器。</p>
<p>也可以在下面的地方找到终端:</p>
<img src="/2024/08/19/AutoDL%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/2024-08-20-08-42-10-image.png" class="">
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>Pycharm最上方”工具”，部署，配置，映射</p>
<p>“本地路径”是本地的项目路径</p>
<p>“部署路径”是远程服务器的映射路径</p>
<h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="Case1-本地文件传输到远程服务器"><a href="#Case1-本地文件传输到远程服务器" class="headerlink" title="Case1:本地文件传输到远程服务器"></a>Case1:本地文件传输到远程服务器</h3><p>如果是本地新建的文件，可以在文件中或者右键点击待传输的文件，选择”部署”，”上传到”，这时候就会把本地的文件传输到映射好的目录中，文件夹也适用于此操作。</p>
<p>如果是在Pycharm中打开远程服务器中的文件，并且做了一些修改，那么在文件最上方就会提示”该文件已被修改，是否上传？”，选择最右边的图标，“上传当前文件，Ctrl+shift+Q”即可。</p>
<p>如果需要批量上传，可以将标签页切换到一个本地的文件(如果标签页是远程服务器的文件，有点选项可能是灰色)，然后右键，部署，”将所有打开的文件上传到”，即可。</p>
<h3 id="Case2-远程服务器文件下载到本地"><a href="#Case2-远程服务器文件下载到本地" class="headerlink" title="Case2:远程服务器文件下载到本地"></a>Case2:远程服务器文件下载到本地</h3><p>先打开远程主机的界面，选择你要下载的文件，右键，从此处下载即可。</p>
<h1 id="网盘传输数据"><a href="#网盘传输数据" class="headerlink" title="网盘传输数据"></a>网盘传输数据</h1><h2 id="阿里网盘"><a href="#阿里网盘" class="headerlink" title="阿里网盘"></a>阿里网盘</h2><p>租完服务器后，在”容器实例”界面，快捷工具，”AutoPanel”，然后进入到AutoPanel界面，选择”公网网盘”，选择阿里网盘，然后扫码授权登录。</p>
<p>可以选择授权范围，有”备份盘””资源库”或者二者都授权。</p>
<p>选择你要下载的文件，点击下载，默认下载路径为:<code>/root/autodl-temp</code></p>
<p>也可以把自己再远程服务器的数据下载到网盘中</p>
<h2 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h2><p>较为复杂，暂未尝试</p>
<h1 id="xftp连接"><a href="#xftp连接" class="headerlink" title="xftp连接"></a>xftp连接</h1><p>下载Xshell的XFTP软件</p>
<p>还是采用的SSH连接。</p>
<p>可视化界面，支持拖拽。</p>
<p>单个文件（比如压缩包）可以达到5、6M每秒，但是如果是一个文件夹，速度就很慢了。</p>
<h1 id="Jupyter-Lab上传数据-最快"><a href="#Jupyter-Lab上传数据-最快" class="headerlink" title="Jupyter Lab上传数据(最快)"></a>Jupyter Lab上传数据(最快)</h1><p>由于Jupyter Lab只能上传单个的文件，所以可以先把文件压缩好，然后再解压缩。</p>
<blockquote>
<p>注意：此过程中可能会存在中途传输错误的情况，需要重新传输即可 。</p>
</blockquote>
<h2 id="本地压缩"><a href="#本地压缩" class="headerlink" title="本地压缩"></a>本地压缩</h2><p>本地的文件夹压缩的格式要求是zip或者rar4,由于rar格式指的是rar5,和rar4格式不一样！</p>
<blockquote>
<p>JupyterLab的工作目录为<code>/root</code>目录，而非<code>/</code>系统根目录</p>
</blockquote>
<h2 id="Jupyter-Lab上传单个文件"><a href="#Jupyter-Lab上传单个文件" class="headerlink" title="Jupyter Lab上传单个文件"></a>Jupyter Lab上传单个文件</h2><p>租完服务器后，在”容器实例”界面，快捷工具，”Jupyter Lab”,进入到下面的界面。</p>
<img src="/2024/08/19/AutoDL%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/2024-08-20-09-16-12-image.png" class="">
<p>点击上述图标即可上传文件。</p>
<p>上传文件后，选择解压缩工具。</p>
<h2 id="解压缩工具及其指令"><a href="#解压缩工具及其指令" class="headerlink" title="解压缩工具及其指令"></a>解压缩工具及其指令</h2><h3 id="arc工具（需要下载，不支持rar5"><a href="#arc工具（需要下载，不支持rar5" class="headerlink" title="arc工具（需要下载，不支持rar5)"></a>arc工具（需要下载，不支持rar5)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载安装工具</span></span><br><span class="line">curl -L -o /usr/<span class="built_in">bin</span>/arc http://autodl-public.ks3-cn-beijing.ksyun.com/tool/arc &amp;&amp; chmod +x /usr/<span class="built_in">bin</span>/arc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩/打包</span></span><br><span class="line">arc compress xxx.<span class="built_in">zip</span> path/to/directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">arc decompress xxx.<span class="built_in">zip</span> </span><br><span class="line">或者解压到指定目录</span><br><span class="line">arc decompress xxx.<span class="built_in">zip</span> path/to/directory</span><br></pre></td></tr></table></figure>
<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><blockquote>
<p>Linux系统自带了许多用于压缩和解压缩文件的命令。以下是一些常见的命令及其对应的文件格式：</p>
<h3 id="压缩命令："><a href="#压缩命令：" class="headerlink" title="压缩命令："></a>压缩命令：</h3><ol>
<li><strong><code>tar</code></strong>:<ul>
<li>常用于创建 <code>.tar</code>、<code>.tar.gz</code>、<code>.tar.bz2</code>、<code>.tar.xz</code> 等格式的压缩文件。</li>
<li>示例：<code>tar -czvf archive.tar.gz files/</code>（创建一个gzip压缩的tar文件）</li>
<li>示例：<code>tar -cjvf archive.tar.bz2 files/</code>（创建一个bzip2压缩的tar文件）</li>
<li>示例：<code>tar -cJvf archive.tar.xz files/</code>（创建一个xz压缩的tar文件）</li>
</ul>
</li>
<li><strong><code>gzip</code></strong>:<ul>
<li>用于压缩单个文件，创建 <code>.gz</code> 格式的文件。</li>
<li>示例：<code>gzip file.txt</code>（压缩文件并删除原文件）</li>
</ul>
</li>
<li><strong><code>bzip2</code></strong>:<ul>
<li>用于创建 <code>.bz2</code> 格式的压缩文件。</li>
<li>示例：<code>bzip2 file.txt</code>（压缩文件并删除原文件）</li>
</ul>
</li>
<li><p><strong><code>zip</code></strong>:</p>
<ul>
<li>用于创建 <code>.zip</code> 格式的压缩文件。</li>
<li><p>示例：<code>zip archive.zip file1.txt file2.txt</code>（将多个文件压缩成一个zip文件）</p>
<h3 id="解压缩命令："><a href="#解压缩命令：" class="headerlink" title="解压缩命令："></a>解压缩命令：</h3></li>
</ul>
</li>
<li><strong><code>tar</code></strong>:<ul>
<li>解压缩 <code>.tar</code>、<code>.tar.gz</code>、<code>.tar.bz2</code>、<code>.tar.xz</code> 等格式的文件。</li>
<li>示例：<code>tar -xzvf archive.tar.gz</code>（解压gzip压缩的tar文件）</li>
<li>示例：<code>tar -xjvf archive.tar.bz2</code>（解压bzip2压缩的tar文件）</li>
<li>示例：<code>tar -xJvf archive.tar.xz</code>（解压xz压缩的tar文件）</li>
</ul>
</li>
<li><strong><code>gzip</code></strong>:<ul>
<li>解压缩 <code>.gz</code> 格式的文件。</li>
<li>示例：<code>gunzip file.txt.gz</code>（解压缩文件并删除原压缩文件）</li>
<li>或者：<code>gzip -d file.txt.gz</code>（与gunzip相同）</li>
</ul>
</li>
<li><strong><code>bzip2</code></strong>:<ul>
<li>解压缩 <code>.bz2</code> 格式的文件。</li>
<li>示例：<code>bunzip2 file.txt.bz2</code>（解压缩文件并删除原压缩文件）</li>
<li>或者：<code>bzip2 -d file.txt.bz2</code>（与bunzip2相同）</li>
</ul>
</li>
<li><p><strong><code>unzip</code></strong>:</p>
<ul>
<li>解压缩 <code>.zip</code> 格式的文件。</li>
<li><p>示例：<code>unzip archive.zip</code>（解压缩zip文件）<br>请注意，<code>zip</code> 和 <code>unzip</code> 命令可能不在所有Linux发行版中默认安装，但通常可以通过包管理器轻松安装。例如，在Debian或Ubuntu系统中，可以使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install zip unzip</span><br></pre></td></tr></table></figure>
<p>上述命令涵盖了Linux系统中常见的压缩和解压缩工具。这些工具通常足以处理日常的文件压缩需求。</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.autodl.com/docs/ssh_proxy/">Auto帮助文档-SSH隧道</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>autodl</tag>
        <tag>远程服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures and Algorithms-Graph</title>
    <url>/2024/11/17/Data-Structures-and-Algorithms-Graph/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><p>用A(G)表示图G的邻接矩阵，$a_{ij}$指的是顶点$v_i$和$v_j$的连接信息。</p>
<p>如果是有向图，$a_{ij}$指的是顶点$v_i$到$v_j$有无有向边。</p>
<p>无向图的邻接矩阵对称，可压缩存储；有向图邻接矩阵不一定对称。</p>
<p><strong>有向图中，
</strong>  顶点Vi的出度是邻接矩阵中第i行元素之和</p>
<p> 顶点Vi的入度是邻接矩阵中第i列元素之和。</p>
<p>有向图和无向图中不邻接的顶点是0，但是对于带权图，不不邻接的顶点是无穷。</p>
<p>优缺点：</p>
<ul>
<li>优点<ul>
<li><strong>便于判断两个顶点之间是否有边。<br> 便于计算各个顶点的度。</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>不便于增加和删除顶点。</li>
<li>不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为0(n2)。</li>
<li>空间复杂度高。对于稀疏图而言尤其浪费空间。</li>
</ul>
</li>
</ul>
<h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>思路是，为图中每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点Vi的边(有向图中指以Vi为尾的弧)，再用一个顶点数组指向每个单链表。</p>
<ul>
<li>定点表结点：<ul>
<li>vexinfo:顶点信息</li>
<li>firstarc:第一条关联边结点</li>
</ul>
</li>
<li>边表结点：<ul>
<li>adjvex:临接结点位置</li>
<li>arcinfo：边的信息</li>
<li>nextarc:下一条关联边边表结点</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arcnode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arcnode</span>* <span class="title">nextarc</span>;</span>  <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125;Arcnode;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>无向图中，单链表中,Arc结点个数=边数*2</p>
<p>有向图中，单链表中,Arc结点个数=弧数</p>
</li>
<li><p>无向图中顶点Vi的度为：第i个单链表中的结点数</p>
<p>有向图中顶点Vi的<strong>出度</strong>为：第i个单链表中的结点数,顶点Vi的<strong>入度</strong>为：整个单链表中邻接点域为i的结点个数;</p>
</li>
</ul>
<h2 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h2><p>有向图中对每个结点建立以Vi为头的弧的单链表</p>
<p>找逆邻接点容易</p>
<h2 id="邻接表（网）"><a href="#邻接表（网）" class="headerlink" title="邻接表（网）"></a>邻接表（网）</h2><p>网：边上带有权值的图</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>adjvex</th>
<th>weight</th>
<th>nextarc</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><p>优点</p>
<ul>
<li><p>便于增加和删除顶点</p>
</li>
<li><p>便于统计边的数目</p>
</li>
<li><p>空间效率高</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>缺点</p>
<ul>
<li>不便于判断定点之间是否有边</li>
<li>不便于计算有向图各个顶点的度</li>
</ul>
</li>
</ul>
<h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><ul>
<li>头节点<ul>
<li>vexinfo:顶点的信息</li>
<li>firstin:第一条关联入狐结点</li>
<li>firstout:第一条关联出弧结点</li>
</ul>
</li>
<li>表结点<ul>
<li>tailvex:弧尾结点位置</li>
<li>headvex:弧头结点位置</li>
<li>arcinfo:弧的信息</li>
<li>tnext:弧尾相同的下一条弧</li>
<li>hnext:弧头相同的下一条弧</li>
</ul>
</li>
</ul>
<h2 id="多重邻接链表"><a href="#多重邻接链表" class="headerlink" title="多重邻接链表"></a>多重邻接链表</h2><ul>
<li>头节点存储<ul>
<li>vexinfo:顶点的信息</li>
<li>firstedge:第一条关联边结点</li>
</ul>
</li>
<li>边结点存储<ul>
<li>flag:标志域，是否遍历过</li>
<li>einfo:边的信息</li>
<li>ivex:边的第一个顶点位置</li>
<li>inext:边的另一个顶点位置</li>
<li>jvex:边的另一个顶点位置</li>
<li>jnext:顶点j的下一条关联边</li>
</ul>
</li>
</ul>
<h2 id="十字链表和邻接多重表的比较"><a href="#十字链表和邻接多重表的比较" class="headerlink" title="十字链表和邻接多重表的比较"></a>十字链表和邻接多重表的比较</h2><p><strong>十字链表：</strong></p>
<p>专门用于表示有向图。</p>
<p><strong>每个顶点都有两个链表：一个是出弧链表，用于存储从该顶点出发的所有边；另一个是入弧链表，用于存储指向该顶点的所有边。</strong></p>
<p><strong>这种表示法使得查询任何顶点的入度和出度都变得非常简单和快速。</strong></p>
<p><strong>工程应用：</strong></p>
<p>适用于需要频繁查询顶点入度或出度的应用场景，例如某些依赖性分析、工作流管理等。**</p>
<p><strong>用于网络流算法中，需要快速访问入弧和出弧，如最大流问题。</strong></p>
<p><strong>邻接多重表：</strong></p>
<p><strong>专门用于表示**</strong>无向图。**</p>
<p><strong>相较于邻接表，邻接多重表只为每条边存储一次，从而更加节省空间。</strong></p>
<p><strong>便于判断边是否存在，以及快速删除边。</strong></p>
<p><strong>工程应用：</strong></p>
<p><strong>适用于需要频繁添加或删除边的应用场景。</strong></p>
<p><strong>在网络设计和拓扑结构分析中，这种数据结构可以帮助有效地查询和管理连接。</strong></p>
<p><strong>在无向图的算法中，如最小生成树、图的双连通分量分析等，都可以考虑使用邻接多重表。</strong></p>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h2><ul>
<li>访问一个顶点V，然后访问该顶点邻接到的未被访问过的顶点V’，</li>
<li>再从V’出发递归地按照深度优先的方式周游，</li>
<li>当遇到一个所有邻接于它的顶点都被访问过了的顶点U时，则回到已访问顶点序列中最后一个拥有未被访问的相邻顶点的顶点W，</li>
<li>再从W出发递归地按照深度优先的方式周游，</li>
<li>最后，当任何已被访问过的顶点都没有未被访问的相邻顶点时，则周游结束。</li>
</ul>
<p>图的遍历顺序未必唯一。</p>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>它的基本思想是</p>
<ul>
<li>访问顶点V0，</li>
<li>然后访问V0邻接到的所有未被访问过的顶点V01，V02，…V0i，</li>
<li>再依次访问V01，V02，…V0i邻接到的所有未被访问的顶点，</li>
<li>如此进行下去r，直到访问遍所有的顶点。</li>
</ul>
<p>用<font color="red">队列</font> 实现广度优先遍历。</p>
<p>因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，两种遍历方法的不同之处仅仅在于对顶点访问的顺序不同。</p>
<p>用邻接矩阵表示图的时候，查找每个顶点的邻接点的复杂度为$O(n^2)$, $n$为顶点数。</p>
<p>当以邻接表做图的存储结构时，查找邻接点的时间复杂度为O(e),其中e为图中边数，深度优先搜索 遍历图的时间复杂度为O(n+e)。</p>
<h1 id="拓扑排序和关键路径"><a href="#拓扑排序和关键路径" class="headerlink" title="拓扑排序和关键路径"></a>拓扑排序和关键路径</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序（Topological Sort）就是从某积和上的一个偏序得到该集合的一个全序。、</p>
<p>用顶点表示活动，用弧表示活动之间优先级关系的有向图成为顶点表示活动的网络（Activity On Vertex Network）即AOV-网。</p>
<p>在AOV-网中，不应该出现有向环，因为存在有向环证明某项活动以自己为先决条件，这显然是谬误的。</p>
<p>实现拓扑排序：</p>
<ul>
<li>在有向图中选一个没有前驱的顶点输出之；</li>
<li>从图中删除该顶点和所有以它为尾的弧。</li>
<li>重复上述两步，直至全部顶点都已经输出，或者当前图中不存在无前驱的顶点为止，后一种情况说明无向图中存在环。</li>
</ul>
<h3 id="有向图的邻接表实现："><a href="#有向图的邻接表实现：" class="headerlink" title="有向图的邻接表实现："></a>有向图的邻接表实现：</h3><p>注：邻接表是尾每一个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点$v_i$的边（对于有向图是以顶点$v_i$为尾的弧）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//边的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Arcnode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该弧指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Arcnode</span>* nextarc;<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    InfoType* info;<span class="comment">//该弧相关信息的指针</span></span><br><span class="line">&#125;Arcnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结构体</span></span><br><span class="line"><span class="comment">//对于该任务，我们新增一个域，即入度域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Vnode</span>&#123;</span><br><span class="line">    VertexType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> in;<span class="comment">//入度域</span></span><br><span class="line">    Arcnode* firstarc;  <span class="comment">//指向该顶点的第一条出边</span></span><br><span class="line">&#125;Arcnode,AdjList[Max_Vertex_Num];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;<span class="comment">//图的顶点集合（邻接表）</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">// 图的顶点数图的边数</span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>AdjList</code> 定义了一个数组类型，数组大小是 <code>Max_Vertex_Num</code>，表示图中最多可以存储 <code>Max_Vertex_Num</code> 个顶点。<code>AdjList vertices;</code>表示</p>
<h3 id="求各个顶点入度的函数"><a href="#求各个顶点入度的函数" class="headerlink" title="求各个顶点入度的函数"></a>求各个顶点入度的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountInDegreee</span><span class="params">(ALGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    Arcnode* p；<span class="comment">//设一个指针用于表示弧</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G.vexnum;i++)&#123;</span><br><span class="line">        G.vertices[i]-&gt;in=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//初始时全部设置为0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G.vexnum;i++)&#123;<span class="comment">//遍历结点</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;<span class="comment">//遍历所有有向弧</span></span><br><span class="line">            G.vertices[p-&gt;adjvex]-&gt;in++;<span class="comment">//该弧指向的结点的入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓扑排序的时候，</p>
<ul>
<li><p>1）求出各顶点的入度存入数组indegree［i］中，并将入度为0的顶点入栈。</p>
</li>
<li><p>2）只要栈不空，则重复以下操作： 将栈顶顶点vi出栈并保存在拓扑序列数组topo中; 对顶点vi的每个邻接点vk的入度减1,如果vk的入度变为0,则将n入栈。 </p>
</li>
<li><p>3）如果输出顶点个数少于AOV-网的顶点个数，则网中存在有向环，无法进行拓 扑排序，否则拓扑排序成功。</p>
</li>
</ul>
<h3 id="拓扑排序函数"><a href="#拓扑排序函数" class="headerlink" title="拓扑排序函数:"></a>拓扑排序函数:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> count; <span class="comment">//记载排好序的数量</span></span><br><span class="line">    ArcNode *p; <span class="comment">//由于表示某一个结点的弧</span></span><br><span class="line">    <span class="type">int</span> S[max];<span class="comment">//栈，用于存储入度为0的结点</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;<span class="comment">//栈顶</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.计算每一个顶点的入度</span></span><br><span class="line">    CountInDegree(G);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.入度为0的结点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vertices[i].in==<span class="number">0</span>)&#123;</span><br><span class="line">            S[top++]=i; <span class="comment">//入栈，栈顶指针+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.重复检测栈是否为空</span></span><br><span class="line">    <span class="keyword">while</span>(top!==<span class="number">0</span>)&#123;</span><br><span class="line">        j=S[--top]; <span class="comment">//得到栈顶元素的结点编号</span></span><br><span class="line">        count++;<span class="comment">//出栈了一个元素，计数器+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顶点%d&quot;</span>,j);</span><br><span class="line">        <span class="comment">//3.1 将出栈顶点的所有边断开，然后更新与之相连的结点的度</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;<span class="comment">//弧p 指向的顶点编号</span></span><br><span class="line">            <span class="keyword">if</span>(--G.vertices[k].in==<span class="number">0</span>)&#123;<span class="comment">//将弧p指向的结点的入度-1，检测此时入度是否为0</span></span><br><span class="line">                S[top++]=k;<span class="comment">//结点k入栈               </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断输出结点是否小于图的结点个数</span></span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)&#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>与AOV-网相对应的是AOE-网（Activity On Edge）即边表示活动的网。AOE-网是一个<strong>带权的有向无环图。</strong></p>
<p>在AOE-网中，弧表示活动，顶点表示事件，权表示活动持续时间。事件必须要等到活动完成后才会发生。</p>
<p>比如：</p>
<img src="/2024/11/17/Data-Structures-and-Algorithms-Graph/image-20241201162538499.png" class="" alt="image-20241201162538499">
<p>通常，AOE-网可以估算工程的完成时间，比如上述图中，完成活动需要的最短时间就是27.</p>
<p>路径最长的路径叫做关键路径(Critical Path).</p>
<h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul>
<li>e(i)  活动i的最早开始时间</li>
<li>l(i)   活动i的最晚开始时间</li>
<li>dut(<j,k>)  活动i用弧<j,k>表示，持续时间为dut(<j,k>)</li>
<li>ve(j)    事件j的最早开始时间</li>
<li>vl(j)     事件j的最晚开始时间</li>
</ul>
<p>显然我们可以得到，<strong>一个活动最早开始的时间就是它的前驱事件的最早开始时间</strong>。即e(i)=ve(j),同时这个<strong>活动的最晚开始时间，就是他后继事件的最晚开始时间减去活动的持续时间</strong>，即v(i)=vl(k)-dut(<j,k>).</p>
<h4 id="ve-j-和vl-j-的求解"><a href="#ve-j-和vl-j-的求解" class="headerlink" title="ve(j)和vl(j)的求解"></a>ve(j)和vl(j)的求解</h4><p>对于一个事件j,为了求ve(j)，可以采取前向递推的方法求解:</p>
<p>ve(0)=0</p>
<p>ve(j)=Max{ve(i)+dut(<i,j>)},</p>
<p><i,k>∈T，j=1,2,~n-1.</p>
<p>其中，T是所有以第j个顶点为头的弧的集合。</p>
<p>对于一个事件j,为了求vl(j)，可以采取后向递推的方法求解:</p>
<p>vl(n-1)=ve(n-1)</p>
<p>vl(j)=Min{vl(j)-dut(<i,j>)},</p>
<p><i,k>∈S，j=n-2,~0</p>
<p>其中，S是所有以第i个顶点为尾的弧的集合。</p>
<h3 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h3><p>算法步骤： </p>
<ul>
<li>（1）输入顶点和弧信息，建立其邻接表 </li>
<li>（2）计算每个顶点的入度 </li>
<li>（3）对其进行拓扑排序 排序过程中求顶点（事件）的Ve[i] 将得到的拓扑序列进栈 </li>
<li>（4）按逆拓扑序列求顶点（事件）的Vl[i] </li>
<li>（5）计算每条弧（活动）的e[i]和l[i],找出e[i]=l[i]的关键活动</li>
</ul>
<p>首先，在拓扑排序的算法基础上，我们设置一个函数，可以在拓扑排序的同时，找到每一个结点的最长路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">QuiVe</span><span class="params">(ALGraph G,<span class="type">int</span> ve[M+<span class="number">1</span>],<span class="type">int</span> Sn[M+<span class="number">1</span>])</span>&#123;</span><br><span class="line">    <span class="comment">//Sn栈用于存储拓扑排序后的顶点顺序</span></span><br><span class="line">    <span class="type">int</span> S[M];     <span class="comment">//一个栈，用于保存当前入度为0的顶点。</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;    <span class="comment">//S栈指针</span></span><br><span class="line">    <span class="type">int</span> topnixu=<span class="number">0</span>; <span class="comment">//Sn栈的指针</span></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    ArcNode* p; <span class="comment">//弧的指针</span></span><br><span class="line">    <span class="comment">//1.将所有入度为0的结点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vertices[i].in==<span class="number">0</span>)&#123;</span><br><span class="line">            S[top++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.循环检测，实现拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1栈顶元素出栈</span></span><br><span class="line">        j=S[--top];<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        count++;<span class="comment">//计数器+1</span></span><br><span class="line">        Sn[topnixu++] = j;  <span class="comment">// 记录拓扑排序结果，Sn存储顺序</span></span><br><span class="line">        <span class="comment">//2.2更新入度</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j]-&gt;firstarc;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;<span class="comment">//k是弧p的后继节点</span></span><br><span class="line">            <span class="keyword">if</span>(--G.vertices[k].in==<span class="number">0</span>)&#123;<span class="comment">//如果更新后入度为0</span></span><br><span class="line">                S[top++]=k; <span class="comment">//将该结点入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.3更新事件最早开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(ve[j]+p-&gt;length&gt;ve[k])&#123;</span><br><span class="line">                ve[k]=ve[j]+p-&gt;length;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count&lt;G.vexnum)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求关键路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(ALGraph G,<span class="type">int</span> ve[M+<span class="number">1</span>],<span class="type">int</span> Sn[M+<span class="number">1</span>])</span>&#123;</span><br><span class="line">    <span class="type">int</span> topnixu=M; <span class="comment">//拓扑排序结果的指针，将其即为M,因为求vl需要反向递推</span></span><br><span class="line">    <span class="type">int</span> j,k;</span><br><span class="line">    <span class="type">int</span> ee;    <span class="comment">//存储某条边的开始时间</span></span><br><span class="line">    <span class="type">int</span> el;    <span class="comment">//存储某条边的结束时间</span></span><br><span class="line">    <span class="type">int</span> vl[M+<span class="number">1</span>]; <span class="comment">//事件的最晚开始时间</span></span><br><span class="line">    <span class="comment">//1.初始化最晚开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G.vexnum;++i)&#123;<span class="comment">//从2开始</span></span><br><span class="line">        vl[i]=ve[M];    <span class="comment">//初始化最晚完成时间为 ve[M]（即最长路径的长度）        </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.计算每个顶点的最晚开始时间：</span></span><br><span class="line">    <span class="keyword">while</span>(topnixu!=<span class="number">0</span>)&#123;</span><br><span class="line">        j=Sn[--topnixu];   <span class="comment">//取出栈顶元素</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="comment">//更新每个节点的最晚完成时间</span></span><br><span class="line">            <span class="keyword">if</span>((vl[k] - p-&gt;length) &lt; vl[j]) &#123;</span><br><span class="line">                vl[j]=vl[k] - p-&gt;length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算关键路径</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=G.vexnum;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;nextarc;</span><br><span class="line">            ee=ve[j];<span class="comment">//该边的最早开始时间</span></span><br><span class="line">            el=vl[k]-p-&gt;length;<span class="comment">//该边的最晚开始时间，等于后继节点的最晚开始时间减去该边长度</span></span><br><span class="line">            <span class="comment">//如果某一个边的最短开始时间和最晚开始时间相同，就是关键路径。</span></span><br><span class="line">            <span class="keyword">if</span>(ee==el)&#123;</span><br><span class="line">                <span class="built_in">printf</span>((<span class="string">&quot;%d到%d长度为%d的边为关键活动\n&quot;</span>, j, k, p-&gt;length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures and Algorithms-array.md</title>
    <url>/2024/10/29/Data%20Structures%20and%20Algorithms-array/</url>
    <content><![CDATA[<h1 id="矩阵快速转置算法"><a href="#矩阵快速转置算法" class="headerlink" title="矩阵快速转置算法"></a>矩阵快速转置算法</h1><p>当稀疏矩阵以三元组形式存储在计算机中时，转置会破坏掉原有矩阵的顺序性，比如原来矩阵的存储中，依次是：第一行第一个非零元素、第一行第二个非零元素~~~但是简单的交换行和列会破坏掉这些结构。矩阵的快速转置算法可以解决上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//最多的个数</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三元组结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j; <span class="comment">//行标和列标</span></span><br><span class="line">	<span class="type">float</span> e; <span class="comment">//假设是单精度浮点型变量构成的矩阵</span></span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="comment">//矩阵结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	Triple data[MAXSIZE + <span class="number">1</span>];  <span class="comment">//第一个元素不用，矩阵的下标从1开始</span></span><br><span class="line">	<span class="type">int</span> rowNum, colNum, allNum;  <span class="comment">//分别是行数、列数和非零元素个数</span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速转置算法</span></span><br><span class="line"><span class="function">TSMatrix* <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix *T)</span> </span>&#123; <span class="comment">//两个参数分别是原来的矩阵和转置后的指针</span></span><br><span class="line">	<span class="type">int</span> num[MAXSIZE] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//每一行的非零元素个数，初始化为0</span></span><br><span class="line">	<span class="type">int</span> cpot[MAXSIZE];  <span class="comment">//原始矩阵的某一列的第一个非零元素在结果中的下标位置。</span></span><br><span class="line">	<span class="comment">//统计原始矩阵中每一列的非零元素个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M.allNum; i++) &#123; </span><br><span class="line">		num[M.data[i].j]++;  </span><br><span class="line">	&#125;</span><br><span class="line">	cpot[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//初始化，第一个非零元素的位置是1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定原始矩阵的每一个列的第一个非零元素的位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= M.colNum; i++) &#123;</span><br><span class="line">		cpot[i] = num[i - <span class="number">1</span>] + cpot[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转置后矩阵的行数、列数、总元素个数等信息</span></span><br><span class="line">	T-&gt;rowNum = M.colNum;</span><br><span class="line">	T-&gt;colNum = M.rowNum;</span><br><span class="line">	T-&gt;allNum = M.allNum;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历原来的矩阵，根据构建的对应关系转置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> elem = <span class="number">1</span>; elem &lt;= M.allNum; elem++) &#123;</span><br><span class="line">		<span class="type">int</span> col = M.data[elem].j; <span class="comment">//确定这个元素在原来矩阵中的列</span></span><br><span class="line">		<span class="type">int</span> row = M.data[elem].i; <span class="comment">//确定这个元素在原来矩阵中的行</span></span><br><span class="line"></span><br><span class="line">		T-&gt;data[cpot[col]].e = M.data[elem].e; <span class="comment">//将原来矩阵的这个位置的值复制到合适的位置</span></span><br><span class="line">		T-&gt;data[cpot[col]].i = col; <span class="comment">//原来的列变成行</span></span><br><span class="line">		T-&gt;data[cpot[col]].j = row; <span class="comment">//原来的行变成列</span></span><br><span class="line">		cpot[col]++;  <span class="comment">//非零元素的位置+1，以便下一个元素进行操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMatrix</span><span class="params">(TSMatrix M)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;行数: %d, 列数: %d, 非零元素个数: %d\n&quot;</span>, M.rowNum, M.colNum, M.allNum);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M.allNum; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) : %.2f\n&quot;</span>, M.data[i].i, M.data[i].j, M.data[i].e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否存在相同位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exists</span><span class="params">(TSMatrix M, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M.allNum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (M.data[i].i == row &amp;&amp; M.data[i].j == col) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机数种子</span></span><br><span class="line"></span><br><span class="line">	TSMatrix M;</span><br><span class="line">	M.rowNum = <span class="number">5</span>; <span class="comment">// 行数</span></span><br><span class="line">	M.colNum = <span class="number">5</span>; <span class="comment">// 列数</span></span><br><span class="line">	M.allNum = <span class="number">0</span>; <span class="comment">// 非零元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成随机稀疏矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123; <span class="comment">// 假设最多有10个非零元素</span></span><br><span class="line">		<span class="type">int</span> row, col;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			row = <span class="built_in">rand</span>() % M.rowNum + <span class="number">1</span>; <span class="comment">// 随机行</span></span><br><span class="line">			col = <span class="built_in">rand</span>() % M.colNum + <span class="number">1</span>; <span class="comment">// 随机列</span></span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="built_in">Exists</span>(M, row, col)); <span class="comment">// 检查是否已经存在该位置的元素</span></span><br><span class="line">		<span class="type">float</span> value = (<span class="type">float</span>)(<span class="built_in">rand</span>() % <span class="number">100</span>) / <span class="number">10</span>; <span class="comment">// 随机值</span></span><br><span class="line">		M.allNum++;</span><br><span class="line">		M.data[M.allNum].i = row;</span><br><span class="line">		M.data[M.allNum].j = col;</span><br><span class="line">		M.data[M.allNum].e = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;原始矩阵:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">PrintMatrix</span>(M);</span><br><span class="line"></span><br><span class="line">	TSMatrix T; <span class="comment">// 转置后的矩阵</span></span><br><span class="line">	<span class="built_in">FastTransposeSMatrix</span>(M, &amp;T);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n转置后的矩阵:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">PrintMatrix</span>(T);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures and Algorithms-Tree</title>
    <url>/2024/11/20/Data-Structures-and-Algorithms-Tree/</url>
    <content><![CDATA[<h1 id="基本述语"><a href="#基本述语" class="headerlink" title="基本述语"></a>基本述语</h1><ul>
<li>树的度(Degree of Tree)：树的度是树内各结点度的最大值。</li>
<li>叶子(Leaf)：度为0的结点称为叶子或终端结点。</li>
</ul>
<h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><ul>
<li>树中的结点数等于所有结点的度数之和加1。</li>
<li>度为m的树中第i层上至多有m(i-1)结点。</li>
<li>高度为h的m叉树至多有$\frac{m^h -1}{m-1}$个结点。</li>
<li>具有n个结点的m叉树的最小高度为$\log_m[(n(m-1))+1]$向上取整。</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：</p>
<ul>
<li>二叉树每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点); </li>
<li>二叉树的子树有左右之分，其次序不能任意颠倒。</li>
</ul>
<p>二叉树的性质：</p>
<p>任何一棵二叉树T，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一棵高度为知且含有2 h -1个结点的二叉树称为<strong>满二叉树</strong>，即树中的每层都含有最多的结点，满 二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2。</p>
<p>可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左向右 。这样，每个结点对应一个编号，对于编号为i的结点，若有双亲，则其双亲为$\lfloor \frac i 2\rfloor $ , 若有左孩 子，则左孩子为2i；若有右孩子，则右孩子为2i+1。</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中 编号为 1-n的结点一一对应时，称为完全二叉树，（完全二叉树就是对应相同高 度的满二叉树缺失最下层最右边的一些连续叶子结点）</p>
<img src="/2024/11/20/Data-Structures-and-Algorithms-Tree/image-20241120202724640.png" class="" alt="image-20241120202724640">
<p>具有n个结点的完全二叉树的深度为$\lfloor \log_2 n\rfloor +1$</p>
<p>性质5:如果对一棵有几个结点的完全二叉树的结点按层序编号，则对任一结点$i(1\le i\le n)$，有:<br>(1)如果i=1，则结点i是二又树的根，无双亲;如果i&gt;1，则其双亲是$\lfloor \frac i 2\rfloor$<br>(2)如果2i&gt;n，则结点i无左孩子;如果2i<n，则其左孩子是2i
(3)如果2i+1>n，则结点i无右孩子;如果2i+1&lt;n则其右孩子是2i+1</p>
<h3 id="几个特殊的二叉树"><a href="#几个特殊的二叉树" class="headerlink" title="几个特殊的二叉树"></a>几个特殊的二叉树</h3><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关 键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。 </p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>树上任一结点的左子树和右子树的深度之差不超过1。</p>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双亲表示法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTREE SIZE 100#</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;<span class="comment">// 结点的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> 	TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="comment">// 树的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	PTNode nodes[MAX_TREE_SIZE];    </span><br><span class="line">    <span class="type">int</span> r，n;<span class="comment">//根的位置和结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
<p>找双亲容易，找孩子难。</p>
<h2 id="孩子表示法：多重链表"><a href="#孩子表示法：多重链表" class="headerlink" title="孩子表示法：多重链表"></a>孩子表示法：多重链表</h2><p>每个结点有多个指针域，分别指向其子树的根 </p>
<ul>
<li>结点同构：结点的指针个数相等，为树的度D 结点不同构：</li>
<li>结点指针个数不等，为该结点的度d</li>
</ul>
<h2 id="孩子表示法：孩子链表"><a href="#孩子表示法：孩子链表" class="headerlink" title="孩子表示法：孩子链表"></a>孩子表示法：孩子链表</h2><p>每个结点的孩子结点用单链表存储，再用含n个头指针的线性表指向每个孩子链表。</p>
<p>找孩子容易 找双亲难</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//孩子表示法：孩子链表</span></span><br><span class="line"><span class="comment">//定义孩子结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ChildNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> childIndex; <span class="comment">// 孩子节点在数组中的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ChildNode</span>* next;<span class="comment">//下一个孩子节点的指针</span></span><br><span class="line">&#125; ChildNode;</span><br><span class="line"><span class="comment">//定义树的结点,里面的指针只指向第一个孩子节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">//存储的数据，此处设定为字符型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ChildNode</span>* firstChild; <span class="comment">//第一个孩子结点的指针</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//定义树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TreeNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r,n;<span class="comment">//根的位置和结点数</span></span><br><span class="line">&#125;Tree;</span><br></pre></td></tr></table></figure>
<h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><p>用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩 子结点和下一个兄弟结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 孩子兄弟表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;<span class="comment">// 节点数据，可根据需要修改数据类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span>* firstChild; <span class="comment">//第一个孩子节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span>* nextSibling;<span class="comment">//右侧兄弟节点的指针CSNode</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<p>特点： 1. 操作容易 2. 破坏了树的层次</p>
<h2 id="顺序存储实现"><a href="#顺序存储实现" class="headerlink" title="顺序存储实现"></a>顺序存储实现</h2><p>按完全二叉树的结点层次编号，依次存放二叉树中的数据元素.</p>
<img src="/2024/11/20/Data-Structures-and-Algorithms-Tree/image-20241120204618000.png" class="" alt="image-20241120204618000">
<p>➢结点间的父子关系蕴含在其存储位置中 </p>
<p>➢浪费空间，适于存满二叉树和完全二叉树</p>
<h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><p>指针域用两个指针分别指向左右子结点。</p>
<p>找孩子容易 找双亲难</p>
<p><strong>在n个结点的二叉链表中，有 n+1 个空指针域</strong></p>
<p>具有 n 个内部节点的二叉树： </p>
<p>• 有n−1 个内部指针，因为除了根节点，每个节点都有一个指针指向它。 </p>
<p>• 有 2n 个指针总共从所有的内部节点出来，因为每个节点有2个指针。 </p>
<p>• 这 2n 个指针分为两种：指向内部节点的和指向外部节点的。我们已经知道有 n−1  个指针指向内部节点，因此有 2n-(n-1)=n+1 个指针指向外部节点（即空指针域）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树的节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> data; <span class="comment">// 节点的数据部分，可以根据需求修改数据类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* left;<span class="comment">// 指向左孩子的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* right;<span class="comment">//指向右孩子的指针</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>
<h2 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h2><p>三个指针，分别指向左子结点、右子结点、双亲结点。</p>
<p>找孩子容易 找双亲容易</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树的节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TriNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data; <span class="comment">// 节点的数据部分，可以根据需求修改数据类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TriNode</span>* left;<span class="comment">// 指向左孩子的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TriNode</span>* right;<span class="comment">//指向右孩子的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TriNode</span>* parent;<span class="comment">//指向父节点的指针</span></span><br><span class="line">&#125; TriNode;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树-amp-森林"><a href="#二叉树-amp-森林" class="headerlink" title="二叉树 &amp; 森林"></a>二叉树 &amp; 森林</h1><h2 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h2><ul>
<li><p>对于森林中的每棵树，从根节点开始，如果某个节点有多个孩子，将最左侧的结点保留，右边的子树接到最左侧结点的右节点。</p>
</li>
<li><p>将树根相连，如果树根较多，往右下角接。</p>
<img src="/2024/11/20/Data-Structures-and-Algorithms-Tree/%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.gif" class="" alt="森林转化为二叉树">
</li>
</ul>
<h2 id="二叉树转化为森林"><a href="#二叉树转化为森林" class="headerlink" title="二叉树转化为森林"></a>二叉树转化为森林</h2><ul>
<li><p>从根节点开始，一直找右节点，向右走，直到没有右结点。将这条向右的路线上，所有的的枝断开，得到各个独立的树。</p>
</li>
<li><p>对于各个子树的节点，从根节点开始，一直找右节点，向右走，直到没有右结点。将这条路上的右测侧的节点连到左侧节点的双亲。</p>
<p><img src="./Data-Structures-and-Algorithms-Tree/二叉树转化为森林.gif" alt="二叉树转化为森林" style="zoom:150%;" /></p>
</li>
</ul>
<font color=red>右子树不为空的二叉树只能转换成森林 </font>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul>
<li>先（根）序的遍历算法：先访问根结点，然后分别先序遍历左子树、右子树 </li>
<li>中（根）序的遍历算法：先中序遍历左子树，然后访问根结点，最后中序遍 历右子树 </li>
<li>后（根）序的遍历算法：先后序遍历左、右子树，然后访问根结点 层次遍历算法：从上到下、从左到右访问各结点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre0rderTraversal</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，root-&gt;data);<span class="comment">// 访问根节点	</span></span><br><span class="line">        <span class="built_in">pre0rderTraversal</span>(root-&gt;left);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">pre0rderTraversal</span>(root-&gt;right);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in0rderTraversal</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">in0rderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，root-&gt;data);<span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">in0rderTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post0rderTraversal</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">post0rderTraversal</span>(root-&gt;left);        </span><br><span class="line">        <span class="built_in">post0rderTraversal</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，root-&gt;data);<span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="层次遍历算法的非递归描述"><a href="#层次遍历算法的非递归描述" class="headerlink" title="层次遍历算法的非递归描述"></a>层次遍历算法的非递归描述</h3><p>利用队列实现二叉树的层次 遍历非递归算法</p>
<ul>
<li>将二叉树的根结点入队 </li>
<li>队头元素出队并访问，将 其非空左、右孩子入队（即以 从左向右的顺序将下一层结点 保存在队列中） </li>
<li>重复上一步直到队空为止</li>
</ul>
<p>树的遍历常用方法是先根（序）遍历、后根（序）遍历和按层次遍历。</p>
<h3 id="求树的深度算法（采用孩子—兄弟存储结构）"><a href="#求树的深度算法（采用孩子—兄弟存储结构）" class="headerlink" title="求树的深度算法（采用孩子—兄弟存储结构）"></a>求树的深度算法（采用孩子—兄弟存储结构）</h3><ul>
<li>1.设depth为T的当前最大子树深度，初始为0；</li>
<li>2.若T=NULL，则返回0； </li>
<li>3.否则p=T-&gt;firstchild </li>
<li>4.p不为空，则求以p为根的子树深度d （递归） <ul>
<li>若d&gt;depth，则depth=d；p=p-&gt;nextsibling </li>
</ul>
</li>
<li>5.返回depth+1</li>
</ul>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>森林的遍历分为先序遍历、中序遍历、后续遍历。</p>
<p>本质上就是对于其中每一棵树应用先序遍历、中序遍历、后续遍历。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>后续遍历</td>
<td>后续遍历</td>
</tr>
</tbody>
</table>
</div>
<h3 id="由遍历序列确定二叉树"><a href="#由遍历序列确定二叉树" class="headerlink" title="由遍历序列确定二叉树"></a>由遍历序列确定二叉树</h3><p>◆ 给定先序、中序遍历序列可唯一确定二叉树。 </p>
<p>◆ 给定后序、中序遍历序列可唯一确定二叉树。</p>
<p>◆ 给定层次、中序遍历序列可唯一确定二叉树。</p>
<div class="note success disabled"><p>先确定根节点，然后将序列划分，对于每一个子树也确定根节点</p>
</div>
<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>试做如下规定：若结点有左子树，则其Ichild域指示其左孩子，否则令Ichild域指示 其前驱; 若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。 为了避免混淆，尚需改变结点结构，增加两个标志域。</p>
<blockquote>
<p>leftTag=0表示指示结点的左儿子，=1表示指示结点的前驱结点</p>
<p>rightTag=0指示结点的右儿子,=1指示结点的后继结点</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">    Link,Thread;</span><br><span class="line">&#125;PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiThrNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiThrNode</span> *lchild,*rchild;</span><br><span class="line">    PointerTag LTag,Rtag;</span><br><span class="line">&#125;BiThrNode,*BithrTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后 继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。</p>
<p> 以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针p指向正 在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空 ，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p。</p>
<p>中序遍历的特点：<strong>在中序遍历中，对于任何一个节点，其前驱是其左子树的最右下角的节点，其后继是其右子树的最左下角的节点。</strong></p>
<h2 id="中序序列构造线索二叉树"><a href="#中序序列构造线索二叉树" class="headerlink" title="中序序列构造线索二叉树"></a>中序序列构造线索二叉树</h2><p>算法步骤</p>
<ul>
<li>1）如果p非空，左子树递归线索化。</li>
<li>2）如果p的左孩子为空，则给p加上左线索，将其LTag置为1,让p的左孩子 指针指向pre （前驱）；否则将p的LTag置为0。 </li>
<li>3）如果pre的右孩子为空，则给pre加上右线索，将其RTag置为1,让pre的右 孩子指针指向p （后继）；否则将pre的RTag置为0。 </li>
<li>4）将pre指向刚访问过的结点p,即pre = p。</li>
<li>5）右子树递归线索化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历并线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderThreading</span><span class="params">(BiThrTree node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node)&#123;</span><br><span class="line">		<span class="built_in">in0rderThreading</span>(node-&gt;lchild);<span class="comment">// 如果当前节点的左子树为空，设置lchild为前驱</span></span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;lchild)&#123;</span><br><span class="line">			node-&gt;LTag = Thread;</span><br><span class="line">            node-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果前一个节点的右子树为空，设置rchild为当前节点</span></span><br><span class="line"><span class="comment">// pre为NULL时，说明当前节点是第一个被访问的节点，没有前驱</span></span><br><span class="line">      	<span class="keyword">if</span>(pre &amp;&amp; !pre-&gt;rchild)&#123;</span><br><span class="line">            pre-&gt;RTag = Thread;</span><br><span class="line">            pre-&gt;rchild =node;</span><br><span class="line">        &#125;</span><br><span class="line">		pre = node;</span><br><span class="line">		<span class="built_in">inOrderThreading</span>( node:node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历中序二叉树"><a href="#遍历中序二叉树" class="headerlink" title="遍历中序二叉树"></a>遍历中序二叉树</h2><p> ◆线索链表的遍历算法——遍历中序二叉树： 1.指针p指向根结点。 2.P为非空树或遍历未结束时，循环执行以下操作： 1）沿左孩子向下，到达最左下结点<em>p，它是中序的第一个结点； 2）访问</em>p；沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索 为0或者遍历结束； 3）转向p的右子树。</p>
<p> ◆ 中序线索化链表的第一个结点： 左子树上处于“最左下”（没有左子树）的结点。</p>
<p> ◆ 中序线索化链表中结点的后继： 若无右子树，则为后继线索所指结点； 否则为对其右子树进行中序遍历时访问的第一个结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiThrTree T)</span></span>&#123;</span><br><span class="line">    BiThrTree p=T;</span><br><span class="line">    <span class="comment">// 找到最左侧的节点，这是中序遍历的起点</span></span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp; p-&gt;LTag == Link)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>，p-&gt;data);</span><br><span class="line">		<span class="comment">// 如果右指针是线索，直接指向后继节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;RTag == Thread)&#123;</span><br><span class="line">            p= p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//否则，找到右子树的最左侧节点</span></span><br><span class="line">            p= p-&gt;rchild;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; p-&gt;LTag == Link)&#123;</span><br><span class="line">                p= p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="huffman树"><a href="#huffman树" class="headerlink" title="huffman树"></a>huffman树</h1><p>给定n个权值，构造出来含有n个叶子结点的二叉树，从根节点到这些叶子结点的权值为给定的权值，使得带权路径长度（WPL)最小的二叉树是最优二叉树或者哈夫曼树。</p>
<p>构造步骤：</p>
<ul>
<li>1）根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树(森林) ，根结点的权值分别为wj </li>
<li>2）在森林中选取两棵根结点权值最小的二叉树作为左右子树，构造一棵新 的二叉树，新二叉树根结点的权值为其左右孩子的权值之和 </li>
<li>3）在森林中删除这两棵二叉树，并将新二叉树加入森林中</li>
<li>4）重复2、3步，直到森林中只含一棵二叉树为止，这棵树即哈夫曼树</li>
</ul>
<h2 id="最佳判定树"><a href="#最佳判定树" class="headerlink" title="最佳判定树"></a>最佳判定树</h2><p>编制一个将百分制转换成五分制的程序，按照人数比例作为权值构造Huffman树。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>对于不等长的字符编码，如果需要解码，必须保证任何一个字符的编码都不是另一个字符的编码的前缀，这种编码被称之为字符编码。</p>
<p><strong>编码：</strong>根据字符出现频率构造Huffman树，然后将树中结点引向其左孩子的分支标 “0”，引向其右孩子的分支标“1”；每个字符的编码即为从根到每个叶子的路径 上得到的0、1序列。</p>
<img src="/2024/11/20/Data-Structures-and-Algorithms-Tree/image-20241120224945357.png" class="" alt="image-20241120224945357">
<p><strong>译码：</strong>从Huffman树根开始，从待译码电文中逐位取码。若编码是“0”，则向左走 ；若编码是“1”，则向右走，一旦到达叶子结点，则译出一个字符；再重新从根出 发，直到电文结束</p>
<img src="/2024/11/20/Data-Structures-and-Algorithms-Tree/image-20241120224958403.png" class="" alt="image-20241120224958403">
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures and Algorithms-linear list</title>
    <url>/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/</url>
    <content><![CDATA[<h1 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h1><p>线性表(linear_list)是最常用且最简单的一种数据结构。简言之，一个线性表是 $n$ 个 数据元素的有限序列。</p>
<p>线性表中的数据元素可以是各种各样的，但同一线性表中的 元素必定具有相同特性，即属同一数据对象，相邻数据元素之间存在着序偶关系。</p>
<p>线性表的抽象数据类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT List&#123; </span><br><span class="line">数据对象：D=&#123;ai|ai∈ElemSet,i=<span class="number">1</span>,<span class="number">2</span>,…,n,n≥<span class="number">0</span>&#125; </span><br><span class="line">数据关系：R=&#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1</span>,ai∈D,i=<span class="number">2</span>,…,n&#125;</span><br><span class="line">基本操作： </span><br><span class="line">InitList(&amp;L) </span><br><span class="line">　　　操作结果 ：构造一个空的线性表L。 </span><br><span class="line">DestroyList(&amp;L) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　　　操作结果 ：销毁线性表L。 </span><br><span class="line">ClearList(&amp;L) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　　　操作结果 ：将L重置为空表。 </span><br><span class="line">ListEmpty(L) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　　　操作结果 ：若L为空表，则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。 </span><br><span class="line">ListLength(L) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　　　操作结果 ：返回L中数据元素的个数。 </span><br><span class="line">GetElem(L,i,&amp;e) </span><br><span class="line">　　　初始条件 ：线性表L已存在，且<span class="number">1</span>≤i≤ListLength(L)。 </span><br><span class="line">　　　操作结果 ：用e返回L中第i个数据元素的值。 </span><br><span class="line">LocateElem(L,e) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　　　操作结果：返回L中第<span class="number">1</span>个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为<span class="number">0</span>。</span><br><span class="line">PriorElem(L,cur_e,&amp;pre_e) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，</span><br><span class="line">pre_e无定义。 </span><br><span class="line">NextElem(L,cur_e,&amp;next_e) </span><br><span class="line">　　　初始条件 ：线性表L已存在。 </span><br><span class="line">　操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，</span><br><span class="line">next_e无定义。 </span><br><span class="line">ListInsert(&amp;L,i,e) </span><br><span class="line">　　　初始条件 ：线性表L已存在，且<span class="number">1</span>≤i≤ListLength(L)+<span class="number">1</span>。 </span><br><span class="line">　　　操作结果 ：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="number">1</span>。 </span><br><span class="line">ListDelete(&amp;L,i)</span><br><span class="line">　　　初始条件 ：线性表L已存在且非空，且<span class="number">1</span>≤i≤ListLength(L)。 </span><br><span class="line">　　　操作结果 ：删除L的第i个数据元素，L的长度减<span class="number">1</span>。</span><br><span class="line">TraverseList(L)</span><br><span class="line">　　　初始条件 ：线性表L已存在。</span><br><span class="line">　　　操作结果 ：对线性表L进行遍历，在遍历过程中对L的每个节点访问一次。</span><br><span class="line">&#125;ADT List </span><br></pre></td></tr></table></figure>
<p>抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所 涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据 具体需要选择使用不同的数据类型。</p>
<h1 id="顺序表及其实现"><a href="#顺序表及其实现" class="headerlink" title="顺序表及其实现"></a>顺序表及其实现</h1><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这 种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为顺序表 （Sequential List）。其特点是，逻辑上相邻的数据元素，其物理位置也是相邻的。</p>
<p>只要确定了存储线性表的起始位置，线性表中任一数据元素都可<strong>随机存取</strong>，所 以线性表的顺序存储结构是一种随机存取的存储结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 朱玥 on 24-9-29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100  <span class="comment">// 假设我们规定的顺序表长度最大为100</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data;  <span class="comment">//指向存储数据的动态数组的指针</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">//表示当前顺序表中元素的数量</span></span><br><span class="line">    <span class="type">int</span> list_size; <span class="comment">//表示顺序表的总容量（即分配的数组大小）</span></span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化一个顺序链表，这是一个返回类型为 SeqList* 的函数</span></span><br><span class="line">SeqList *<span class="title function_">init_seq_list</span><span class="params">()</span> &#123; </span><br><span class="line">    SeqList *<span class="built_in">list</span> = (SeqList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList)); <span class="comment">//预分配内存</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data = (<span class="type">int</span> *) <span class="built_in">malloc</span>(MAXSIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//这行代码为 list 中的 data 数组分配内存。</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;  <span class="comment">//初始化 length，表示当前链表中还没有元素。</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;list_size = MAXSIZE;  <span class="comment">//设置链表的总容量为 MAXSIZE，也就是链表最多可以存储的元素数量。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 销毁顺序链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_seq_list</span><span class="params">(SeqList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span>;  <span class="comment">//如果链表指针为NULL，直接返回。</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;data);  <span class="comment">//释放动态分配的 data 数组内存。</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;list_size = <span class="number">0</span>;  <span class="comment">//将 length 和 list_size 设置为0，以确保链表状态被重置。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.清空顺序链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_seq_list</span><span class="params">(SeqList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;  <span class="comment">//我们要做的是清空而不是销毁，所以简单的将链表长度置零即可。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.索引链表元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_seq_elem</span><span class="params">(SeqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">list</span>-&gt;length) <span class="comment">//错误的条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.查找元素位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">locate_seq_elem</span><span class="params">(SeqList *<span class="built_in">list</span>, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; ++i) &#123; <span class="comment">//依次查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == e) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.获取前驱元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prior_elem</span><span class="params">(SeqList *<span class="built_in">list</span>, <span class="type">int</span> cur_e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == cur_e) <span class="keyword">return</span> <span class="built_in">list</span>-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert_elem</span><span class="params">(SeqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || <span class="built_in">list</span>-&gt;length &gt;= <span class="built_in">list</span>-&gt;list_size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">list</span>-&gt;length; j &gt; i; --j) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[j] = <span class="built_in">list</span>-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[i] = i;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.删除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_elem</span><span class="params">(SeqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">list</span>-&gt;length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; ++j) &#123;  <span class="comment">//直接将后面的元素依次左移即可。</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;data[j] = <span class="built_in">list</span>-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预分配内存浪费问题及其解决"><a href="#预分配内存浪费问题及其解决" class="headerlink" title="预分配内存浪费问题及其解决"></a>预分配内存浪费问题及其解决</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SeqList *<span class="built_in">list</span> = (SeqList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList)); <span class="comment">//预分配内存</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>SeqList *list</code>: 定义了一个指针变量 list，它指向一个 SeqList 类型的结构体。通过 <code>malloc</code> 函数来为这个结构体动态分配内存。</li>
<li>​    <code>malloc(sizeof(SeqList))</code>:<code>malloc</code> 分配内存的大小由 <code>sizeof(SeqList)</code> 决定，也就是 <code>SeqList</code> 结构体的大小。</li>
<li><code>(SeqList *): malloc</code> 返回的是一个 <code>void*</code> 类型的指针，需要通过强制类型转换 (<code>SeqList *</code>) 转换为 <code>SeqList</code> 类型的指针</li>
</ul>
<blockquote>
<p>你提到的 <code>list-&gt;data = (int *) malloc(MAXSIZE * sizeof(int));</code> 是在初始化顺序表时为数据数组 <code>data</code> 预分配了一块固定大小的内存。在这个例子中，<code>MAXSIZE</code> 代表了最多可以存储的元素个数，而 <code>sizeof(int)</code> 表示每个 <code>int</code> 类型所占的内存大小。</p>
<h3 id="1-内存预分配是否会造成浪费？"><a href="#1-内存预分配是否会造成浪费？" class="headerlink" title="1. 内存预分配是否会造成浪费？"></a>1. <strong>内存预分配是否会造成浪费？</strong></h3><p>是的，这种直接分配 <code>MAXSIZE * sizeof(int)</code> 的方式确实可能会在某些情况下造成内存浪费，尤其是当你不确定最终会存储多少数据时。比如如果你只使用了很少的空间（比如只存了几个元素），但系统依然为你分配了足够存储 <code>MAXSIZE</code> 个元素的空间，这部分未使用的内存就浪费了。</p>
<h3 id="2-如何体现动态？"><a href="#2-如何体现动态？" class="headerlink" title="2. 如何体现动态？"></a>2. <strong>如何体现动态？</strong></h3><p>要真正体现动态内存分配，可以根据实际需要逐步增加内存，而不是一开始就分配固定的 <code>MAXSIZE</code> 空间。可以采用 <strong>动态扩容</strong> 的策略。</p>
<p>一个常见的做法是：</p>
<ul>
<li>初始时分配一个相对较小的空间（例如10个元素的空间）。</li>
<li>当空间不足时，通过 <strong>倍增</strong> 的方式动态扩展空间。即当数组达到当前容量时，重新分配一块更大的内存（比如原来的2倍），然后将原来的数据拷贝到新分配的空间。</li>
</ul>
<p>这样可以减少内存浪费，同时在需要的时候自动扩容。</p>
<h3 id="3-改进方案"><a href="#3-改进方案" class="headerlink" title="3. 改进方案"></a>3. <strong>改进方案</strong></h3><p>你可以实现类似于 <strong>动态数组</strong> 的结构，采用按需扩展空间的方式。以下是一个改进的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SIZE 10   <span class="comment">// 初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCREASE_FACTOR 2   <span class="comment">// 扩展倍数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顺序表，初始容量为 INIT_SIZE</span></span><br><span class="line">SeqList* <span class="title function_">init_seq_list</span><span class="params">()</span> &#123;</span><br><span class="line">    SeqList* <span class="built_in">list</span> = (SeqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));</span><br><span class="line">    <span class="built_in">list</span>-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(INIT_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 初始分配较小的内存</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;list_size = INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展顺序表容量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expand_seq_list</span><span class="params">(SeqList* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> new_size = <span class="built_in">list</span>-&gt;list_size * INCREASE_FACTOR;  <span class="comment">// 扩展为原来的两倍</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data = (<span class="type">int</span>*)<span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;data, new_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;list_size = new_size;  <span class="comment">// 更新容量大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素到顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_element</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> elem)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length &gt;= <span class="built_in">list</span>-&gt;list_size) &#123;</span><br><span class="line">        expand_seq_list(<span class="built_in">list</span>);  <span class="comment">// 当容量不足时，进行扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[<span class="built_in">list</span>-&gt;length++] = elem;  <span class="comment">// 添加元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SeqList* <span class="built_in">list</span> = init_seq_list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试添加多个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        add_element(<span class="built_in">list</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已添加元素: %d, 当前长度: %d, 当前容量: %d\n&quot;</span>, i, <span class="built_in">list</span>-&gt;length, <span class="built_in">list</span>-&gt;list_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-改进后的优点"><a href="#4-改进后的优点" class="headerlink" title="4. 改进后的优点"></a>4. <strong>改进后的优点</strong></h3><ul>
<li><strong>节省内存</strong>：一开始只分配较小的空间，真正需要时才扩展内存，避免初期的内存浪费。</li>
<li><strong>动态扩展</strong>：顺序表可以根据需要不断扩展，容量不再固定为 <code>MAXSIZE</code>，而是动态增长。</li>
<li><strong>高效使用内存</strong>：虽然扩展内存时可能有一定的开销（重新分配和拷贝），但这种方式可以有效平衡内存使用和性能。</li>
</ul>
<p>通过这种方式，你可以实现一个真正的“动态”数组，不再局限于一开始预设的固定内存大小。</p>
</blockquote>
<h2 id="各个操作时间复杂度分析"><a href="#各个操作时间复杂度分析" class="headerlink" title="各个操作时间复杂度分析"></a>各个操作时间复杂度分析</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引（取值）</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td>查找</td>
<td>$O(n)$</td>
<td>平均查找长度（Average Search Length，ASL)为$\frac{n+1}{2}$</td>
</tr>
<tr>
<td>插入</td>
<td>$O(n)$</td>
<td></td>
</tr>
<tr>
<td>删除</td>
<td>$O(n)$</td>
</tr>
</tbody>
</table>
</div>
<p>索引是通过根据指定的位置序号i，获取顺序表中第i个数据元素的值。查找是根据指定的元素值e，查找顺序表中第1个值与e相等的元素。</p>
<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><p>为了表示每个数据元素 $a_i$ 与其直接后继数据元 素 $a_i+1$ 之间的逻辑关系，对数据元素 $a_i$ 来说，除了存储其本身的信息之外，还需<strong>存储一个指示其直接后继的信息</strong>（直接后继的存储位置）。这两部分信息组成数据元素 $a_i$ 的存储映像，称为<strong>节点 （node）</strong>。它包括两个域：</p>
<ul>
<li>其中存储数据元素信息的域称为<strong>数据域</strong>；</li>
<li>存储直接后继存储位置的域称为<strong>指针域</strong>。</li>
</ul>
<p>指针域中存储的信息称作<strong>指针或链</strong>。$n$ 个节点[ $a_i(1≤i≤n)$ 的存储映像]链接成 一个链表，即为线性表：</p>
<script type="math/tex; mode=display">
 (a_1, a_2,…, a_n)</script><p>的链式存储结构。又由于此链表的每个节点中只包含一个指针域，故又称<strong>线性链表</strong>或<strong>单链表</strong>。</p>
<p>根据链表节点所含指针个数、指针指向和指针连接方式，可将链表分为<strong>单链表、循环链 表、双向链表、二叉链表、十字链表、邻接表、邻接多重表</strong>等。其中<strong>单链表、循环链表和双向链表多用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。</strong></p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221034810.png" class="" alt="image-20241011221034810">
<p>一般情况下，为了处理方便，在单链表的第一个节点之前附设一个节点，称之为头节点。 图2.8所示的单链表增加头节点后如下图所示。</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221057768.png" class="" alt="image-20241011221057768">
<h2 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h2><p>如下代码所示:</p>
<h3 id="定义单链表结点类型"><a href="#定义单链表结点类型" class="headerlink" title="定义单链表结点类型"></a>定义单链表结点类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 朱玥 on 2024/10/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，<code>LinkList</code>与<code>LNode *</code>，两者本质上是等价的。通常习惯上用<code>LinkList</code>定义单链表，强调定义的是某个单链表的头指针；用<code>LNode *</code>定义指向单链表中任意节点的指针变量。例如，<br>若定义<code>LinkList L</code>，则<code>L</code>为单链表的头指针，<br>若定义<code>LNode *p</code>，则<code>p</code>为指向单链表中某个节点的指针，用<code>*p</code>代表该节点。<br>当然也可以使用定义<code>LinkList p</code>，这种定义形式完全等价于<code>LNode *p</code>。</p>
<p>注意区分指针变量和节点变量两个不同的概念，若定义 <code>LinkList p</code>或<code>LNode *p</code>， 则<code>p</code>为指向某节点的指针变量，表示该节点的地址；而<code>*p</code>为对应的节点变量，表示该节点的 名称。</p>
</blockquote>
<h3 id="初始化单向链表"><a href="#初始化单向链表" class="headerlink" title="初始化单向链表"></a>初始化单向链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.初始化单向链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_list</span><span class="params">(LinkList *L)</span> &#123;<span class="comment">//传入参数为二级指针</span></span><br><span class="line">    *L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//指向下一个节点的指针为空。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C 语言中，<code>LinkList *L</code> 表示传入的是一个指向指针的指针。<code>*L</code> 用于解引用这个指针，允许函数直接修改调用该函数时传入的头指针。</p>
<p>具体来说：</p>
<ol>
<li><code>LinkList *L</code> 是一个指向 <code>LinkList</code> 的指针，也就是指向一个指向 <code>LNode</code> 的指针。</li>
<li>使用 <code>*L</code> 可以访问并修改这个指针的值，即将新分配的内存地址赋给它。</li>
</ol>
<p>因此，在初始化链表时，我们需要通过 <code>*L</code> 来给传入的头指针分配内存。这样，链表的头指针在函数外部也能反映这个变化。</p>
<h3 id="销毁单向链表"><a href="#销毁单向链表" class="headerlink" title="销毁单向链表"></a>销毁单向链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.销毁单向链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">destroy_list</span><span class="params">(LinkList *L)</span> &#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">while</span> (*L) &#123;      <span class="comment">//和前面说的一样，*L是个指针</span></span><br><span class="line">        p = (*L)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(*L);</span><br><span class="line">        *L = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><blockquote>
<p><strong>算法:单链表的按值查找</strong></p>
<p>① 用指针<code>p</code>指向首元节点。 </p>
<p>② 从首元节点开始依次顺着链域<code>next</code>向下查找，只要指向当前节点的指针<code>p</code>不为空，并且<code>p</code>所指节点的数据域不等于给定值<code>e</code>，则循环执行以下操作：<code>p</code>指向下一个节点。 </p>
<p>③ 返回<code>p</code>。若查找成功，<code>p</code>此时指向节点的地址值，若查找失败，则<code>p</code>的值为<code>NULL</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode* <span class="title function_">find_node</span><span class="params">(LinkList L, <span class="type">int</span> value)</span> &#123; <span class="comment">//这个时候传入的参数是一个一级指针</span></span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取元素-取值"><a href="#获取元素-取值" class="headerlink" title="获取元素(取值)"></a>获取元素(取值)</h3><blockquote>
<p><strong>算法:单链表的取值</strong></p>
<p>① 用指针<code>p</code>指向首元节点，用<code>j</code>做计数器初值赋为<code>1</code>。</p>
<p> ② 从首元节点开始依次顺着链域<code>next</code>向下访问，只要指向当前节点的指针<code>p</code>不为空 （<code>NULL</code>），并且没有到达序号为i的节点，则循环执行以下操作：</p>
<ul>
<li><p><code>p</code>指向下一个节点；</p>
</li>
<li><p>计数器<code>j</code>相应加<code>1</code>。</p>
</li>
<li><p>退出循环时，如果指针<code>p</code>为空，或者计数器j大于i，说明指定的序号<code>i</code> 值不合法（<code>i</code>大于表长<code>n</code>或<code>i</code>小于等于<code>0</code>），取值失败返回<code>ERROR</code>；否则取值成 功，此时<code>j = i</code>时，<code>p</code>所指的节点就是要找的第i个节点，用参数<code>e</code>保存当前节点的 数据域，返回<code>1</code></p>
</li>
</ul>
</blockquote>
<p>时间复杂度为 $O(n)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_elem</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span> *e)</span> &#123;</span><br><span class="line">    LNode* p = L-&gt;next;  <span class="comment">// p是一个结构体指针，一级指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为规定了函数的返回值代表操作成功与否，所以又用了<code>*e</code> 参数来接受获得的值。</p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>假设要在单链表的两个数据元素 $a$ 和 $ b$ 之间插入一个数据元素 $ x$，已知<code>p</code>为其单链表存储结构 中指向节点 $a$的指针，如图2.11（a）所示。</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221206906.png" class="" alt="image-20241011221206906">
<blockquote>
<p><strong>算法:单链表的插入</strong></p>
<p>将值为<code>e</code>的新节点插入表的第<code>i</code>个节点的位置，即插入节点 $a_{i-1}$ 与 $a_i$ 之间，具体插入过程如图所示，图中对应的5个步骤说明如下。 </p>
<p>① 查找节点 $a_{i-1}$ 并由指针<code>p</code>指向该节点。  </p>
<p>② 生成一个新节点<code>*s</code>。</p>
<p>③ 将新节点<code>*s</code>的数据域置为e。  </p>
<p>④ 将新节点<code>*s</code>的指针域指向节点 $a_i$ .</p>
<p>⑤ 将节点<code>*p</code>的指针域指向新节点<code>*s</code>。</p>
</blockquote>
<p>时间复杂度为 $O(n)$</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221218086.png" class="" alt="image-20241011221218086">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insert_elem</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123; <span class="comment">//这个时候传入的参数是一个一级指针</span></span><br><span class="line">    LNode* p = L;   <span class="comment">//p是一级指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//while循环用于找到这个元素，相当于重新实现了获取元素功能。</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为新节点分配内存</span></span><br><span class="line">    LNode* s = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">//下面三句把原有的指针断开，又连接上。</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除第 <code>i</code> 个节点，并返回该节点的数据</p>
<blockquote>
<p>算法:单链表的删除</p>
<p>删除单链表的第 $i$个节点 $a_i$的具体过程如图所示，图中对应的4个步骤 说明如下。</p>
<p> ① 查找节点$a_{i−1}$并由指针<code>p</code>指向该节点。</p>
<p>② 临时保存待删除节点 $a_i$ 的地址在<code>q</code>中，以备释放。</p>
<p> ③ 将节点<code>*p</code>的指针域指向 $ a_i$ 的直接后继节点。</p>
<p>④ 释放节点 $ a_i$ 的空间。</p>
</blockquote>
<p>时间复杂度为 $O(n)$</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221233079.png" class="" alt="image-20241011221233079">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete_elem</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span> *e)</span> &#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//while循环用于找到这个元素的前一个元素，即下标为i-1的，获取元素功能。</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || j &gt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* q = p-&gt;next; <span class="comment">// 保存待删除节点</span></span><br><span class="line">    *e = q-&gt;data;       <span class="comment">// 获取数据</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">// 更新前一个节点的指针</span></span><br><span class="line">    <span class="built_in">free</span>(q);            <span class="comment">// 释放待删除节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>delete_elem</code> 函数中，<code>while</code> 循环中找到的 <code>p</code> 是<strong>待删除元素的前一个节点</strong>，而不是待删除的元素本身。</p>
<p>具体来说：</p>
<ul>
<li><code>p</code> 最终指向的是待删除元素的前一个节点，这样才能通过 <code>p-&gt;next</code> 访问待删除的元素。</li>
<li>待删除的元素 <code>q</code> 是通过 <code>q = p-&gt;next</code> 获取的。因此，<code>q</code> 是要被删除的节点，而 <code>p</code> 是其前一个节点。这样才能在删除时更新指针，确保链表的结构不被破坏。</li>
<li><img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221303361.png" class="" alt="image-20241011221303361">
</li>
</ul>
<h3 id="头插法创建链表"><a href="#头插法创建链表" class="headerlink" title="头插法创建链表"></a>头插法创建链表</h3><p>头插法(前插法)是通过将新节点逐个插入链表的头部（头节点之后）来创建链表，每次申请一个新 节点，读入相应的数据元素值，然后将新节点插入到头节点之后。</p>
<blockquote>
<p>算法2.11　</p>
<p><strong>头插法(前插法)创建单链表</strong> </p>
<ul>
<li><p>① 创建一个只有头节点的空链表。 </p>
</li>
<li><p>② 根据待创建链表包括的元素个数$n$，循环$n$次执行以下操作： </p>
</li>
<li><ul>
<li>生成一个新节点<code>*p</code>； </li>
<li>输入元素值赋给新节点<code>*p</code>的数据域；</li>
<li>将新节点<code>*p</code>插入到头节点之后。</li>
</ul>
</li>
</ul>
</blockquote>
<p>时间复杂度为 $O(n)$ .</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221328310.png" class="" alt="image-20241011221328310">
<p>程序如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_list_by_head</span><span class="params">(LinkList L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;  <span class="comment">//p不为NULL函数返回，链表创建失败。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果内存分配失败，返回 0，表示链表创建失败。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = L-&gt;next;<span class="comment">//先让p的指针指向L的后继元素</span></span><br><span class="line">        L-&gt;next = p;<span class="comment">//再让L的指针指向p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>:warning:注意,下面两句是<strong>有顺序</strong>的.否则会造成链表元素丢失</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = L-&gt;next;<span class="comment">//先让p的指针指向L的后继元素</span></span><br><span class="line">L-&gt;next = p;<span class="comment">//再让L的指针指向p</span></span><br></pre></td></tr></table></figure>
<p>同时,注意<strong>输入顺序</strong>,如果想创建逻辑顺序为 $a\rightarrow b\rightarrow c\rightarrow d\rightarrow e$ 的单项链表,如果用头插法,输入顺序,应该是 $e\rightarrow d\rightarrow c\rightarrow b\rightarrow a$ ,恰好反过来.</p>
<h3 id="尾插法创建链表"><a href="#尾插法创建链表" class="headerlink" title="尾插法创建链表"></a>尾插法创建链表</h3><p><strong>尾插法(后插法)是通过将新节点逐个插入链表的尾部来创建链表。</strong>同前插法一样，每次申请一个新 节点，读入相应的数据元素值。不同的是，为了使新节点能够插入表尾，需要增加一个尾指针<code>q</code> 指向链表的尾节点。</p>
<blockquote>
<p><strong>算法2.12</strong>　</p>
<p><strong>尾插法(后插法)创建单链表</strong> </p>
<p>① 创建一个只有头节点的空链表。 </p>
<p>② 尾指针<code>q</code>初始化，指向头节点。 </p>
<p>③ 根据创建链表包括的元素个数 $n$ ，循环 $n$ 次执行以下操作： </p>
<ul>
<li><p>生成一个新节点<code>*p</code>；</p>
</li>
<li><p><em>输入元素值赋给新节点</em>p的数据域； </p>
</li>
<li><p>将新节点<code>*p</code>插入尾节点<code>*q</code>之后；</p>
</li>
<li><p>尾指针r指向新的尾节点<code>*p</code>。</p>
</li>
</ul>
</blockquote>
<p>时间复杂度为 $O(n)$ .</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221421426.png" class="" alt="image-20241011221421426">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_list_by_tail</span><span class="params">(LinkList L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    LNode* p = L; <span class="comment">//起初，p 指向链表的头指针 L，也就是链表的头结点，因为只有一个节点 ，所以也是尾节点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        LNode* q = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (!q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果内存分配失败，返回 0，表示链表创建失败。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">        q-&gt;next = <span class="literal">NULL</span>;<span class="comment">//让q的指针为NULL，使得q为新的尾节点。</span></span><br><span class="line">        p-&gt;next = q; <span class="comment">//让原来尾节点p的指针指向q</span></span><br><span class="line">        p = q;<span class="comment">//尾节点更新，每次输入一个数，尾节点就变成了当前这个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插法的优点是链表的构建顺序与输入顺序一致，适合需要从前往后逐步生成链表的情况。如果想创建逻辑顺序为 $a\rightarrow b\rightarrow c\rightarrow d\rightarrow e$ 的单项链表,输入顺序,应该是 $a\rightarrow b\rightarrow c\rightarrow d\rightarrow e$ ,保持一致.</p>
<p>在这种情况下,下面的语句的顺序没有影响:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q-&gt;next = <span class="literal">NULL</span>;<span class="comment">//让q的指针为NULL，使得q为新的尾节点。</span></span><br><span class="line">p-&gt;next = q; <span class="comment">//让原来尾节点p的指针指向q</span></span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>销毁单向链表</td>
<td>$O(n)$</td>
<td></td>
</tr>
<tr>
<td>按值查找节点</td>
<td>$O(n)$</td>
<td></td>
</tr>
<tr>
<td>获取元素(取值)</td>
<td>$O(n)$</td>
<td></td>
</tr>
<tr>
<td>删除元素</td>
<td>$O(n)$</td>
<td></td>
</tr>
<tr>
<td>头插法创建单向链表</td>
<td>$O(n)$</td>
<td></td>
</tr>
<tr>
<td>尾插法创建单向链表</td>
<td>$O(n)$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个节点的指针域指向头节点，整个链表形成一个环。由此，从表中任一节点出发均可找到表中其他 节点，图2.17所示为单链的循环链表。类似地，还可以有多重链的循环链表。</p>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221434466.png" class="" alt="image-20241011221434466">
<p>循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针<code>p</code>是否指 向表尾节点的终止条件不同。在单链表中，判别条件为<code>p!=NULL</code>或<code>p-&gt;next!=NULL</code>，而循环单链 表的判别条件为<code>p!=L</code>或<code>p-&gt;next!=L</code></p>
<p>在某些情况下，若在循环链表中设立尾指针而不设头指针[见图2.18（a）]，可使一些操作 简化。例如，将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一个 节点，第二个表的尾指针指向第一个表的头节点，然后释放第二个表的头节点。当线性表以图 2.18（a）的循环链表作存储结构时，这个操作仅需改变两个指针值即可，主要语句段如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = B-&gt;next-&gt;next; </span><br><span class="line">B-&gt;next = A-&gt;next;</span><br><span class="line">A-&gt;next = p;</span><br></pre></td></tr></table></figure>
<img src="/2024/10/11/Data%20Structures%20and%20Algorithms-linear%20list/image-20241011221852206.png" class="" alt="image-20241011221852206">
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表实现大同小异，只需要把<code>prev</code>指针处理好就行:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义双链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125; LNode, * LinkList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_list</span><span class="params">(LinkList* L)</span> &#123;</span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    (*L)-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">destroy_list</span><span class="params">(LinkList* L)</span> &#123;  <span class="comment">//指向结构体指针的指针</span></span><br><span class="line">    LinkList p = *L;  <span class="comment">//p是结构体指针，对L解引。</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList q = p-&gt;next;  <span class="comment">//q用于存储p的下一个节点，防止释放内存后找不到</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找节点</span></span><br><span class="line">LNode* <span class="title function_">find_node</span><span class="params">(LinkList L, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据下标索引节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_elem</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span>* e)</span> &#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点到指定位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert_elem</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到这个位置</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//令s的next指向p的下一个节点。</span></span><br><span class="line">    s-&gt;prev = p;        <span class="comment">//令s的prev指向p。</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;  <span class="comment">// 如果 p 的下一个节点不是 NULL，更新 p-&gt;next 的 prev 指针</span></span><br><span class="line">        p-&gt;next-&gt;prev = s;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = s;        <span class="comment">//令p的next指向s。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点并且得到删除的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete_elem</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span>* e)</span> &#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || j &gt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;  <span class="comment">// 如果 q-&gt;next 不是 NULL，更新它的 prev 指针</span></span><br><span class="line">        q-&gt;next-&gt;prev = p;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法创建链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_list_by_head</span><span class="params">(LinkList L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    LNode* p;   <span class="comment">//p是要插入的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(p-&gt;data));  <span class="comment">//读入p的数据</span></span><br><span class="line">        p-&gt;next = L-&gt;next;  <span class="comment">//令p的next指向L的下一个节点。</span></span><br><span class="line">        p-&gt;prev = L;        <span class="comment">//令p的prev指向L。</span></span><br><span class="line">        <span class="keyword">if</span> (L-&gt;next != <span class="literal">NULL</span>) &#123;  <span class="comment">// 判断 L-&gt;next 是否为空，避免空指针访问</span></span><br><span class="line">            L-&gt;next-&gt;prev = p;</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;next = p;        <span class="comment">//令L的next指向p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法创建链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_list_by_tail</span><span class="params">(LinkList L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    LNode* p = L; <span class="comment">//p是尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        LNode* q = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (!q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">        q-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//令q的next指向NULL</span></span><br><span class="line">        p-&gt;next = q;        <span class="comment">//令原来尾结点的p的next指向q</span></span><br><span class="line">        q-&gt;prev = p;        <span class="comment">//令q的prev指向p</span></span><br><span class="line">        p = q;              <span class="comment">//更新尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(LNode* head)</span> &#123;</span><br><span class="line">    LNode* temp = head-&gt;next; <span class="comment">//不需要打印头节点，从第一个节点开始打印</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建链表</span></span><br><span class="line">	LinkList L ;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	init_list(&amp;L);</span><br><span class="line"></span><br><span class="line">	create_list_by_head(L, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;下面是头插法创建的链表\n&quot;</span>);</span><br><span class="line">	printList(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入节点</span></span><br><span class="line">	insert_elem(L, <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;下面是在2位置插入操作后的的链表\n&quot;</span>);</span><br><span class="line">	printList(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除某个元素</span></span><br><span class="line">	<span class="type">int</span> elem_deleted;</span><br><span class="line">	delete_elem(L, <span class="number">2</span>, &amp;elem_deleted);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;要删除的节点是 %d\n&quot;</span>, elem_deleted);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;删除第二个节点后的链表为:\n&quot;</span>);</span><br><span class="line">	printList(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下表索引和查找节点</span></span><br><span class="line">	<span class="type">int</span> elem;</span><br><span class="line">	get_elem(L, <span class="number">3</span>, &amp;elem);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;第3个节点为%d\n&quot;</span>, elem);</span><br><span class="line">	</span><br><span class="line">	LNode* node;</span><br><span class="line">	node = find_node(L, elem);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;这个节点的元素是 %d\n&quot;</span>, node-&gt;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 销毁链表，防止内存泄漏</span></span><br><span class="line">	destroy_list(&amp;L);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Data-Structures-and-Algorithms-Sorting.md</title>
    <url>/2024/12/02/Data-Structures-and-Algorithms-Sorting/</url>
    <content><![CDATA[<h1 id="排序及其相关的数据结构"><a href="#排序及其相关的数据结构" class="headerlink" title="排序及其相关的数据结构"></a>排序及其相关的数据结构</h1><p>排序（Sorting）是按<strong>关键字</strong>的非递减或非递增顺序对一组记录重新进行排列的操作。</p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>当排序记录中的关键字Ki（i = 1, 2, …, n）都不相同时，则任何一个记录的无序序列经排序 后得到的结果唯一；反之，当待排序的序列中存在两个或两个以上关键字相等的记录时，则排 序所得的结果不唯一。假设Ki = Kj（1≤i≤n，1≤j≤n，i≠j），且在排序前的序列中Ri领先于Rj ，（即i&lt;j），若在排序后的序列中Ri仍领先于Rj，则称所用的排序方法是<strong>稳定</strong>的；反之，若可能使 排序后的序列中Rj领先于Ri，则称所用的排序方法是不稳定的。</p>
<h2 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h2><ul>
<li>（1）<strong>插入类</strong>：将无序子序列中的一个或几个记录插入有序序列，从而增加记录的有序子序 列的长度。主要包括直接插入排序、折半插入排序和希尔排序。 </li>
<li>（2）<strong>交换类</strong>：通过交换无序序列中的记录从而得到其中关键字最小或最大的记录，并 将它加入有序子序列中，以此方法增加记录的有序子序列的长度。主要包括冒泡排序和快速 排序。 </li>
<li>（3）<strong>选择类</strong>：从记录的无序子序列中选择关键字最小或最大的记录，并将它加入有序子 序列中，以此方法增加记录的有序子序列的长度。主要包括简单选择排序、树形选择排序和堆 排序。 </li>
<li>（4）<strong>归并类</strong>：通过归并两个或两个以上的记录有序子序列，逐步增加记录有序序列的长 度。2-路归并排序是最为常见的归并排序方法。 </li>
<li>（5）<strong>分配类</strong>：是唯一一类不需要进行关键字比较的排序方法，排序时主要利用分配和收集 两种基本操作来完成。基数排序是主要的分配排序方法。</li>
</ul>
<h2 id="待排序记录的存储方式"><a href="#待排序记录的存储方式" class="headerlink" title="待排序记录的存储方式"></a>待排序记录的存储方式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EQ(a,b) ((a)==(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT(a, b) ((a) &lt; (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LQ(a,b) ((a)&lt;=(b))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType; <span class="comment">//关键字类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType; <span class="comment">//关键字所含有的其他信息类型，这里定义为字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	KeyType key;</span><br><span class="line">	InfoType* info;</span><br><span class="line">&#125;RedType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	RedType r[MAXSIZE + <span class="number">1</span>];<span class="comment">//r[0]作为闲置或者哨兵单元</span></span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的方法是，先假定第一个元素是“有序”的，然后依次将第二个元素插入前面“有序”的序列中，在此过程中，可以用哨兵单元暂存需要插入的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList* <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">list</span>.length;++i)&#123; <span class="comment">//注意从2开始，且是++i</span></span><br><span class="line">        <span class="keyword">if</span>(LT(<span class="built_in">list</span>-&gt;r[i]-&gt;key,<span class="built_in">list</span>-r[i<span class="number">-1</span>]-&gt;key))&#123; <span class="comment">//如果前大后小</span></span><br><span class="line">            <span class="built_in">list</span>-&gt;r[<span class="number">0</span>]-&gt;key=<span class="built_in">list</span>-&gt;r[i]-&gt;key; <span class="comment">//将这个关键字存入哨兵单元</span></span><br><span class="line">            <span class="built_in">list</span>-&gt;r[i]-&gt;key=<span class="built_in">list</span>-&gt;r[i<span class="number">-1</span>]-&gt;key； <span class="comment">//将其后移</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">int</span> j=i<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-2</span>;j&gt;=<span class="number">0</span>&amp;&amp;LT( <span class="built_in">list</span>-&gt;r[<span class="number">0</span>]-&gt;key, <span class="built_in">list</span>-&gt;r[j]-&gt;key),--j)&#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;r[j+<span class="number">1</span>]-&gt;key=<span class="built_in">list</span>-&gt;r[j]-&gt;key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>-&gt;r[j+<span class="number">1</span>]-&gt;key=<span class="built_in">list</span>-&gt;r[<span class="number">0</span>]-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Game Theory-Applications of Nash Equilibrium</title>
    <url>/2024/10/16/Game%20Theory-Applications%20of%20Nash%20Equilibrium/</url>
    <content><![CDATA[<h1 id="Cournot-模型"><a href="#Cournot-模型" class="headerlink" title="Cournot 模型"></a>Cournot 模型</h1><img src="/2024/10/16/Game%20Theory-Applications%20of%20Nash%20Equilibrium/bd5f88ea23f9cc5e15799b6655142bf.jpg" class="" alt="bd5f88ea23f9cc5e15799b6655142bf">
<h1 id="Bertrand模型"><a href="#Bertrand模型" class="headerlink" title="Bertrand模型"></a>Bertrand模型</h1><img src="/2024/10/16/Game%20Theory-Applications%20of%20Nash%20Equilibrium/062adea84047acfbee0962f3dbf761b.jpg" class="" alt="062adea84047acfbee0962f3dbf761b">
<h1 id="Hotelling模型"><a href="#Hotelling模型" class="headerlink" title="Hotelling模型"></a>Hotelling模型</h1><img src="/2024/10/16/Game%20Theory-Applications%20of%20Nash%20Equilibrium/9273c3786dd4683f62b6519df9056de.jpg" class="" alt="9273c3786dd4683f62b6519df9056de">
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Nash均衡</tag>
        <tag>博弈论</tag>
        <tag>手写稿</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory-Extensive form game</title>
    <url>/2024/10/16/Game%20Theory-Extensive%20form%20game/</url>
    <content><![CDATA[<h1 id="扩展式博弈"><a href="#扩展式博弈" class="headerlink" title="扩展式博弈"></a>扩展式博弈</h1><blockquote>
<p>扩展式博弈包含以下要素:</p>
<ol>
<li>参与人集合 $\Gamma={1,2,\cdots,n}$;</li>
<li>参与人的行动顺序，即每个参与人何时行动；</li>
<li>每个参与人行动时面临的决策问题，包括参与人行动时可供他选择的行动方案及他所了解的信息；</li>
<li>参与人的支付函数，即博弈结束时每个参与人得到的博弈结果。</li>
</ol>
</blockquote>
<h1 id="博弈树及其表示"><a href="#博弈树及其表示" class="headerlink" title="博弈树及其表示"></a>博弈树及其表示</h1><p>博弈树是由“结”和“有向枝”构成的“有向树”，最上方的节点是空心圆，表示博弈的开始，其余的节点用实心圆表示，结（node)分为：</p>
<ul>
<li><p>初始结或根（root）；</p>
</li>
<li><p>决策结（root）；</p>
</li>
<li><p>终点结（terminal node）</p>
</li>
</ul>
<h1 id="信息集"><a href="#信息集" class="headerlink" title="信息集"></a>信息集</h1><p>在博弈树中，参与人 $i$ 的一个信息集（用 $I_i$ 表示）是参与人 $i$ 决策结的一个集合，且满足下列两个条件：</p>
<ul>
<li><p>(1) $I_i$ 中的每个决策树都是参与人  $i$ 的决策结；</p>
</li>
<li><p>(2)  当博弈达到信息集 $I_i$  (即博弈到达 $I_i$ 中的某个决策结点)时，参与人 $i$ 知道自己位于信息集 $I_i$ 的节点上，但是不知道自己位于 $I_i$ 中的哪个节点上。</p>
</li>
</ul>
<p>在决策树上，我们将位于同一个信息集上的节点用虚线连接起来。</p>
<h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><h2 id="博弈的结构和参与人完全理性是共同知识"><a href="#博弈的结构和参与人完全理性是共同知识" class="headerlink" title="博弈的结构和参与人完全理性是共同知识"></a>博弈的结构和参与人完全理性是共同知识</h2><h2 id="“完美记忆”假设"><a href="#“完美记忆”假设" class="headerlink" title="“完美记忆”假设"></a>“完美记忆”假设</h2><p>即假设参与人不会忘记以前知道或者做过的事情。</p>
<h1 id="扩展式博弈的战略及其Nash均衡"><a href="#扩展式博弈的战略及其Nash均衡" class="headerlink" title="扩展式博弈的战略及其Nash均衡"></a>扩展式博弈的战略及其Nash均衡</h1><p>用 $H<em>i$ 表示参与人 $i$ 的信息集 $I_i$ 的集合，即 $H_i={I_i}$ ;用 $A_i(I_i)$ 表示参与人 $i$ 在信息集上的行动集，$A_i(H_i)$ 表示参与人 $i$ 在所有信息集上的行动集，即 $A_i(H_i)=\bigcup\limits</em>{I_i\in H_i} A_i(I_i)$ ,那么参与人  $i$ 的一个纯战略 $s_i$就是从信息集 $H_i$ 到行动集合 $A_i(H_i)$ 的一个映射关系，即：</p>
<script type="math/tex; mode=display">
s_i=H_i\rightarrow A_i(H_i)</script><p> 其中，对于 $\forall I_i \in H_i,s_i(I_i)\in A_i(I_i)$</p>
<p>在以后的讨论中，用参与人 $i$ 在每个信息集 $I_i$ 上的行动集 $A_i(I_i)$ <strong>笛卡尔积</strong>来表示参与人 $i$ 的战略集 $S_i$，即</p>
<script type="math/tex; mode=display">
S_i=\prod  _{I_i\in H_i}A_i(I_i)</script><p>对于扩展式博弈，博弈中可能发生的每一件事件序列，都可以用博弈树中的一条从初始结点（或者根）到终结点之一的由枝形成的路径表示，比如 </p>
<script type="math/tex; mode=display">
x_1\to x_2\to x_3 \to x_7</script><p>扩展式博弈中，参与人的每一个战略组合与博弈树中的一条路径对应。</p>
<p>需要注意的是，<strong>每个战略组合都有唯一与之对应的路径，但是一个路径所对应的战略组合未必唯一。</strong></p>
<h1 id="扩展式博弈和战略式博弈的比较"><a href="#扩展式博弈和战略式博弈的比较" class="headerlink" title="扩展式博弈和战略式博弈的比较"></a>扩展式博弈和战略式博弈的比较</h1><p>扩展式博弈是动态模型，战略式博弈是静态模型。</p>
<p>由于Nash均衡只是一个静态的解的概念，所以扩展式博弈，需要先给出来博弈的战略式描述，才可能得到博弈的Nash均衡。</p>
<p>对于给定的扩展式博弈，总存在唯一的战略式博弈与之对应，但是对于给定的战略式博弈，会存在多个扩展式博弈与之对应。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>扩展式博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory - Nash Equilibrium</title>
    <url>/2024/09/11/Game%20Theory%20-%20Nash%20Equilibrium/</url>
    <content><![CDATA[<h1 id="Nash-Equilibrium的定义"><a href="#Nash-Equilibrium的定义" class="headerlink" title="Nash Equilibrium的定义"></a>Nash Equilibrium的定义</h1><p>在一个给定的$n$人战略式博弈 $G=&lt;\Gamma ;S_1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，战略组合 $s^<em>=(s_1^</em>，\cdots，s_i^<em>，\cdots，s_n^</em>)$ 是一个Nash均衡当且仅当 $\forall i \in \Gamma，\forall s_i \in S_i$ ，有：</p>
<script type="math/tex; mode=display">
u_i(s^*_i,s^*_{-i})\ge u_i(s_i,s_{-i})</script><p>或者 $\forall i \in \Gamma，s<em>i^*\in \arg \max \limits</em>{s<em>i \in S_i}u_i(s_i,s^*</em>{-i})$</p>
<ul>
<li><p>传统博弈论中，一般将Nash均衡作为博弈问题的解。</p>
</li>
<li><p>占优战略均衡一定是Nash均衡。</p>
</li>
<li><p>重复剔除的占优均衡也是Nash均衡。</p>
</li>
</ul>
<h1 id="两人战略式博弈中Nash均衡的求解（划线法和箭头法）"><a href="#两人战略式博弈中Nash均衡的求解（划线法和箭头法）" class="headerlink" title="两人战略式博弈中Nash均衡的求解（划线法和箭头法）"></a>两人战略式博弈中Nash均衡的求解（划线法和箭头法）</h1><h2 id="划线法"><a href="#划线法" class="headerlink" title="划线法"></a>划线法</h2><p>划线法利用了Nash的一个性质：</p>
<blockquote>
<p>在两人博弈的时候，相互构成最优战略的战略组合就是Nash均衡。</p>
</blockquote>
<p>具体方法如下：</p>
<ul>
<li><p>考察参与人1的最优战略，对于参与人2的每一个战略，找出来参与人1的最优战略，在其支付下划一横线。</p>
</li>
<li><p>用上述方法找出参与人二的最优战略，然后看看哪一个方格中花了两个横线，该战略组合就是就是Nash均衡。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>b1</strong></th>
<th style="text-align:center"><strong>b2</strong></th>
<th style="text-align:center"><strong>b3</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>a1</strong></td>
<td style="text-align:center">3,2</td>
<td style="text-align:center">1,3</td>
<td style="text-align:center">2,<u><strong>5</strong></u></td>
</tr>
<tr>
<td style="text-align:center"><strong>a2</strong></td>
<td style="text-align:center">2,4</td>
<td style="text-align:center"><u><strong>4</strong></u>,<u><strong>5</strong></u></td>
<td style="text-align:center"><u><strong>3</strong></u>,4</td>
</tr>
<tr>
<td style="text-align:center"><strong>a3</strong></td>
<td style="text-align:center"><u>4</u>,2</td>
<td style="text-align:center">3,1</td>
<td style="text-align:center">2,<u><strong>3</strong></u></td>
</tr>
</tbody>
</table>
</div>
<p>即，观察一行的时候，找右边那个数里面最大的划线；观察一列的时候，找左边那个数里面最大的。</p>
<h2 id="箭头法"><a href="#箭头法" class="headerlink" title="箭头法"></a>箭头法</h2><p>划线法利用了Nash的另一个性质：</p>
<blockquote>
<p>在两人博弈的时候，一个战略组合只有在两个参与人都不愿意偏离的情况下才可以构成Nash均衡。</p>
</blockquote>
<p>具体方法如下：</p>
<ul>
<li><p>对于每一个战略组合，检查是否会有人因为更高的支付而偏离这个战略组合，如果有，就用一个箭头指向索要偏离的战略组合。</p>
</li>
<li><p>找出来没有人会偏离的战略组合，即找到一个方格，这个方格没有箭头指向其他方格，该战略组合就是Nash均衡。</p>
</li>
<li><p>可以任意选择一个方格，顺着他指向的箭头，找到下一个方格，接着顺着这个方格指向的箭头，直至找到尽头，没有箭头可以继续找到下一个战略组合，即为Nash均衡。</p>
<p>|        | <strong>b1</strong> | <strong>b2</strong> | <strong>b3</strong> |<br>| :——: | :——: | :——: | :——: |<br>| <strong>a1</strong> |  3,2   |  1,3   |  2,5   |<br>| <strong>a2</strong> |  2,4   |  4,5   |  3,4   |<br>|   a3   |  4,2   |  3,1   |  2,3   |</p>

</li>
</ul>
<h1 id="混合战略Nash均衡"><a href="#混合战略Nash均衡" class="headerlink" title="混合战略Nash均衡"></a>混合战略Nash均衡</h1><h2 id="定义及相关概念"><a href="#定义及相关概念" class="headerlink" title="定义及相关概念"></a>定义及相关概念</h2><p>在一个给定的有限$n$人战略式博弈$G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$中，对任一参与人$i$，设$S_i={s_i^1,\cdots,s_i^{K_i}}$，则参与人$i$的一个<strong>混合战略为</strong>定义在战略集$S_i$上的一个<strong>概率分布</strong>$\sigma_i=(\sigma_i^1,\cdots,\sigma_i^{K_i},)$，其中$\sigma_i^j(j=1,\cdots,K_i)$表示参与人$i$选择战略$s_i^j$的概率。$\sigma_i^j$满足$0\leq \sigma_i^j \leq 1$且$\sum \limits</em>{j=1}^{K_i}\sigma_i^j=1$。</p>
<ul>
<li><p>当参与人$i$的混合战略$\sigma_i$以概率$1$赋给某一战略$s_i^j$时，即$\sigma_i=(0,\cdots,1,\cdots,0)$，此时，混合战略退化为<strong>纯战略</strong>(pure strategy).</p>
</li>
<li><p>以后用$\Sigma_i={\sigma_i}$表示参与人$i$的<strong>混合战略空间</strong>，用$\sigma=(\sigma_1,\sigma_2,\cdots,\sigma_n)$表示<strong>混合战略组合</strong>。其中$\Sigma_i \in \Sigma_i$，表示博弈中每个参与人$i(i=1,2,\cdots,n)$采用混合战略组合中相应战略$\sigma_i$的一种博弈情形。</p>
</li>
<li>用$\Sigma=\prod\limits_{i=1}^{n}\Sigma_i={(\sigma_1,\sigma_2,\cdots,\sigma_n)|\sigma_i \in \Sigma_i,i=1,2,\cdots,n}$表示<strong>混合战略组合空间</strong>，其中$\sigma \in \Sigma$</li>
</ul>
<h2 id="期望效益"><a href="#期望效益" class="headerlink" title="期望效益"></a>期望效益</h2><p>我们用$\sigma<em>{-i}=(\sigma_1,\cdots,\sigma</em>{i-1},\sigma<em>{i+1},\cdots,\sigma_n,))$表示除了参与人$i$以外的其他参与人的混合战略组合，因此$\sigma=(\sigma_i,\sigma</em>{-i})$,我们用$v<em>i(\sigma)=v_i(\sigma_i,\sigma</em>{-i})$表示参与人$i$在混合战略组合$\sigma=(\sigma<em>i,\sigma</em>{-i})$下的<strong>期望效益</strong>。</p>
<p>如果用$\pi(s)$表示在混合战略$\sigma$下，纯战略组合$s(s \in S)$出现的概率，那么参与人$i$在混合战略组合$\sigma=(\sigma<em>i,\sigma</em>{-i})$下的期望效益$v_i(\sigma)$可以表示为:</p>
<script type="math/tex; mode=display">
\begin{equation}
v_i(\sigma)=v_i(\sigma_i,\sigma_{-i})=\sum_{s\in S}\pi(s)u_i(s)\tag{1}
\end{equation}</script><p> 我们假设每个参与人对于战略的随机选择是<strong>相互独立</strong>的，故有:</p>
<script type="math/tex; mode=display">
\pi(s)=\prod_{j=1}^n \sigma_j(s_j)\tag{2}</script><p>把(2)代入(1)，可得:</p>
<script type="math/tex; mode=display">
\begin{align}
v_i(\sigma) & =v_i(\sigma_i,\sigma_{-i}) \\
& =\sum_{s\in S}\pi(s)u_i(s)\\
& =\sum_{s\in S}[\prod_{j=1}^n \sigma_j(s_j)]u_i(s)\tag{3}\\
\end{align}</script><p>如果参与人$i$选择了纯战略$s<em>i^k(j=1,\cdots,K_i)$，其中$K_i$表示参与人$i$拥有的战略数目，即其战略集的大小。这算是$\sigma$的一个特例，此时可以认为$\sigma=(s_i^k,\sigma</em>{-i})$。进一步，我们用$v<em>i(s_i^k,\sigma</em>{-i})$表示<strong>在其他参与人选择混合战略$\sigma_{-i}$的情况下</strong>，参与人$i$选择纯战略$s_i^k$的期望支付。则(3)式可以写成:</p>
<script type="math/tex; mode=display">
\begin{align}
v_i(\sigma) 
& =v_i(\sigma_i,\sigma_{-i}) \\
&=v_i(s_i^k,\sigma_{-i})\\
& =\sum_{s\in S}[\prod_{j=1}^n \sigma_j(s_j)]u_i(s)\tag{3}\\
& =\sum_{s_{-i}\in S_{-i}}[\prod_{j=1 j\neq i}^n \sigma_j(s_j)]u_i(s_i^k,s_{-i})\tag{4}\\
\end{align}</script><p>（4）式中$\prod \limits<em>{j=1 j\neq i}^n \sigma_j(s_j)$表示在混合战略$\sigma=(s_i^k,\sigma</em>{-i})$下，其他参与人的纯战略组合$s_{-i}$出现的概率。</p>
<blockquote>
<p>此处关于$j\neq i$的理解如下:</p>
<p>既然我们假定了参与人$i$选择战略$s<em>i^k$，那么相当于所有战略组合的集合由于参与人$i$选择纯战略$s_i^k$而从$S={s}$缩小为$S</em>{-i}={s_{-i}}$,所以求和符号下标中战略组合的集合是除去参与人$i$的战略组合的集合。</p>
</blockquote>
<p>上述四式描述了参与人$i$选择一个纯战略的情形，为了获得他混合战略的期望，我们需要对于这些混合战略的每一个分量重复上述步骤，求和，就可以得到这个参与人$i$的期望效用。</p>
<p>继续上述步骤:(注意下式中的$v_i(\sigma)$和上一个推导公式中的不一样，下面的指的是<strong>所有战略</strong>的期望效应)</p>
<script type="math/tex; mode=display">
\begin{align}
v_i(\sigma) 
& =v_i(\sigma_i,\sigma_{-i}) \\
&=\sum \limits _{k=1}^{K_i}\sigma_i^k v_i(s_i^k,\sigma_{-i})\\
&=\sum \limits _{k=1}^{K_i}\sigma_i^k\{\sum_{s_{-i}\in S_{-i}}[\prod_{j=1 j\neq i}^n \sigma_j(s_j)]u_i(s_i^k,s_{-i})\} \tag{5}\\
\end{align}</script><h2 id="混合战略Nash均衡-1"><a href="#混合战略Nash均衡-1" class="headerlink" title="混合战略Nash均衡"></a>混合战略Nash均衡</h2><blockquote>
<p><strong>定义2.7</strong><br>在有限n人战略式博弈 $G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，混合战略组合 $\sigma^<em>=(\sigma_1^</em>,\sigma_2^<em>,\cdots,\sigma_n^</em>)$为一个Nash均衡，<strong>当且仅当</strong>$\forall i \in \Gamma ,\forall \sigma_i \in \Sigma_i$ ,有$v_i(\sigma_i^*,\sigma</em>{-i}^<em>)\ge v<em>i(\sigma_i,\sigma</em>{-i}^</em>)$</p>
<p><strong>定义2.8</strong><br>在有限n人战略式博弈 $G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，混合战略组合 $\sigma^<em>=(\sigma_1^</em>,\sigma_2^<em>,\cdots,\sigma_n^</em>)$为一个Nash均衡，<strong>当且仅当</strong>$\forall i \in \Gamma ,\forall \sigma_i \in \Sigma_i$ ,有$v_i(\sigma_i^*,\sigma</em>{-i}^<em>)\ge v<em>i(s_i,\sigma</em>{-i}^</em>)$</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Nash均衡</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures and Algorithms-Search</title>
    <url>/2024/11/28/Data-Structures-and-Algorithms-Search/</url>
    <content><![CDATA[<p>所谓查找，就是给定一个关键字，找到一个下标，使得给定表中的下标对应元素的关键字等于给定的关键字。</p>
<h1 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h1><p>结构如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序查找表的静态存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType* elem;<span class="comment">//数据中元素的基址，0号单元留空，即下标从1开始</span></span><br><span class="line">    <span class="type">int</span> length;    <span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h2><p>从后往前查找，如果找不到，就把留空的第一个元素（下标为0）置为待查找的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST[<span class="number">0</span>].key=key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ST.length;!<span class="built_in">EQ</span>(ST[i].key,ley);--i);<span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均查找长度$ASL=\dfrac{n+1}{2}$</p>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数是关键字，返回是下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=ST.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123; <span class="comment">//跳出来的条件是严格不等</span></span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>; <span class="comment">//向下取整</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EQ</span>(key,ST[mid].key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">LT</span>(key,ST[mid].key))&#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均查找长度$ASL=\dfrac{n+1}{n}\log_2(n+1)-1$</p>
]]></content>
  </entry>
  <entry>
    <title>Game Theory-Solution to Mixed Strategy Nash Equilibrium Part 1</title>
    <url>/2024/09/14/Game%20Theory-Solution%20to%20Mixed%20Strategy%20Nash%20Equilibrium%20Part%201/</url>
    <content><![CDATA[<h1 id="混合战略Nash均衡回顾"><a href="#混合战略Nash均衡回顾" class="headerlink" title="混合战略Nash均衡回顾"></a>混合战略Nash均衡回顾</h1><blockquote>
<p><strong>定义2.7</strong><br>在有限$n$人战略式博弈 $G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，混合战略组合 $\sigma^<em>=(\sigma_1^</em>,\sigma_2^<em>,\cdots,\sigma_n^</em>)$为一个Nash均衡，<strong>当且仅当</strong>$\forall i \in \Gamma ,\forall \sigma_i \in \Sigma_i$ ,有$v_i(\sigma_i^*,\sigma</em>{-i}^<em>)\ge v<em>i(\sigma_i,\sigma</em>{-i}^</em>)$</p>
<p><strong>定义2.8</strong><br>在有限$n$人战略式博弈 $G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，混合战略组合 $\sigma^<em>=(\sigma_1^</em>,\sigma_2^<em>,\cdots,\sigma_n^</em>)$为一个Nash均衡，<strong>当且仅当</strong>$\forall i \in \Gamma ,\forall \sigma_i \in \Sigma_i$ ,有$v_i(\sigma_i^*,\sigma</em>{-i}^<em>)\ge v<em>i(s_i,\sigma</em>{-i}^</em>)$</p>
</blockquote>
<p>关于参与人$i$的最优混合战略，有如下命题成立:</p>
<blockquote>
<p><strong>命题2.1</strong><br>在参与人 $i$ 的最优混合战略$\sigma_i^<em>=(\sigma_i^{1</em>},\sigma_i^{2<em>},\cdots,\sigma_i^{K_i</em>})$中，对$\forall \sigma_i^{j*}&gt;0$,有:</p>
<script type="math/tex; mode=display">
v_i(s_i^j,\sigma_{-i})=v_i(\sigma_i^*,\sigma_{-i})</script></blockquote>
<p>命题2.1的含义如下:</p>
<p>如果 $\sigma<em>i^*$ 是参与人 $i$ 在给定对手选择混合战略 $\sigma</em>{-i}$ 下的最优混合战略，若混合战略规定参与人 $i$ 以正概率选择纯概率 $s<em>i^k$ ，则 $s_i^k$ 一定也是给定 $\sigma</em>{-i}$ 下的一个最优战略，也就是说，<strong>所有以正概率进入最优混合战略的纯战略都是参与人 $i$ 的最优战略，并且参与人 $i$ 在所有这些纯战略之间一定是无差异的</strong>，即如果 $\sigma_i^{1<em>}&gt;0,\cdots, \sigma_i^{k</em>}&gt;0$ ,则有:</p>
<script type="math/tex; mode=display">
v_i(s_i^1,\sigma_{-i})=v_i(s_i^2,\sigma_{-i})=\cdots=v_i(s_i^k,\sigma_{-i})=v_i(\sigma_i^*,\sigma_{-i})</script><p>反之，<strong>如果参与人 $i$ 有$n$个纯战略是最优的，那么这些纯战略上的任何一个概率分布都是参与人 $i$ 的最优混合战略。</strong></p>
<p><strong>证明</strong>如下:</p>
<p>首先，如果 $\sigma_i^<em>=(\sigma_i^{1</em>},\sigma_i^{2<em>},\cdots,\sigma_i^{K_i</em>})$ 是一个<strong>纯战略</strong>，那么 $\sigma_i^*$ 的分量中只有一个为 $1$，其余均为 $0$ ,命题2.1显然成立。</p>
<p><strong>考虑一般情况</strong>，如果 $\sigma_i^<em>=(\sigma_i^{1</em>},\sigma_i^{2<em>},\cdots,\sigma_i^{K_i</em>})$ 不是一个纯战略，那么 $\sigma_i^<em>$ 的分量中至少含有两个或者两个以上严格大于0的分量，不妨设 $\sigma(s^{j</em>})$ 和 $\sigma(s_i^{h<em>})$ 大于 $0$ ，由于这两个量是<strong>随意选取</strong>的，我们只需要证明 $\sigma(s^{j</em>})$ 和 $\sigma(s_i^{h*})$ 均满足命题2.1即可，也就是:</p>
<script type="math/tex; mode=display">
\begin{cases}

v_i(s_i^{j},\sigma_{-i})&=v_i(\sigma_i^*,\sigma_{-i})   \\
v_i(s_i^{h},\sigma_{-i})&=v_i(\sigma_i^*,\sigma_{-i}) 

  \end{cases}</script><p>即，只需要证明 $v<em>i(s_i^{j},\sigma</em>{-i})=v<em>i(s_i^{h},\sigma</em>{-i})$ 即可。我们采用<strong>反证法</strong>。假设 $v<em>i(s_i^{j*},\sigma</em>{-i})\neq v<em>i(s_i^{h*},\sigma</em>{-i})$ ,由于希望战略 $s^{j}$ 和战略 $s^{h}$ 是随意选取的，我们就进一步假设 $v<em>i(s_i^{j},\sigma</em>{-i})&gt; v<em>i(s_i^{h},\sigma</em>{-i})$ ，<strong>希望推出与“$\sigma_i^*$ 是参与人 $i$ 的最优混合战略”这一前提相悖的结论</strong>。为此我们构造出一个参与人 $i$ 的混合战略 $\sigma_i’=(\sigma_i^{1’},\sigma_i^{2’},\cdots,\sigma_i^{K_i’})$ ,满足以下性质:</p>
<p>(1). 对 $\forall k \in {1,2,\cdots,K_i}$ ,若 $k\neq j $ 且 $k\neq h $ ,则 $\sigma_i^{k’}=\sigma_i^{k*}$ ;</p>
<p>(2). $\sigma_i^{j’}=\sigma_i^{j<em>}+\sigma_i^{h</em>},\quad \sigma_i^{h’}=0$</p>
<p>上述两条说明，与最优混合战略 $\sigma_i^<em>$ 相比，在混合战略 $\sigma_i^{‘}$ 中,只有战略 $s^{j</em>}$ 和战略 $s^{h<em>}$ 对应的概率不一样，其余均一样。由<em>*期望效用的公式</em></em>可得:</p>
<script type="math/tex; mode=display">
\begin{align}
v_i(\sigma_i',\sigma_{-i}')-v_i(\sigma_i^*,\sigma_{-i}^*)
&=\sum\limits _{k=1}^{K_i}\sigma_i^{k'}v_i(s_i^{k},\sigma_{-i})-\sum\limits _{k=1}^{K_i}\sigma_i^{k*}v_i(s_i^{k},\sigma_{-i})\\
&=\sigma_i^{j'}v_i(s_i^{j},\sigma_{-i})+\sigma_i^{h'}v_i(s_i^{h},\sigma_{-i})-\sigma_i^{j*}v_i(s_i^{j},\sigma_{-i})-\sigma_i^{h*}v_i(s_i^{h},\sigma_{-i})\\
&=(\sigma_i^{j*}+\sigma_i^{h*})v_i(s_i^{j},\sigma_{-i})+0 \cdot v_i(s_i^{h},\sigma_{-i})-\sigma_i^{j*}v_i(s_i^{j},\sigma_{-i})-\sigma_i^{h*}v_i(s_i^{h},\sigma_{-i})\\
&=\sigma_i^{h*}v_i(s_i^{j},\sigma_{-i})-\sigma_i^{h*}v_i(s_i^{h},\sigma_{-i})\\
&=\sigma_i^{h*}(v_i(s_i^{j},\sigma_{-i})-v_i(s_i^{h},\sigma_{-i}))\\
&>0
\end{align}</script><p>由此，我们推出了$\sigma<em>i^*$ 并不是参与人 $i$ 的最优混合战略，这和假设矛盾，所以 $v_i(s_i^{j},\sigma</em>{-i})=v<em>i(s_i^{h},\sigma</em>{-i})$ 成立，即在$\sigma_i^<em>=(\sigma_i^{1</em>},\sigma_i^{2<em>},\cdots,\sigma_i^{K_i</em>})$ 不是一个纯战略的情况下，命题2.1也成立。</p>
<h1 id="最优反应及最优反应引理"><a href="#最优反应及最优反应引理" class="headerlink" title="最优反应及最优反应引理"></a>最优反应及最优反应引理</h1><p>上述内容所讨论的都是对于<strong>单个参与人</strong> $i$ 的情况，是单个参与人的最优混合战略。我们没有提及Nash均衡，因为Nash均衡是针对多个参与人而言的，所以下面的几个概念/定理说明了<strong>多个参与人</strong>的时候，混合战略Nash均衡的定义。</p>
<blockquote>
<p><strong>最优反应</strong><br>我们用 $p^*(q)$表示在给定参与人 $2$ 的混合战略 $\sigma_2=(q,1-q)$ 的情况下，参与人 $1$ 的最优反应。</p>
<p><strong>支集</strong><br>对于给定的参与人 $i$ 的混合战略 $\sigma_i$ ,称 $\sigma_i$ 中所有大于0的分量对应的纯战略组合的集合为 $\sigma_i$ 的支集，记为 $S_i(\sigma_i)$ ,即  $S_i(\sigma_i)={s_i \in S_i | \sigma_i(s_i)&gt;0}$ </p>
<p><strong>最优反应的引理</strong><br>在有限 $n$ 人战略式博弈 $G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，混合战略组合 $\sigma^<em>=(\sigma_1^</em>,\sigma_2^<em>,\cdots,\sigma_n^</em>)$为一个Nash均衡，<strong>当且仅当</strong>$\forall i \in \Gamma $ , $\sigma_i^<em> $的支集 $S_i(\sigma_i^</em>)$ 中的每一个战略都是给定 $\sigma</em>{-i}^* $ 下的最优反应。</p>
</blockquote>
<h1 id="等值法求解-2-times-2-战略式博弈"><a href="#等值法求解-2-times-2-战略式博弈" class="headerlink" title="等值法求解 $2\times 2$ 战略式博弈"></a>等值法求解 $2\times 2$ 战略式博弈</h1><p>等值法基于下面的假设:在最优混合战略中，大于0的分量对应的纯战略的期望支付相等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th style="text-align:center">$q$</th>
<th>$1-q$</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td style="text-align:center">$b_1$</td>
<td>$b_2$</td>
</tr>
<tr>
<td>$p$</td>
<td>$a_1$</td>
<td style="text-align:center"><strong>$x_1,y_1$</strong></td>
<td><strong>$x_2,y_2$</strong></td>
</tr>
<tr>
<td>$1-p$</td>
<td>$a_2$</td>
<td style="text-align:center"><strong>$x_3,y_3$</strong></td>
<td><strong>$x_4,y_4$</strong></td>
</tr>
</tbody>
</table>
</div>
<p>假定 $\sigma_1=(p,1-p)$，$\sigma_2=(q,1-q)$ 为参与人 $1$和参与人 $2$ 的混合战略， $\sigma_1,\sigma_2$ 为博弈的混合战略Nash均衡，不失一般性，假设 $p \in (0,1),q \in (0,1)$ ,因此 $1-p \in (0,1),1-q \in (0,1)$ ，根据最优战略的性质，有:</p>
<script type="math/tex; mode=display">
%\left\{
\begin{cases}

v_1(a_1,\sigma_2)=v_1(a_2,\sigma_2)\\
v_2(b_1,\sigma_1)=v_2(b_2,\sigma_2)

\end{cases}
%\right.</script><p>即:</p>
<script type="math/tex; mode=display">
\begin{cases}

qx_1+(1-q)x_1=qx_3+(1-q)x_4\\
py_1+(1-p)y_3=py_2+(1-p)y_4

\end{cases}</script><p>求解上述方程可得:</p>
<script type="math/tex; mode=display">
\begin{cases}

p=\dfrac{y_3-y_4}{y_2-y_1+y_3-y_4}\\
q=\dfrac{x_2-x_4}{x_3-x_1+x_2-x_4}

\end{cases}</script><p>对于参与人大于 $2$ 的博弈问题，无法直接利用”等值法”求解。</p>
<h1 id="支撑求解法"><a href="#支撑求解法" class="headerlink" title="支撑求解法"></a>支撑求解法</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><blockquote>
<p><strong>支撑</strong></p>
<p>对于给定的混合战略组合 $\sigma$ , $\sigma$ 的支撑，记为 $S(\sigma)$，指的是参与人按照  $\sigma$ 选择战略的时候，所有参与人支集 $S<em>i(\sigma_i)={s_i\in S_i|\sigma_i(s_i)&gt;0}$ 的直积，即 $S(\sigma)=\prod\limits</em>{i\in \Gamma}{s_i \in S_i|\sigma_i(s_i)&gt;0}$</p>
</blockquote>
<p>举例:</p>
<p>比如在两人战略式博弈中，</p>
<script type="math/tex; mode=display">
S_{1}=\left\{s_{1}^{1},\quad s_{1}^{2},\quad s_{1}^{3},\quad s_{1}^{4}\right\},\quad S_{2}=\left\{s_{2}^{1},\quad s_{2}^{2},\quad s_{2}^{3}\right\}</script><p>设 </p>
<script type="math/tex; mode=display">
\sigma_1=(0.1,\quad 0.5,\quad 0,\quad 0.4),\quad \sigma_2=(0.6,\quad 0,\quad 0.4 )</script><p>所以有:</p>
<script type="math/tex; mode=display">
S_1(\sigma_1)=\{s_1^1,\quad s_1^2,\quad s_1^4\},\quad S_2(\sigma_2)=\{s_2^1,\quad s_2^3\}</script><p>战略组合 $\sigma=(\sigma_1,\sigma_2)$ 的支撑为:</p>
<script type="math/tex; mode=display">
S(\sigma)=\{s_1^1, s_1^2,s_1^4\}\times\{s_2^1, s_2^3\} =\{(s_1^1,s_2^1),\quad (s_1^1, s_2^3),\quad (s_1^2, s_2^1),\quad (s_1^2,s_2^3),\quad (s_1^4,\quad s_2^1),\quad (s_1^4,\quad s_2^3)\}</script><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>对于给定的有限$n$人战略式博弈 $G=&lt;\Gamma ;S<em>1,S_2,\cdots,S_n ;u_1,u_2,\cdots,u_n &gt;$ 中，假设混合战略组合 $\sigma^<em>=(\sigma_1^</em>,\sigma_2^<em>,\cdots,\sigma_n^</em>)$为一个Nash均衡，此时考察 $\sigma$ 的支撑 $S(\sigma)=\prod \limits </em>{i\in \Gamma}S_i(\sigma_i^<em>)$ ,对于$\forall i \in \Gamma,\sigma _i^</em>= (\sigma _i^<em>(s_i^1), \sigma _i^</em>(s_i^2),\quad \cdots\quad \sigma _i^<em>(s_i^{K_i}))$，不失一般性，设$\sigma _i^</em>(s_i^1),\quad \sigma _i^<em>(s_i^2),\quad \cdots\quad \sigma _i^</em>(s_i^{K_i})&gt;0$ ，则参与人 $i$ 关于战略组合 $\sigma^<em>$的支集为 $S_i(\sigma_i^</em>)={s_i^1,\cdots,s_i^{k_i}}$ ，（注意是小k）由<strong>最优反应的引理</strong>可得:</p>
<script type="math/tex; mode=display">
\left\{
\begin{align}

\sum\limits_{s_{-i}\in S_{-i}}(\prod\limits_{j\in \Gamma,j\neq i}\sigma_j^*(s_j))\cdot u_i(s_i^1,s_{-i}) &= \mathbf v_i \tag{1}\\
\sum\limits_{s_{-i}\in S_{-i}}(\prod\limits_{j\in \Gamma,j\neq i}\sigma_j^*(s_j))\cdot u_i(s_i^2,s_{-i}) &= \mathbf v_i \tag{2}\\
& \vdots\\
\sum\limits_{s_{-i}\in S_{-i}}(\prod\limits_{j\in \Gamma,j\neq i}\sigma_j^*(s_j))\cdot u_i(s_i^{k_i},s_{-i}) &= \mathbf v_i \tag{$k_i$}\\
\sum\limits_{j=1}^{k_i}\sigma_j^*(s_i^j)&=1 \tag{$k_i+1$}



\end{align}
\right.</script><p>上述一共 $k_i+1$ 个未知数 [即 $\sigma _i^<em>(s_i^1), \sigma _i^</em>(s_i^2),\quad \cdots\quad \sigma _i^*(s_i^{K_i})$] 和 $k_i+1$ 个方程，考虑一般性，就可以解出所有的未知数，即混合最优战略。</p>
<h2 id="例子-Page-43例2-10"><a href="#例子-Page-43例2-10" class="headerlink" title="例子(Page 43例2.10)"></a>例子(Page 43例2.10)</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>$A(\sigma_2^A)$</th>
<th>$B(\sigma_2^B)$</th>
<th>$C(\sigma_2^C)$</th>
<th>$D(\sigma_2^D)$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$U(\sigma_1^U)$</td>
<td>$0,2$</td>
<td>$6,1$</td>
<td>$2,3$</td>
<td>$4,6$</td>
</tr>
<tr>
<td>$L(\sigma_1^L)$</td>
<td>$4,3$</td>
<td>$2,6$</td>
<td>$1,2$</td>
<td>$6,1$</td>
</tr>
</tbody>
</table>
</div>
<p>在上述博弈问题中，很显然无法通过重复剔除劣战略达到纯Nash战略均衡。因此不存在其制程中只包含参与人一个战略的Nash均衡。因此，在上述博弈问题中，可能的支撑如下:</p>
<script type="math/tex; mode=display">
%\begin{align}
\\1个2\times 4战略组合:\\
\{U,L\}\times\{A,B,C,D\}\\

\\4个2\times 3战略组合:\\
\{U,L\}\times\{A,B,C\},\qquad \{U,L\}\times\{B,C,D\},\\
 \{U,L\}\times\{A,C,D\},\qquad \{U,L\}\times\{A,B,D\}\\

\\6 个2\times 2战略组合:\\
\{U,L\}\times\{A,B\},\qquad \{U,L\}\times\{A,C\},\qquad \{U,L\}\times\{A,D\},\\
\{U,L\}\times\{B,C\},\qquad  \{U,L\}\times\{B,D\},\qquad  \{U,L\}\times\{C,D\}  \\


%\end{align}</script><p>下面我们逐一判断这些战略组合:</p>
<h4 id="2-times-4战略组合-U-L-times-A-B-C-D"><a href="#2-times-4战略组合-U-L-times-A-B-C-D" class="headerlink" title="$2\times 4战略组合:{U,L}\times{A,B,C,D}$"></a>$2\times 4战略组合:{U,L}\times{A,B,C,D}$</h4><p>对于参与人1或者2，其战略组合的支集中每个纯战略获得的期望支付相同，由此我们可以列出来方程:</p>
<script type="math/tex; mode=display">
\begin{cases}v_1(U,\sigma_2)=v_1(L,\sigma_2)=v_1(\sigma_1,\sigma_2)=v_1\\v_2(\sigma_1,A)=v_2(\sigma_1,B)=v_2(\sigma_1,C)=v_2(\sigma_1,D)=v_2(\sigma_1,\sigma_2)=v_2\end{cases}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{cases}

&6\sigma_{2}^{B}+2\sigma_{2}^{C}+4\sigma_{2}^{D}=\upsilon_{1}\\&4\sigma_{2}^{A}+2\sigma_{2}^{B}+\sigma_{2}^{C}+6\sigma_{2}^{D}=\upsilon_{1}\\&2\sigma_{1}^{U}+3\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{1}^{U}+6\sigma_{1}^{L}=\upsilon_{2}\\&3\sigma_{1}^{U}+2\sigma_{1}^{L}=\upsilon_{2}\\&6\sigma_{1}^{U}+\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{2}^{A}+\sigma_{2}^{B}+\sigma_{2}^{C}+\sigma_{2}^{D}=1\\&\sigma_{1}^{L}+\sigma_{1}^{U}=1

\end{cases}</script><p>上述方程中，显然，由于我们的前提就是混合战略，排除了纯战略，故未知数都<strong>严格大于零</strong>，考虑到上述方程组中3~6个方程的特点，如果有解，则 $\sigma_1^U=\sigma_1^L=0$ ,所以上述方程不存在正数解，即 ${U,L}\times{A,B,C,D}$ 不可能成为博弈的均衡支撑。</p>
<h4 id="2-times-3-战略组合"><a href="#2-times-3-战略组合" class="headerlink" title="$2\times 3$战略组合"></a>$2\times 3$战略组合</h4><p>同理，利用对于参与人1或者2，其战略组合的支集中每个纯战略获得的期望支付相同这一性质，我们列出来$2\times 3$战略组合${U,L}\times{A,B,C}$的方程：</p>
<script type="math/tex; mode=display">
\begin{cases}
&6\sigma_{2}^{B}+2\sigma_{2}^{C}=\upsilon_{1}\\&4\sigma_{2}^{A}+2\sigma_{2}^{B}+\sigma_{2}^{C}=\upsilon_{1}\\&2\sigma_{1}^{U}+3\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{1}^{U}+6\sigma_{1}^{L}=\upsilon_{2}\\&3\sigma_{1}^{U}+2\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{2}^{A}+\sigma_{2}^{B}+\sigma_{2}^{C}=1\\&\sigma_{1}^{L}+\sigma_{1}^{U}=1\end{cases}</script><p>各个等式之间依然存在矛盾问题， 所以上述方程组没有正数解，即$2\times 3战略组合:{U,L}\times{A,B,C}$不可能成为博弈的均衡支撑。</p>
<p>基于同样的原因，其他的$2\times 3$ 战略组合:${U,L}\times{A,B,D},\quad{U,L}\times{B,C,D},\quad {U,L}\times{A,C,D},\quad$都不是博弈的均衡支撑。</p>
<p>接下来从 $2\times 2$ 的战略组合中寻找可能的均衡支撑。</p>
<h4 id="2-times-2战略组合-U-L-times-A-B"><a href="#2-times-2战略组合-U-L-times-A-B" class="headerlink" title="$2\times 2战略组合:{U,L}\times{A,B}$"></a>$2\times 2战略组合:{U,L}\times{A,B}$</h4><script type="math/tex; mode=display">
\begin{cases}&6\sigma_{2}^{B}=\upsilon_{1}\\&4\sigma_{2}^{A}+2\sigma_{2}^{B}=\upsilon_{1}\\&2\sigma_{1}^{U}+3\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{1}^{U}+6\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{1}^{U}+\sigma_{1}^{L}=1\\&\sigma_{2}^{A}+\sigma_{2}^{B}=1\end{cases}</script><p>上述方程组，可以求得唯一的正数解，即：</p>
<script type="math/tex; mode=display">
\begin{cases}
\sigma_1^U=\frac{3}{4}\\
\sigma_1^L=\frac{1}{4}\\
\sigma_2^A=\sigma_2^B=\frac{1}{2}\\
v_1=3\\
v_2=\frac{9}{4}
\end{cases}</script><p>但是，此时如果我们让参与人 $1$ 采用这个解，但是让参与人 $2$ 采用纯战略$C$，此时参与人 $1$ 和 $2$ 的期望收益变为:</p>
<script type="math/tex; mode=display">
v_1(\sigma_1,C)=\frac{7}{4}\\
\text{However,}\quad v_2(\sigma_1,C)=\frac{11}{4}>\frac{9}{4}</script><p>故，参与人 $2$ 必定会偏离这个解，因此，${U,L}\times{A,B}$ 不是博弈的均衡支撑。</p>
<h4 id="2-times-2战略组合-U-L-times-A-C"><a href="#2-times-2战略组合-U-L-times-A-C" class="headerlink" title="$2\times 2战略组合:{U,L}\times{A,C}$"></a>$2\times 2战略组合:{U,L}\times{A,C}$</h4><p>当支撑是${U,L}\times{A,C}$的时候，仿照上例，得到方程为:</p>
<script type="math/tex; mode=display">
\begin{cases}&2\sigma_{2}^{C}=v_{1}\\&4\sigma_{2}^{A}+\sigma_{2}^{C}=v_{1}\\&2\sigma_{1}^{U}+3\sigma_{1}^{L}=v_{2}\\&3\sigma_{1}^{U}+2\sigma_{1}^{L}=v_{2}\\&\sigma_{1}^{L}+\sigma_{1}^{U}=1\\&\sigma_{2}^{A}+\sigma_{2}^{C}=1\end{cases}</script><p>它的解是：</p>
<script type="math/tex; mode=display">
\begin{cases}
\sigma_1^U=\sigma_1^L=\frac{1}{2}\\
\sigma_2^A=\frac{1}{5}\\
\sigma_2^C=\frac{4}{5}\\
v_1=\frac{8}{5}\\
v_2=\frac{5}{2}
\end{cases}</script><p>但是我们再考虑一种情况，给定 $\sigma_1=(\frac{1}{2},\frac{1}{2})$ ，让参与人 $2$ 去选择纯战略 $B$ ，则此时，$v_2(\sigma_1,B)=v_2(\sigma_1,D)=\frac{7}{2}$,即此时参与人 $2$ 选择纯战略的支付大于在所求解均衡中的支付，即 ${U,L}\times{A,C}$ 不可能成为博弈的均衡支撑。</p>
<h4 id="2-times-2战略组合-U-L-times-A-D-和-U-L-times-C-D"><a href="#2-times-2战略组合-U-L-times-A-D-和-U-L-times-C-D" class="headerlink" title="$2\times 2战略组合:{U,L}\times{A,D} 和{U,L}\times{C,D}$"></a>$2\times 2战略组合:{U,L}\times{A,D} 和{U,L}\times{C,D}$</h4><p>和之前的情况一样，求解出来上述均衡支撑之后，可以找到不属于均衡支撑的纯战略，使得期望支付更大，所以这两种情况排除。</p>
<h4 id="2-times-2战略组合-U-L-times-B-D"><a href="#2-times-2战略组合-U-L-times-B-D" class="headerlink" title="$2\times 2战略组合:{U,L}\times{B,D}$"></a>$2\times 2战略组合:{U,L}\times{B,D}$</h4><p>列出来方程组如下:</p>
<script type="math/tex; mode=display">
\begin{cases}
&6\sigma_{2}^{B}+4\sigma_{2}^{D}=\upsilon_{1}\\&2\sigma_{2}^{B}+6\sigma_{2}^{D}=\upsilon_{1}\\&\sigma_{1}^{U}+6\sigma_{1}^{L}=\upsilon_{2}\\&6\sigma_{1}^{U}+\sigma_{1}^{L}=\upsilon_{2}\\&\sigma_{1}^{L}+\sigma_{1}^{U}=1\\&\sigma_{2}^{B}+\sigma_{2}^{D}=1
\end{cases}</script><p>上述方程组的解为</p>
<script type="math/tex; mode=display">
\begin{cases}
\sigma_1^U=\sigma_1^L=\frac{1}{2}\\
\sigma_1^B=\frac{1}{3}\\
\sigma_1^D=\frac{2}{3}\\
v_1=\frac{14}{3}\\
v_2=\frac{7}{2}
\end{cases}</script><p>参与人 $2$ 在均衡中的所得均大于选择纯战略 $A$ 或 $C$ 的所得，所以上述解构成<strong>混合战略Nash均衡</strong>：</p>
<script type="math/tex; mode=display">
(\sigma_1,\sigma_2)=((\frac{1}{2},\frac{1}{2}),(0,\frac{1}{3},0,\frac{2}{3}))</script><h2 id="合理分析以减少运算"><a href="#合理分析以减少运算" class="headerlink" title="合理分析以减少运算"></a>合理分析以减少运算</h2><p>从上述例子中可以看出来，如果无法事先确定好支撑，就只能逐一计算，导致计算量十分巨大。因此我们可以进行如下分析，进而排除不合理的支撑，减少计算量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>$A(\sigma_2^A)$</th>
<th>$B(\sigma_2^B)$</th>
<th>$C(\sigma_2^C)$</th>
<th>$D(\sigma_2^D)$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$U(\sigma_1^U)$</td>
<td>$0,2$</td>
<td>$6,1$</td>
<td>$2,3$</td>
<td>$4,6$</td>
</tr>
<tr>
<td>$L(\sigma_1^L)$</td>
<td>$4,3$</td>
<td>$2,6$</td>
<td>$1,2$</td>
<td>$6,1$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="分析1"><a href="#分析1" class="headerlink" title="分析1"></a>分析1</h4><p>第一种分析方法思路是，<strong>如果某一个支撑是最后的Nash均衡，那么这个均衡中的各个战略必定不存在严格的占优行为。</strong></p>
<p>考虑一种战略组合 ${U,L}\times{A,D}$,假定它是我们要求解的均衡支撑。那么参与人 $1$ 的两个战略 $ U$ 和 $ L$ 之间必定不存在占优行为，即不管参与人 $2$ 选择什么战略，那么参与人 $1$ 的两个战略 $ U$ 和 $ L$ 没有明显的占优，我们不能把其中一个战略剔除掉。</p>
<p>明显，无论参与人 $2$ 在支撑集 ${A,D}$上有任何的概率分布，参与人 $1$ 选择战略 $L$ 获得的期望支付大于选择战略 $U$ 的期望支付，所以，在这种战略组合中，存在参与人 $1$ 的 $L$ 对 $ U$ 的占优，即战略组合 ${U,L}\times{A,D}$必定不是我们要找的均衡支撑！</p>
<p>同样的道理，战略组合 ${U,L}\times{B,C}$也不是我们要找的支撑。</p>
<h4 id="分析2"><a href="#分析2" class="headerlink" title="分析2"></a>分析2</h4><p>第二种分析方法是通过<strong>构造不含有某一个战略的混合战略，彻底排除该战略。</strong></p>
<p>构造出来参与人 $2$ 的一个不含战略 $A$ 的混合战略 $\sigma_2=(0,\frac{1}{2},\frac{1}{3},\frac{1}{6})$ ,很显然，无论参与人 $1$ 选择战略 $U$ ,还是选择战略 $L$ ,参与人 $2$ 的期望支付总是大于选择纯战略 $A$ 的期望支付。更进一步，不管参与人 $1$ 的混合战略分布 $\sigma_1=(\sigma_1^U,\sigma_1^L)$如何取值，对于参与人 $2$ ，选择混合战略  $\sigma_2=(0,\frac{1}{2},\frac{1}{3},\frac{1}{6})$ 总是优于选择纯战略 $A$.</p>
<p>即 $\sigma_2=(0,\frac{1}{2},\frac{1}{3},\frac{1}{6})$ 对纯战略 $A$ 严格占优！ </p>
<p>既然纯战略 $A$ 是参与人 $2$ 的严格劣战略，因此我们可以<strong>将纯战略 $A$ 从参与人 $2$ 的均衡战略支集中排除。</strong></p>
<p>同样，我们可以构造出来参与人 $2$ 的一个不含战略 $C$ 的混合战略 $\sigma_2=(\frac{1}{3},\frac{1}{6},0，\frac{1}{2})$，这个战略对纯战略 $C$ 严格占优，因此可以把纯战略 $C$ 从参与人 $2$ 的均衡战略支集中排除。</p>
<p>因此，该博弈问题中的可能的均衡支撑只有 ${U,L}\times{B,D}$.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Nash均衡</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory-Stackelberg Model</title>
    <url>/2024/11/03/Game%20Theory-Stackelberg%20Model/</url>
    <content><![CDATA[<h1 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h1><ul>
<li><p>企业生产的产品是同质无差异的；</p>
</li>
<li><p>企业进行的是产量竞争，也就是说，企业的决策变量为产量</p>
</li>
<li><p>企业的行动顺序是有先后的，且其先后顺序由外生给定，即，模型为动态的。</p>
</li>
</ul>
<p>Stackelberg模型属于<strong>完全信息动态博弈</strong>，因此必须用子博弈精炼Nash均衡来描述模型的解。可以用逆向归纳法求解。</p>
<h1 id="求解分析"><a href="#求解分析" class="headerlink" title="求解分析"></a>求解分析</h1><p>假设企业$1$先选择自己的战略——产量 $q_1\in Q_1=[0,+\infty]$ ,因此企业 $1$ 称为领头者(leader),企业 $2$ 称为尾随者(follower).采用逆向归纳法的思路是，企业 $2$ 在行动的时候能够观测到企业 $1$ 的产量 $q_1$，从而企业 $2$ 会根据$q_1$选择自己的产量以使自己的利润最大，因此企业$2$的战略应该是从 $Q_1$ 到 $Q_2$ 的函数，即 $q_2:Q_1\to Q_2$。而企业 $1$ 的战略就是简单的选择自己的产量 $q_1$，但是企业 $1$ 在选择 $q_1$ 的时候知道企业 $2$ 将根据自己的产量来选择，即企业  $1$ 在选择 $q_1$ 的时候知道企业 $2$ 的战略 $q_2(q_1)$，即企业 $1$即是选择 $q_1$使得 $\pi_1(q_1,q_2(q_1))$最大。</p>
<p>假设市场的需求函数为 $P=a-(q_1+q_2)$,两个企业有相同且不变的单位成本 $c$，则企业 $i$ 的利润函数为:</p>
<script type="math/tex; mode=display">
\pi_i(q_1,q_2)=q_i(a-q_i-q_j-c)</script><p>其中 $i,j=1,2\quad i \neq j$</p>
<p>采用逆向归纳法，尾随者企业 $2$ 的最优化问题为:</p>
<script type="math/tex; mode=display">
\max_{q_2>0}\pi_2(q_1,q_2)=q_2(a-q_1-q_2-c)</script><p>由最优化一阶条件：</p>
<script type="math/tex; mode=display">
\tag{8.1}
q_2(q_1)=\frac{1}{2}(a-q_1-c)</script><p>为了保证最优内点存在，这里假设 $q_1&lt;a-c$ ，上式就是企业$2$的最佳战略。企业 $1$ 根据这个做决策，他面对的最优化问题为:</p>
<script type="math/tex; mode=display">
\begin{align}
\max \pi_1(q_1,q_2(q_1))&=q_1[a-q_1-q_2(q_1)-c]\\
&=q_1[a-q_1-\frac{1}{2}(a-q_1-c)-c]\\
&=-\frac{1}{2}q_1^2+\frac{1}{2}(a-c)q_1

\end{align}</script><p>由最优化一阶条件：</p>
<script type="math/tex; mode=display">
q_1^*=\frac{1}{2}(a-c)</script><p>带入8.1,得到</p>
<script type="math/tex; mode=display">
q_2^*=\frac{1}{4}(a-c)</script><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因此子博弈精炼Nash均衡为 $ \Big(\frac{1}{2}(a-c),\frac{1}{4}(a-c)\Big)$ ，与静态博弈——Cournot模型的均衡产量 $\Big(\frac{1}{3}(a-c),\frac{1}{3}(a-c)\Big)$ 相比，可以发现，企业 $1$ 先行动，产量增多，企业 $2$ 后行动，产量变少。</p>
<p>再看利润，Stackelberg模型中先行动的企业 $1$ 得到的利润是 $\frac{1}{8}(a-c)^2$ ，<mark class="hl-label yellow">大于</mark>Cournot模型中的利润 $\frac{1}{9}(a-c)^2$；</p>
<p>后行动的企业 $1$ 得到的利润是 $\frac{1}{16}(a-c)^2$ ，<mark class="hl-label red">小于</mark>Cournot模型中的利润 $\frac{1}{9}(a-c)^2$；</p>
<p>这说明在Stackelberg模型中领头者具有“先动优势”，虽然尾随着具有信息优势，但是这种优势并没有给他带来收益，反而损害了他的利益。</p>
<p>在 Stackelberg 模型中领头者获得的均衡利润要大于Coummot 均衡中的利润，说明了在一定情形下承诺的价值。在Stackelberg 模型中领头者的产品一旦生产出来，就变成了一种<font color="red">沉淀成本 </font>，无法改变，因而尾随者不得不认为领头者的威胁是可置信的。如果领头者并没有实际生产而只是威胁宣称他将生产 $\frac{1}{2}(a-c)$，尾随者是不会相信他的威胁的。因为如果尾随者相信领头者的威胁，选择产量 $\frac{1}{4}(a-c)$，则领头者就会根据Cournot模型中的反应函数，选择 $R_1(q_2)= \frac{1}{2}(a-q_2-c)= \frac{3}{8}(a-c)$产量。<br>从 Stackelberg 模型的子博弈精炼 Nash 均衡，我们也可以进一步地理解 Nash 均衡与子博弈精炼 Nash 均衡的区别。按Nash 均衡的定义，上述 Stackelberg 模型还有其他的 Nash 均衡，如 Cournot 均衡 $(\frac{1}{3}(a-c),\frac{1}{3}(a-c))$，也是一个 Nash 均衡。因为给定企业 $1$ 选择产 $\frac{1}{3}(a-c)$ ,企业 $2$ 的最优选择为 $\frac{1}{3}(a-c)$ ；同理给定企业 $2$ 选择 $\frac{1}{3}(a-c)$ ，企业 $1$ 的最优选择也为 $\frac{1}{3}(a-c)$ 。但这个 Nash 均衡不是子博弈精炼均衡，因为 $q_2(q_1)=\frac{1}{3}(a-c)$ 并不在所有子博弈上构成 Nash 均衡。事实上 $q_2(q_1)=\frac{1}{3}(a-c)$ 是一个不可置信的威胁，如果企业 $1$ 选择的产量不为 $\frac{1}{3}(a-c)$ ，企业 $2$ 也不会选择 $\frac{1}{3}(a-c)$ 。</p>
<h1 id="固定成本"><a href="#固定成本" class="headerlink" title="固定成本"></a>固定成本</h1><p>此外，在前面的讨论中，我们都没有考虑企业生产中的固定成本。企业的固定成本虽然对企业的产量决策(即如果生产，生产多少)不会产生直接影响，但却会影响企业的进入决策(即是否生产)。下面通过一个算例分析固定成本对企业决策及最终均衡的影响。</p>
<p>假设市场的需求函数仍然为 $P=a-(q_1+q_2)$，企业 i(i=1，2) 生产的固定成本为 K_i，平均单位变动成本为 c_i (这里假设c_i 为常数)。仿前面的计算，可以得到:企业 $1$ 和企业 $2$ 的Stackelberg均衡产量分别为 $\frac{a-2c_1+c_2}{2}$ 和 $\frac{a+2c_1-3c_2}{2}$ ；Stackelberg均衡利润分别为 $\frac{(a-2c_1+c_2)^2}{8} -K_1$ 和  $\frac{(a+2c_1-3c_2)^2}{16} -K_2$ 。对于企业 $2$，如果生产的固定成本 $K_2$ 过大，比如 $K_2&gt; \frac{(a+2c_1-3c_2)^2}{16}$ ，那么企业 $2$ 生产就会亏本。因此，企业 $2$ 就不会生产。当企业 $2$ 不生产时，如果企业 $1$ 按前  $\frac{a-2c_1+c_2}{2}$生产，则其均衡利润为 $\frac{(a-c_1)^2+(c_2-c_2)^2}{4}-K_1$,。现在的问题是：</p>
<blockquote>
<p> 企业 $2$ 由于生产的固定成本过高而不生产，企业 $1$ 是否可以将自己视为市场上唯一的生产者即<font color=yellow>垄断者</font>进行决策呢?</p>
</blockquote>
<p>如果企业 $1$ 进行垄断决策，则选择垄断产量 $\frac{a-c_1}{2}$ ,但是企业 $1$ 是否可以获得垄断利润 $\frac{a-c_1}{4}-K_1$ 呢？</p>
<p>企业 $1$ 是否能够得到垄断利润，还取决于企业 $2$ 如何反应! 当企业 $1$ 选择垄断产量 $\frac{a-c_1}{2}$ 时，如果企业 $2$ 决定生产，则会根据反应函数</p>
<script type="math/tex; mode=display">
q_2(q_1)=\frac{1}{2}(a-c_2-q_1)</script><p>选择产量  $\frac{a+c_1-2c_2}{4}$ ，从而得到利润 $\frac{(a+c_1-2c_2)^2}{16}$ 如果 $c_2&gt;c_1$ ,，则此时企业 $2$ 的利润就会大于前面计算出来的均衡利润  $\frac{(a+2c_1-3c_2)^2}{16} -K_2$ 。同时，如果 $\frac{(a+c_1-2c_2)^2}{16} -K_2&gt;0$ ，那么企业 $2$ 就会选择生产，并生产出  $\frac{a+c_1-2c_2}{4}$ 的产品。<br>当企业 $1$ 选择垄断产量 $\frac{a-c_1}{2}$ 时，并导致企业 $2$ 生产 $\frac{a+c_1-2c_2}{4}$ 的时候，企业不仅得不到所谓的垄断利润 $\frac{a-c_1}{4}-K_1$ ，而且实际得到的利润垄断利润 $\frac{(a-c_1)(a-3c_1+2c_2)}{8}-K_1$ 小于前面计算出来的均衡利润  $\frac{(a-2c_1+c_2)^2}{8} -K_1$ 。</p>
<p>因此，即使企业  $2$ 因为固定成本过高而不生产，企业 $1$ 也不能将自己视为市场上唯一的生产者而进行垄断决策。这里，企业 $2$ 虽然不生产，但由于企业 $2$ 可以<strong>随时择机进入</strong>，致使企业 $1$ 不能独占市场，进行垄断生产。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>Stackelberg模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory-Solution to Mixed Strategy Nash Equilibrium Part 2</title>
    <url>/2024/09/30/Game%20Theory-Solution%20to%20Mixed%20Strategy%20Nash%20Equilibrium%20Part%202/</url>
    <content><![CDATA[<h1 id="规划法求解Nash均衡"><a href="#规划法求解Nash均衡" class="headerlink" title="规划法求解Nash均衡"></a>规划法求解Nash均衡</h1><h2 id="两人的情况"><a href="#两人的情况" class="headerlink" title="两人的情况"></a>两人的情况</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>所谓规划求解法，就是将求解博弈问题的混合战略Nash均，转换为一个规划问题进行求解。相对于支撑求解法，规划求解法对两人有限博弈问题的Nash均衡求解尤为有效。下面对规划求解法的基本原理和步骤进行介绍。</p>
<p>在一个两人有限战略式博弈中，设 $S<em>1={s_1^1,…,s_1^m},S_1={s_2^1,…,s_2^n}$ 。用矩阵 $\mathbf U_1=(a</em>{ij})<em>{m\times n}$ 表示参与人 $1$ 的支付，其中 $a$ 表示参与人 $1$ 在战略组合 $(s_1^i,s_2^j)$ 下的支付，即 $a</em>{ij}=u<em>1(s_1^i,s_2^j)$ ；用矩阵 $\mathbf U_2=(b</em>{ij})<em>{m\times n}$ 表示参与人 $2$ 的支付，其中 $b</em>{ij}$ 表示参与人 $2$ 在战略组合 $(s<em>1^i,s_2^j)$ 下的支付，即 $b</em>{ij}=u_2(s_1^i,s_2^j)$ 。设参与人 $1$ 和参与人 $2$ 的混合战略分别为 $\boldsymbol \sigma_1=(\sigma_1^1,\cdots,\sigma_1^m) $和$\boldsymbol \sigma_2=(\sigma_2^1,\cdots,\sigma_2^n) $,则 </p>
<script type="math/tex; mode=display">
v_1(\boldsymbol {\sigma_1,\sigma_1})=\boldsymbol {\sigma_1 U_1\sigma_2^T}\\
v_2(\boldsymbol {\sigma_1,\sigma_1})=\boldsymbol {\sigma_1 U_2\sigma_2^T}</script><p>一个两人有限战略式博弈的 Nash均衡可以通过求解以下规划问题得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\max &&z =\boldsymbol{\sigma_{1}U_{1}\sigma_{2}^{T}-v_{1}+\sigma_{1}U_{2}\sigma_{2}^{T}-v_{2}} \\
&\text{s.t.}&& \boldsymbol{U_{1}\sigma_{2}^{T}\leq\upsilon_{1} E_{m}^{T}}\\
&&&\left(\boldsymbol{\sigma}_{1}\boldsymbol{U}_{2}\right)^{\mathrm{T}}\leqslant\boldsymbol{\upsilon}_{2}\boldsymbol{E}_{n}^{\mathrm{T}} \\
&&&\boldsymbol {\sigma_{1}E_{m}^{\mathrm{T}}=\sigma_{2}E_{n}^{\mathrm{T}}}=1 \\
&&&\sigma_{1}^{i}\geqslant0,i=1,\cdots,m \\
&&&\sigma_{2}^{j}\geqslant0,j=1,\cdots,n
\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
\boldsymbol E_m=[1,\cdots ,1]_{1\times m}\\
\boldsymbol E_n=[1,\cdots ,1]_{1\times n}</script><p>$v_1、v_2$ 分别是参与人 $1$ 和参与人 $2$ 在Nash均衡下的期望支付。</p>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>$A(\sigma_2^A)$</th>
<th>$B(\sigma_2^B)$</th>
<th>$C(\sigma_2^C)$</th>
<th>$D(\sigma_2^D)$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$U(\sigma_1^U)$</td>
<td>$3,5$</td>
<td>$1,4$</td>
<td>$5,7$</td>
<td>$4,2$</td>
</tr>
<tr>
<td>$L(\sigma_1^L)$</td>
<td>$4,3$</td>
<td>$2,5$</td>
<td>$0,3$</td>
<td>$2,6$</td>
</tr>
</tbody>
</table>
</div>
<p>上述博弈问题中，</p>
<script type="math/tex; mode=display">
\boldsymbol U_1=
\begin{bmatrix}
3 & 1 &5 &4\\
4 &2 &0 &2
\end{bmatrix}
\qquad
\boldsymbol U_2=
\begin{bmatrix}
5 & 4 &7 &2\\
3 &5 &3 &6
\end{bmatrix}
\\
\boldsymbol \sigma_1=(\sigma_1^U,\sigma_1^L) \qquad \boldsymbol \sigma_2=(\sigma_2^A,\sigma_2^B,\sigma_2^C,\sigma_2^D)</script><p>设 $\boldsymbol {v_1、v_2}$ 分别是参与人 $1$ 和参与人 $2$ 在Nash均衡下的期望支付。</p>
<p>我们可以列出来以下方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max \quad z &=\begin{pmatrix}   \boldsymbol \sigma_{1}^{U} &  \boldsymbol \sigma_{1}^{L} \end{pmatrix}
\begin{bmatrix}
3 & 1 & 5 & 4 \\
4 & 2 & 0 & 2
\end{bmatrix}
\begin{pmatrix}  \boldsymbol \sigma_{2}^{A} \\ \boldsymbol \sigma_{2}^{B} \\ \boldsymbol \sigma_{2}^{C} \\ \boldsymbol \sigma_{2}^{D}\end{pmatrix}
- \boldsymbol v_1 \\
&\quad + \begin{pmatrix} \boldsymbol \sigma_{1}^{U} & \boldsymbol \sigma_{1}^{L} \end{pmatrix}
\begin{bmatrix}
5 & 4 & 7 & 2 \\
3 & 5 & 3 & 6
\end{bmatrix}
\begin{pmatrix}\boldsymbol { \boldsymbol \sigma_{2}^{A} \\ \boldsymbol \sigma_{2}^{B} \\ \boldsymbol \sigma_{2}^{C} \\ \boldsymbol \sigma_{2}^{D} }\end{pmatrix}
- \boldsymbol v_2 \\
\text{s.t.} \quad &
\begin{bmatrix}
3 & 1 & 5 & 4 \\
4 & 2 & 0 & 2
\end{bmatrix}
\begin{pmatrix} \boldsymbol\sigma_{2}^{A} \\ \boldsymbol \sigma_{2}^{B} \\ \boldsymbol \sigma_{2}^{C} \\ \boldsymbol \sigma_{2}^{D} \end{pmatrix}
\leqslant
\begin{pmatrix} \boldsymbol v_1 \\ \boldsymbol v_1 \end{pmatrix}, \\
&\left(\begin{pmatrix} \boldsymbol \sigma_{1}^{U} & \boldsymbol \sigma_{1}^{L} \end{pmatrix}
\begin{bmatrix}
5 & 4 & 7 & 2 \\
3 & 5 & 3 & 6
\end{bmatrix}\right)^T
\leqslant
\begin{pmatrix} \boldsymbol v_1 \\ \boldsymbol v_2 \\ \boldsymbol v_3 \\ \boldsymbol v_4 \end{pmatrix}, \\
&\boldsymbol {\sigma_{1}^{U} + \sigma_{1}^{L}} = 1, \\
&\boldsymbol {\sigma_{2}^{A} + \sigma_{2}^{B} + \sigma_{2}^{C} + \sigma_{2}^{D}} = 1, \\
&\boldsymbol \sigma_{1}^{U} \geq 0, \ \boldsymbol \sigma_{1}^{L} \geq 0, \\
&\boldsymbol \sigma_{2}^{A} \geq 0, \ \boldsymbol \sigma_{2}^{B} \geq 0, \ \boldsymbol \sigma_{2}^{C} \geq 0, \ \boldsymbol \sigma_{2}^{D} \geq 0.
\end{aligned}
$$ {&}

求解上述规划问题，可以得到三个Nash均衡，即一个纯战略Nash均衡和两个混合战略Nash均衡:</script><p>(U,C)\<br>\left(<br>\left(\frac{1}{3},\frac{2}{3}\right),<br>\left(0,\frac{2}{3},0,\frac{1}{3}\right)<br>\right)\<br>\left(<br>\left(\frac{2}{5},\frac{3}{5}\right),<br>\left(0,\frac{5}{6},\frac{1}{6},0\right)<br>\right)</p>
<script type="math/tex; mode=display">



## 多人博弈情况

利用规划问题求解Nash均衡的思路，还可以推广到有限 $n$ 人的战略式博弈 $G=<\Gamma;S_1,\cdots,S_n;u_1,\cdots,u_n>$ ,对 $\forall i \in \Gamma$ ,设$S_{i}=\left\{s_{i}^{1},\cdots,s_{i}^{K_{i}}\right\},\sigma_{i}=\left(\sigma_{i}^{1},\cdots,\sigma_{i}^{K_{i}}\right)$,求解下列规划问题即可得到博弈问题的解。</script><p>\begin{aligned}<br>&amp;\max z = &amp;&amp; \sum<em>{i=1}^{n}\left(v</em>{i}\left(\boldsymbol \sigma<em>{i},\boldsymbol \sigma</em>{-i}\right) - \boldsymbol v<em>{i}\right) \<br>&amp;\text{s.t.} &amp;&amp; v</em>{i}\left(s<em>{i}^{j},\boldsymbol \sigma</em>{-i}\right) \leqslant \boldsymbol v<em>{i}, &amp;&amp; \forall i \in \Gamma, \forall s</em>{i}^{j} \in S<em>{i}, \<br>&amp;&amp;&amp; \sum</em>{j} \boldsymbol \sigma<em>{i}^{j} = 1, &amp;&amp; \forall i \in \Gamma, \<br>&amp;&amp;&amp; \boldsymbol \sigma</em>{i}^{j} \geqslant 0, &amp;&amp; \forall i \in \Gamma, \forall j \in \left{1,\cdots,K_{i}\right}.<br>\end{aligned}</p>
<script type="math/tex; mode=display">
其中， $\boldsymbol v_i(i=1,\cdots,n)$ 为参与人 $i$ 在Nash均衡下的期望支付。

# 零和博弈

所谓零和博弈，指的是在任何博弈情况下两个参与人的支付之和为 $0$ ,即对于 $\forall i \in \{1,2,\cdots,m\}$ 和 $\forall j \in \{1,2,\cdots,n\}$ ,有 $a_{ij}+b_{ij}=0$ ,我们设 $\boldsymbol {U_1=U}$ ,那么 $\boldsymbol {U_2=-U}$ ,所以给定了支付矩阵 $\boldsymbol U$,就给出来了所有参与人的支付。

## 极大极小化行为和鞍点(saddle point)

所谓极大极小化行为，指的是某一参与人在使自己的支付最小化的战略中，选择使得自己支付最大化的行为。

如下表所示:</script><p>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \min\<br>\ \ \ \ \ \ \ \ \ \ \ \ U = \begin{bmatrix}<br>1 &amp; 4 &amp; 2 \<br>4 &amp; 3 &amp; 2 \<br>1 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{array}{c}<br>1 \<br>(2) \<br>1<br>\end{array}<br>\<br>\max \ \ \ \ \ \ \ \ \ \ 4\quad 4\quad \left(2\right)</p>
<script type="math/tex; mode=display">
上述是参与人 $1$ 的支付矩阵。

对于参与人 $1$ ,当他分别选择战略 $a_1,a_2,a_3$的时候，参与人 $2$ 知道自己和参与人 $1$ 的支付之和为 $0$ ,所以参与人 $2$ **为了使自己的支付最大化，必然要使得参与人 $1$ 的支付最小化**，即参与人 $2$ 会在对应的行中，选择参与人 $1$ 获得支付最小的，即参与人 $2$ 会分别选择战略 $b_1,b_3,b_2$ ,这样可以使得参与人 $1$ 支付最小，自己的支付达到最大。此时参与人 $1$ 和参与人 $2$ 的支付分别为 $v_1=1,2,0,v_2=-1,-2,0$.

但是参与人 $1$ 也知道这一点，他知道上面的支付是自己最小的支付，所以他要**“瘸子里挑将军”，在所有不利于自己的战略中，挑选一个最有利的**。所以参与人 $1$ 一定会选择战略 $a_2$ ,这个时候，按照上述分析，参与人 $2$ 选择战略 $b_3$ 以使对方支付最小，自己支付最大。这样的话，参与人 $1$ 和参与人 $2$ 的支付分别为 $v_1=2,v_2=-2$ .

回顾上述思路，参与人 $1$ 先是站在参与人 $2$ 的角度考虑，挑选了一个对于参与人 $1$ 来说支付最小的，然后又从中挑选了一个支付最大的。因此这种行为被称为参与人$1$的“**极大极小化行为**”

对于参与人 $2$ 来说，也可以照此分析，由于上述矩阵是参与人 $1$ 的支付矩阵，因此参与人 $2$ 就表现出 “**极小极大化行为**”。

>**定义：鞍点**
>
>对于给定的零和博弈的支付矩阵 $U$ ,如果存在某个 $i^*$ 和 $j^*$ ,使得:
></script><blockquote>
<p>a<em>{i^<em>,j^</em>}=\max_i \min_j a</em>{ij}= \min<em>j\max_i a</em>{ij}</p>
<p>$$<br>那么称  $i^<em>$ 行 $j^</em>$ 列对应的点为 <strong>鞍点</strong>(saddle point)</p>
</blockquote>
<p>关于鞍点和Nash均衡，我们有如下定理:</p>
<blockquote>
<p><strong>定理：鞍点和Nash均衡</strong></p>
<p>在Nash均衡中，如果支付矩阵 $\boldsymbol U$ 存在鞍点，那么鞍点对应的战略组合即为Nash均衡。</p>
</blockquote>
<p>我们可以定义混合战略的鞍点</p>
<blockquote>
<p><strong>定义:混合战略意义下的鞍点</strong></p>
<p>对于给定的零和博弈的支付矩阵 $\boldsymbol U$ ，如果存在参与人 $1$ 的某个混合战略 $\boldsymbol \sigma_1^<em>=(\sigma_1^{1</em>},\cdots,\sigma_1^{m<em>})$和参与人 $2$ 的某个混合战略 $\boldsymbol \sigma_2^</em>=(\sigma_2^{1<em>},\cdots,\sigma_2^{n</em>})$ ,使得:</p>
<script type="math/tex; mode=display">
v_1(\boldsymbol \sigma_1^*,\boldsymbol \sigma_2^*)=\max_{\sigma_1} \min_{\sigma_2} v_1(\boldsymbol \sigma_1,\boldsymbol \sigma_2)=\min_{\sigma_2} \max_{\sigma_1}v_1(\boldsymbol \sigma_1,\boldsymbol \sigma_2)</script><p>那么称战略组合$(\boldsymbol \sigma_1^<em>,\boldsymbol \sigma_2^</em>)$ 为支付矩阵 $\boldsymbol U$ 的鞍点。</p>
</blockquote>
<h2 id="von-Neumann极大极小定理"><a href="#von-Neumann极大极小定理" class="headerlink" title="von Neumann极大极小定理"></a>von Neumann极大极小定理</h2><blockquote>
<p><strong>von Neumann极大极小定理</strong></p>
<p>在零和博弈中，对于给定的支付矩阵 $\boldsymbol U$ ，如果存在混合战略 $\boldsymbol \sigma_1^<em>=(\sigma_1^{1</em>},\cdots,\sigma_1^{m<em>})$ 和 $\boldsymbol \sigma_2^</em>=(\sigma_2^{1<em>},\cdots,\sigma_2^{n</em>})$以及一个常数 $v$ ,使得</p>
<script type="math/tex; mode=display">
\forall j,\qquad \sum\limits _{i=1}^m a_{ij}\boldsymbol \sigma_1^{i*}\geq v\\
\forall i,\qquad \sum\limits _{j=1}^n a_{ij}\boldsymbol \sigma_2^{j*}\leq v</script><p>那么称战略组合 $(\boldsymbol \sigma_1^<em>,\boldsymbol \sigma_2^</em>)$ 为博弈的Nash均衡，其中 $v$ 为参与人 $1$ 在均衡中所得到的期望支付，亦称该博弈的值。</p>
</blockquote>
<h2 id="零和博弈问题转化为对偶的规划问题"><a href="#零和博弈问题转化为对偶的规划问题" class="headerlink" title="零和博弈问题转化为对偶的规划问题"></a>零和博弈问题转化为对偶的规划问题</h2><p>对于给定的零和博弈问题，如果<strong>博弈的值 $v&gt;0$</strong> ，那么博弈的 Nash均衡为下列对偶问题的解:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min \sum_{i=1}^{m} p_{i} \\
&\text{s.t.} \quad \sum_{i=1}^{m} a_{ij} p_{i} \geq 1 \quad (j = 1, \cdots, n), \\
&\quad \quad \ p_{i} \geq 0 \quad (i = 1, \cdots, m), \\
&\quad \text{和}\\
&\max \sum_{j=1}^{n} q_{j} \\
&\text{s.t.} \quad \sum_{j=1}^{n} a_{ij} q_{j} \leq 1 \quad (i = 1, \cdots, m), \\
&\quad \quad \ q_{j} \geq 0 \quad (j = 1, \cdots, n).
\end{aligned}</script><p>其中，Nash均衡支付为 $v=\frac{1}{\sum\limits<em>{i=1}^m p_i}=\frac{1}{\sum\limits</em>{j=1}^n q_j}$ ,Nash均衡战略 $\sigma_1^<em>=(vp_1,\cdots,vp_i,\cdots,vp_m),\sigma_2^</em>=(vq_1,\cdots,vq_j,\cdots,vq_n)$.</p>
<p>如果支付矩阵 $\boldsymbol U=(a<em>{ij})</em>{m\times n}$中每个元素都大于零，即 $a_{ij}&gt;0$ ,则博弈的值 $v&gt;0$ ;</p>
<p>由此，如果发现给定的支付矩阵 $\boldsymbol U$ 中存在小于 $0$ 的元素，那么可以把每个元素都加上一个常数，从而使得每个元素都大于 $0$ ,这样的话，可以保证博弈的值 $v&gt;0$ ,就可以应用上面的方法求解博弈问题了。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>给定博弈如下，求解Nash均衡</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>$L$</th>
<th>$M$</th>
<th>$N$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$U$</td>
<td>$2,-2$</td>
<td>$-2,2$</td>
<td>$1,-1$</td>
</tr>
<tr>
<td>$C$</td>
<td>$-1,1$</td>
<td>$1,-1$</td>
<td>$0,0$</td>
</tr>
<tr>
<td>$D$</td>
<td>$3,-3$</td>
<td>$0,0$</td>
<td>$2,2$</td>
</tr>
</tbody>
</table>
</div>
<p>解:</p>
<p>支付矩阵为:</p>
<script type="math/tex; mode=display">
\boldsymbol U=\begin{bmatrix}
2 &-2&1\\
-1 &1&0\\
3 &0&2
\end{bmatrix}</script><p>我们可以加上一个常数 $2$ ,得到下面的支付矩阵:</p>
<script type="math/tex; mode=display">
\boldsymbol U'=\begin{bmatrix}
4 &0&3\\
1 &3&2\\
5 &2&4
\end{bmatrix}</script><p>设参与人 $1$ 和参与人 $2$ 的混合战略分别是  $\sigma_1=(v’p_1,v’p_2,v’p_3),\sigma_2=(v’q_1,v’q_2,v’q_3)$, $v$ 为原博弈的值， $v’$ 为新博弈的值，且 $v’=v+2$ ,利用对偶线性规划方法求解新战略式博弈的Nash均衡，构造规划问题如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min \{p_1 + p_2 + p_3\} \\
&\text{s.t.} \quad 4p_1 + p_2 + 5p_3 \geq 1, \\
&\quad \quad \ 3p_2 + 2p_3 \geq 1, \\
&\quad \quad \ 3p_1 + 2p_2 + 4p_3 \geq 1, \\
&\quad \quad \ p_1 \geq 0, \ p_2 \geq 0, \ p_3 \geq 0,
\\[10pt]
&\max \{q_1 + q_2 + q_3\} \\
&\text{s.t.} \quad 4q_1 + 3q_3 \leq 1, \\
&\quad \quad \ q_1 + 3q_2 + 2q_3 \leq 1, \\
&\quad \quad \ 5q_1 + 2q_2 + 4q_3 \leq 1, \\
&\quad \quad \ q_1 \geq 0, \ q_2 \geq 0, \ q_3 \geq 0.
\end{aligned}</script><p>上述对偶问题的解是</p>
<script type="math/tex; mode=display">
(p_1,p_2,p_3)=(0,\frac{3}{13},\frac{2}{13})\\
(q_1,q_2,q_3)=(\frac{1}{13},\frac{4}{13},0)\\
v'=\frac{13}{5}\\</script><p>因此，所求的混合战略Nash均衡为:</p>
<script type="math/tex; mode=display">
\boldsymbol {
(\sigma_1^*,\sigma_2^*)
}
=\left(
\left(0,\frac{3}{5},\frac{2}{5}\right),
\left(\frac{1}{5},\frac{4}{5},0\right)
\right)\\
v_1=v'-2=\frac{3}{5}\\
v_2=-v_1=-\frac{3}{5}</script>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>规划法</tag>
        <tag>零和博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory-Subgame perfect Nash Equlibrium</title>
    <url>/2024/09/30/Game%20Theory-Subgame%20perfect%20Nash%20Equlibrium/</url>
    <content><![CDATA[<p>Selten在1965年提出了“子博弈精炼 Nash均衡”(Subgame perfect Nash Equlibrium)的概念，不仅在一定程度上解决了Nash均衡的不足，而且对与完全信息的动态博弈适用。</p>
<h1 id="子博弈的概念"><a href="#子博弈的概念" class="headerlink" title="子博弈的概念"></a>子博弈的概念</h1><p>所谓子博弈，就是原博弈的一部分，它始于元博弈中一个位于单结信息集中的决策结 $x$ ,并由决策结 $x$ 及其后续结共同组成。子博弈可以作为一个独立的博弈进行分析，并且和原博弈有相同的结构。</p>
<p>子博弈和原博弈必须有相同的信息结构，如果选取子博弈的过程中破坏了博弈的结构，比如把后续结点中原有的虚线破坏掉（即原博弈中的后续节点是在一个信息集中，但是子博弈中不是一个信息集），那么不构成子博弈。</p>
<p>原博弈也是一个特殊的子博弈。</p>
<h1 id="子博弈精炼-Nash均衡定义"><a href="#子博弈精炼-Nash均衡定义" class="headerlink" title="子博弈精炼 Nash均衡定义"></a>子博弈精炼 Nash均衡定义</h1><p>扩展式博弈的战略组合  $s^<em> = { s_1^</em>, s_2^<em>, \cdots, s_n^</em> }$ 是一个子博弈精炼 Nash均衡，当且仅当满足以下条件：</p>
<ul>
<li>它是原博弈的Nash均衡；</li>
<li>它在每一个子博弈上给出（或构成）Nash均衡。</li>
</ul>
<p>上述定义表明，一个战略组合式子博弈精炼 Nash均衡当且仅当它对所有的子博弈（包括原博弈）构成一个Nash均衡，同时也意味着，<strong>原博弈的Nash均衡，不一定是子博弈精炼Nash均衡</strong>，除非它还对所有子博弈构成Nash均衡。</p>
<p>在完全信息动态博弈中，将子博弈精炼Nash均衡作为Nash均衡的解。</p>
<h1 id="Kuhn定理"><a href="#Kuhn定理" class="headerlink" title="Kuhn定理"></a>Kuhn定理</h1><p>每个有限的扩展式博弈都存在子博弈精炼i </p>
<p>Nash均衡。</p>
<p>所谓有限的扩展式博弈，指的是参与人人数和参与人行时的行动空间都有限的扩展式博弈。</p>
<h1 id="逆向归纳法"><a href="#逆向归纳法" class="headerlink" title="逆向归纳法"></a>逆向归纳法</h1><img src="/2024/09/30/Game%20Theory-Subgame%20perfect%20Nash%20Equlibrium/4cdddc6af27b0bd2192caac1b095749.jpg" class="" alt="4cdddc6af27b0bd2192caac1b095749">
<img src="/2024/09/30/Game%20Theory-Subgame%20perfect%20Nash%20Equlibrium/e21268384ec1797d4bbadf54c32db7c.jpg" class="" alt="e21268384ec1797d4bbadf54c32db7c">
<p>4</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>子博弈精炼Nash均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory-Finitely repeated games</title>
    <url>/2024/11/04/Game-Theory-Finitely-repeated-games/</url>
    <content><![CDATA[<ul>
<li><p>sticky是<code>sticky</code> 值越大，顶置的文章越靠前</p>
</li>
<li><p>thumbnail: “IMAGE_LINK”</p>
<p>redefine对首页文章添加缩略图</p>
</li>
<li><p>摘要</p>
<p>excerpt: “这是文章摘要 This is the excerpt of the post”或者直接设置为false</p>
</li>
<li><p>massage: 文章的密码的提示，但是似乎没有什么用，总是显示Hey,password is required here.</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Git learning</title>
    <url>/2024/08/09/Git-learning/</url>
    <content><![CDATA[<blockquote>
<p>参考链接:</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247493200&amp;idx=2&amp;sn=6a69bf9e575a77edca3c15e70d7e0a34&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247493200&amp;idx=2&amp;sn=6a69bf9e575a77edca3c15e70d7e0a34&amp;scene=21#wechat_redirect</a></p>
</blockquote>
<h1 id="极简版"><a href="#极简版" class="headerlink" title="极简版"></a>极简版</h1><h2 id="设置本地Git走代理"><a href="#设置本地Git走代理" class="headerlink" title="设置本地Git走代理"></a>设置本地Git走代理</h2><p>在Git bash中输入下列命令（Clash默认端口是7890）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//设置全局代理</span><br><span class="line">//http</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line">//https</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br><span class="line"> </span><br><span class="line">// socks</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:7891</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:7891</span><br><span class="line"> </span><br><span class="line">//只对github.com使用代理，其他仓库不走代理</span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:7891</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:7891</span><br><span class="line">//取消github代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.https://github.com.proxy</span><br><span class="line"> </span><br><span class="line">//取消全局代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<h2 id="拉取远程仓库"><a href="#拉取远程仓库" class="headerlink" title="拉取远程仓库"></a>拉取远程仓库</h2><p>新建一个文件夹，用于存储仓库，用下列命令拉取远程仓库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://你的仓库名称</span><br></pre></td></tr></table></figure>
<p>拉取之后，本地会出现一个文件夹，即远程的仓库。</p>
<h2 id="做修改"><a href="#做修改" class="headerlink" title="做修改"></a>做修改</h2><p>在本地做修改。</p>
<p>首先，用下列命令进入仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 你的仓库名称</span><br></pre></td></tr></table></figure>
<p>然后初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>接下来就可以修改本地仓库了。</p>
<h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><h3 id="提交修改到暂存区"><a href="#提交修改到暂存区" class="headerlink" title="提交修改到暂存区"></a>提交修改到暂存区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提交修改单个文件</span><br><span class="line">git add &quot;你的文件名&quot;  </span><br><span class="line"># 提交所有修改到暂存区</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h3 id="提交修改到版本库"><a href="#提交修改到版本库" class="headerlink" title="提交修改到版本库"></a>提交修改到版本库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit &quot;你的提交信息&quot;</span><br></pre></td></tr></table></figure>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p><code>origin</code> 是 Git 中远程仓库的默认名称。通常，当你克隆一个远程仓库时，Git 会自动将该远程仓库命名为 <code>origin</code>。</p>
<p>可以下列命令查看当前仓库名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是<strong>推送修改到远程仓库</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h1 id="Git的结构"><a href="#Git的结构" class="headerlink" title="Git的结构"></a>Git的结构</h1><p>Git是一个分布式版本控制系统，它的主要结构包括工作区（Working Directory）、暂存区（Staging Area，也称为 Index 或 Cache）和版本库（Repository）。</p>
<h3 id="1-工作区（Working-Directory）"><a href="#1-工作区（Working-Directory）" class="headerlink" title="1. 工作区（Working Directory）"></a>1. 工作区（Working Directory）</h3><p>这是你在本地计算机上实际操作的文件目录。当你克隆一个Git仓库时，Git会将版本库的内容提取到工作区。你在这里进行代码的编辑、删除、创建等操作。</p>
<h3 id="2-暂存区（Staging-Area-或-Index）"><a href="#2-暂存区（Staging-Area-或-Index）" class="headerlink" title="2. 暂存区（Staging Area 或 Index）"></a>2. 暂存区（Staging Area 或 Index）</h3><p>暂存区是一个中间层，它保存你希望在下一次提交（commit）时记录的文件快照。你可以通过 <code>git add</code> 命令将工作区的更改放入暂存区，准备提交到版本库。暂存区帮助你组织和选择哪些更改将包含在下一个提交中。</p>
<h3 id="3-版本库（Repository）"><a href="#3-版本库（Repository）" class="headerlink" title="3. 版本库（Repository）"></a>3. 版本库（Repository）</h3><p>版本库存储项目的所有历史记录，包括所有提交的快照、分支和标签等。版本库通常分为两部分：</p>
<ul>
<li><strong>本地版本库</strong>：在本地计算机上，包含 <code>HEAD</code> 指针（指向当前分支的最新提交）和 <code>.git</code> 目录，<code>.git</code> 目录中保存了所有的版本信息和配置文件。</li>
<li><strong>远程版本库</strong>：例如在GitHub、GitLab、Bitbucket等平台上的仓库，允许多个开发者协作。</li>
</ul>
<h3 id="Git结构图示"><a href="#Git结构图示" class="headerlink" title="Git结构图示"></a>Git结构图示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|    工作区 (Working Directory)  |</span><br><span class="line">|  (文件系统中的实际文件)           |</span><br><span class="line">|     - file1.txt         |</span><br><span class="line">|     - file2.txt         |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           | git add</span><br><span class="line">           v</span><br><span class="line">+---------------------+</span><br><span class="line">|    暂存区 (Staging Area)       |</span><br><span class="line">|  (索引文件)                  |</span><br><span class="line">|     - file1.txt (新版本)   |</span><br><span class="line">|     - file2.txt (修改版)   |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           | git commit</span><br><span class="line">           v</span><br><span class="line">+---------------------+</span><br><span class="line">|    本地版本库 (Local Repository) |</span><br><span class="line">|  (提交历史)                  |</span><br><span class="line">|     - commit1: (file1.txt, file2.txt) |</span><br><span class="line">|     - commit2: (file1.txt, file2.txt) |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           | git push</span><br><span class="line">           v</span><br><span class="line">+---------------------+</span><br><span class="line">|    远程版本库 (Remote Repository)  |</span><br><span class="line">|  (远程服务器上的仓库)          |</span><br><span class="line">|     - commit1: (file1.txt, file2.txt) |</span><br><span class="line">|     - commit2: (file1.txt, file2.txt) |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<h3 id="工作流概述"><a href="#工作流概述" class="headerlink" title="工作流概述"></a>工作流概述</h3><ol>
<li><strong>编辑文件</strong>：在工作区中修改文件。</li>
<li><strong>暂存更改</strong>：使用 <code>git add</code> 将更改添加到暂存区。</li>
<li><strong>提交更改</strong>：使用 <code>git commit</code> 将暂存区的更改提交到本地版本库。</li>
<li><strong>推送更改</strong>：使用 <code>git push</code> 将本地版本库的更改推送到远程版本库，以便其他人可以看到你的更改。</li>
</ol>
<p>通过这个结构，Git允许开发者在本地工作、版本控制和协作开发，能够高效地管理项目的演变过程。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="创建工作版本库并且进入目录"><a href="#创建工作版本库并且进入目录" class="headerlink" title="创建工作版本库并且进入目录"></a>创建工作版本库并且进入目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="将工作区的更改放入暂存区"><a href="#将工作区的更改放入暂存区" class="headerlink" title="将工作区的更改放入暂存区"></a>将工作区的更改放入暂存区</h2><h3 id="将某一文件的更改放入暂存区"><a href="#将某一文件的更改放入暂存区" class="headerlink" title="将某一文件的更改放入暂存区"></a>将某一文件的更改放入暂存区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [file]</span><br></pre></td></tr></table></figure>
<h3 id="将所有文件的更改放入暂存区"><a href="#将所有文件的更改放入暂存区" class="headerlink" title="将所有文件的更改放入暂存区"></a>将所有文件的更改放入暂存区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h2 id="将暂存区的更改提交到本地版本库"><a href="#将暂存区的更改提交到本地版本库" class="headerlink" title="将暂存区的更改提交到本地版本库"></a>将暂存区的更改提交到本地版本库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;[message]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="提交所有已跟踪的文件的更改到本地仓库（不需要先使用-git-add）"><a href="#提交所有已跟踪的文件的更改到本地仓库（不需要先使用-git-add）" class="headerlink" title="提交所有已跟踪的文件的更改到本地仓库（不需要先使用 git add）"></a>提交所有已跟踪的文件的更改到本地仓库（不需要先使用 <code>git add</code>）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a -m &quot;[message]&quot;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="查看提交的历史记录"><a href="#查看提交的历史记录" class="headerlink" title="查看提交的历史记录"></a>查看提交的历史记录</h2><p>显示从最近到最远的提交日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>还可以用一下命令查看更为简洁的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>一大串数字如<code>commit 39822faceaf91b7c546d8e886ddb55d114e5d777</code>是提交的版本号(commit id)。</p>
<h2 id="回退到上一版本"><a href="#回退到上一版本" class="headerlink" title="回退到上一版本"></a>回退到上一版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>—hard/—soft/—mixed</p>
<ul>
<li><p>hard回退到上个版本的已提交状态</p>
</li>
<li><p>soft回退到上个版本的未提交状态</p>
</li>
<li><p>mixed回退到上个版本的已添加但是未提交状态</p>
</li>
</ul>
</li>
<li><p>HEAD^</p>
<ul>
<li><p>HEAD当前版本的指针，表示当前版本</p>
</li>
<li><p>HEAD^上一个版本</p>
</li>
<li><p>HEAD^^上上一个版本</p>
</li>
<li><p>HEAD~100上100个版本</p>
</li>
<li><p>39822fa 也可以直接写你的版本号，没必要写全，前几个就行</p>
</li>
</ul>
</li>
</ul>
<h2 id="回到过去后查看未来的版本ID"><a href="#回到过去后查看未来的版本ID" class="headerlink" title="回到过去后查看未来的版本ID"></a>回到过去后查看未来的版本ID</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h2 id="显示当前工作目录和暂存区的状态"><a href="#显示当前工作目录和暂存区的状态" class="headerlink" title="显示当前工作目录和暂存区的状态"></a>显示当前工作目录和暂存区的状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h2 id="查看工作区和暂存区之间的差异"><a href="#查看工作区和暂存区之间的差异" class="headerlink" title="查看工作区和暂存区之间的差异"></a>查看工作区和暂存区之间的差异</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<h2 id="查看暂存区和最后提交之间的差异"><a href="#查看暂存区和最后提交之间的差异" class="headerlink" title="查看暂存区和最后提交之间的差异"></a>查看暂存区和最后提交之间的差异</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --stage</span><br></pre></td></tr></table></figure>
<h2 id="撤销某一文件的保存-适用于git-add之前"><a href="#撤销某一文件的保存-适用于git-add之前" class="headerlink" title="撤销某一文件的保存(适用于git add之前)"></a>撤销某一文件的保存(适用于git add之前)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- &quot;Yourfilename.txt&quot;</span><br></pre></td></tr></table></figure>
<p>两种可能</p>
<p>一种是<code>Yourfilename.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>Yourfilename.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>git checkout是用版本库的状态替换为</p>
<h2 id="撤销某一文件的保存-适用于git-commit之前"><a href="#撤销某一文件的保存-适用于git-commit之前" class="headerlink" title="撤销某一文件的保存(适用于git commit之前)"></a>撤销某一文件的保存(适用于git commit之前)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git restore --staged &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>从暂存区中移除指定的文件，但保留工作目录中的更改,，如果想撤销工作目录的修改，需要再用一次<code>git checkout -- &lt;&quot;filename&quot;&gt;</code></p>
<h2 id="删除工作目录和暂存区的文件"><a href="#删除工作目录和暂存区的文件" class="headerlink" title="删除工作目录和暂存区的文件"></a>删除工作目录和暂存区的文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>如果用的是<code>shell</code>命令<code>rm</code>，只会删除本地的工作目录里面的文件，并不会影响到暂存区的文件。</p>
<p>使用<code>git rm</code>删除文件后，这个删除操作会被记录为一个更改，需要通过<code>git commit</code>命令提交。这意味着删除操作会被版本控制跟踪。使用<code>git rm &lt;filename&gt;</code>意味着还需要之后还要再用<code>git commit</code>命令（如果想彻底删除）</p>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础知识</title>
    <url>/2024/08/09/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Java的编译器对字符串做了特殊照顾，可以使用<code>+</code>连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。</p>
<p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串.</p>
<p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）了。</p>
<p>Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Game theory-Strategic game</title>
    <url>/2024/09/11/Game%20theory-Strategic%20game/</url>
    <content><![CDATA[<h1 id="一些基本概念及其表示"><a href="#一些基本概念及其表示" class="headerlink" title="一些基本概念及其表示"></a>一些基本概念及其表示</h1><h2 id="参与人（player）"><a href="#参与人（player）" class="headerlink" title="参与人（player）"></a>参与人（player）</h2><p>博弈中选择行动以最大化自己效用的决策主体（个人、团体、国家、企业、组织）</p>
<p>用$i=1,2,\cdots,n$ 表示$n$人博弈中的参与人，用$\Gamma={1,2,\cdots,n}$表示所有参与人的主体。</p>
<h2 id="行动（action）"><a href="#行动（action）" class="headerlink" title="行动（action）"></a>行动（action）</h2><p>参与人在博弈的某个时点的决策变量。</p>
<p>用$a_i$表示参与人$i$的行动，用$A_i={a_i}$表示参与人i所有行动的集合。</p>
<p>$n$个参与人行动的有序集$a={a_1,a_2,\cdots,a_n}$表示$n$个参与人的<strong>行动组合</strong>或者<strong>行动断面</strong>（action profile）</p>
<p>用$A$表示所有行动组合的集合。如$A={(a,a),(a,b),(b,a),(b,b)}$</p>
<h2 id="战略（strategy）"><a href="#战略（strategy）" class="headerlink" title="战略（strategy）"></a>战略（strategy）</h2><p>战略是参与人的行动规则，即参与人采取什么样的行动，这有一套规则，称之为战略，比如“投资”和“不投资”是两个行动，但是“对方不投资我就投资”和“对方投资我就不投资”这是两个战略。</p>
<p>在$n$人博弈中，用$s_i$表示参与人$i$的战略，用$X_i$表示参与人$i$在决策过程中可能面临的所有决策情形地集合，称之为观测集。</p>
<p>严格地说，战略$s_i$是从观测集$X_i$到行动集$A_i$的<strong>映射关系</strong>：</p>
<script type="math/tex; mode=display">
s_i:X_i \rarr A_i</script><p>用$S_i={s_i}$表示参与人$i$所有战略的集合。</p>
<p>在$n$人博弈中，用$s={s_1,s_2,\cdots,s_n}$表示$n$个参与人的战略组合。</p>
<p>用$S={s}$表示所有行动组合的集合。</p>
<h2 id="支付（payoff"><a href="#支付（payoff" class="headerlink" title="支付（payoff)"></a>支付（payoff)</h2><p>支付指参与人在博弈中的所得。</p>
<p>用$u_i$表示参与人$i$的支付，参与人i的支付不仅与自己的战略有关，也和其他参与人的战略有关，所以：</p>
<script type="math/tex; mode=display">
u_i=u_i(s_1,s_2,\cdots,s_n)</script><p>为了描述方便，用$s<em>{-i}={s_1,\cdots,s</em>{i-1},s<em>{i+1},\cdots,s_n}$表示除了参与人$i$之外的其他参与人的<strong>战略组合</strong>，则$s={s_1,\cdots,s_n}={s_i,s</em>{-i}}$,故：</p>
<script type="math/tex; mode=display">
u_i=u_i(s_i,s_{-i})</script><p>用<strong>支付组合</strong>$u=(u_1,u_2,\cdots,u_n)$表示参与人在特定博弈情形下所得到的支付。</p>
<h2 id="信息（information）"><a href="#信息（information）" class="headerlink" title="信息（information）"></a>信息（information）</h2><p>信息是参与人所具有的有关博弈的所有知识。</p>
<p>一般假设<strong>博弈问题的结构</strong>（或者是对博弈问题的描述）和<strong>参与人完全理性</strong>是<strong>共同知识</strong>。</p>
<p>因此，在传统的博弈论中，博弈的主体都是同质的。</p>
<h1 id="战略式博弈的定义"><a href="#战略式博弈的定义" class="headerlink" title="战略式博弈的定义"></a>战略式博弈的定义</h1><h2 id="形式Ⅰ"><a href="#形式Ⅰ" class="headerlink" title="形式Ⅰ"></a>形式Ⅰ</h2><p>三要素：</p>
<ul>
<li><p>参与人集合$\Gamma={1，2，\cdots，n}$;</p>
</li>
<li><p>每位参与人非空的战略集$S_i$，即$\forall i \in \Gamma,\exists S_i \neq \varnothing $;</p>
</li>
<li>每位参与人定义在所有战略组合$\prod \limits_{i=1}^n={s=(s_1,\cdots,s_i,\cdots,s_n)}$上的偏好关系$\succ_i$</li>
</ul>
<h2 id="形式Ⅱ"><a href="#形式Ⅱ" class="headerlink" title="形式Ⅱ"></a>形式Ⅱ</h2><p>三要素：</p>
<ul>
<li><p>参与人集合$\Gamma={1，2，\cdots，n}$;</p>
</li>
<li><p>每位参与人非空的战略集$S_i$，即$\forall i \in \Gamma,\exists S_i \neq \varnothing $;</p>
</li>
<li>每位参与人定义在所有战略组合$\prod  \limits_{i=1}^n={s=(s_1,\cdots,s_i,\cdots,s_n)}$上的效用函数$u_i=u_i(s_1,\cdots,s_i,\cdots,s_n)$</li>
</ul>
<p>对于上述博弈，如果$\left| \Gamma \right|&lt;\infty$ 且$\forall i\in \Gamma$    ，$\left| S_i \right|&lt;\infty $，称该博弈问题为<strong>有限博弈</strong>(finite game)，反u之为无限博弈。</p>
<p>一般用三元组$G=&lt;\Gamma ;\left( S_i \right) ;\left( \succ _i \right) &gt;$或者$G=&lt;\Gamma ;\left( S_i \right) ;\left( u_i \right) &gt;$来表示战略式博弈。</p>
<h1 id="占优行为"><a href="#占优行为" class="headerlink" title="占优行为"></a>占优行为</h1><h2 id="占优战略"><a href="#占优战略" class="headerlink" title="占优战略"></a>占优战略</h2><p>在$n$人博弈中，如果对于所有其他的参与人的选择$ s<em>{-i}$，$s_i^<em>$都是参与人$i$的最优选择，即对于$\forall s_i \in S_i(s_i \neq s_i^</em>)$，$\forall s</em>{-i}\in \prod \limits_{j=1,j \neq i}^n S_j$，有：</p>
<script type="math/tex; mode=display">
u_i(s_i^*,s_{-i})>u_i(s_i,s_{-i})</script><p>则称$s_i^<em>$为参与人$i$的<em>*占优战略</em></em>。</p>
<h2 id="劣战略"><a href="#劣战略" class="headerlink" title="劣战略"></a>劣战略</h2><p>在$n$人博弈中，如果对于参与人$i$，存在战略$s’<em>i，s’’_i \in S_i$，对$\forall s</em>{-i}\in\prod \limits_{j=1,j \neq i}^n S_j$有：</p>
<script type="math/tex; mode=display">
u_i(s_i'',s_{-i})>u_i(s_i',s_{-i})</script><p>则称战略$s_i’$为参与人$i$的<strong>劣战略(严格劣战略)</strong>，或者说战略$s_i’’$相对$s_i’$占优。</p>
<h2 id="弱劣战略"><a href="#弱劣战略" class="headerlink" title="弱劣战略"></a>弱劣战略</h2><p>在$n$人博弈中，如果对于参与人$i$，存在战略$s’<em>i，s’’_i \in S_i$，对$\forall s</em>{-i}\in\prod \limits_{j=1,j \neq i}^n S_j$有：</p>
<script type="math/tex; mode=display">
u_i(s_i'',s_{-i})\ge u_i(s_i',s_{-i})</script><p>且$\exists s’<em>{-i}\in\prod \limits</em>{j=1,j \neq i}^n S_j$，使得:</p>
<script type="math/tex; mode=display">
u_i(s_i'',s'_{-i})\ge u_i(s_i',s'_{-i})</script><p>则称战略$s_i’$为参与人$i$的<strong>弱劣战略</strong>，或者说战略$s_i’’$相对$s_i’$<strong>弱占优</strong>。</p>
<p>为了表述方便，将弱劣战略和严格劣战略统称为劣战略。</p>
<blockquote>
<p>在重复剔除劣战略求解博弈问题的过程中，如果每次可以提出的劣战略（包含弱劣战略和严格劣战略）不止一个，那么<strong>各个劣战略剔除的顺序不同可能会影响最终得到的博弈结果，除非每次剔除的都是严格劣战略。</strong></p>
</blockquote>
<p>如下图所示情形:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>b1</strong></th>
<th style="text-align:center"><strong>b2</strong></th>
<th style="text-align:center"><strong>b3</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>a1</strong></td>
<td style="text-align:center">3,3</td>
<td style="text-align:center">3,1</td>
<td style="text-align:center">1,2</td>
</tr>
<tr>
<td style="text-align:center"><strong>a2</strong></td>
<td style="text-align:center">1,1</td>
<td style="text-align:center">2,0</td>
<td style="text-align:center">2,0</td>
</tr>
<tr>
<td style="text-align:center"><strong>a3</strong></td>
<td style="text-align:center">3,4</td>
<td style="text-align:center">1,3</td>
<td style="text-align:center">3,2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="重复剔除劣战略的方法"><a href="#重复剔除劣战略的方法" class="headerlink" title="重复剔除劣战略的方法"></a>重复剔除劣战略的方法</h2><p>画横线，就看左边的值</p>
<p>画竖线，就看右边的值</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>Nash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2024/10/22/LeetCode/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>链接：</p>
<p><a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两数相加，需要返回头指针，所以就两个指针<code>head</code>和<code>tail</code>来进行表示，最后返回<code>head</code>，计算过程用 <code>tail</code>作用。</p>
<p>因为两个链表可能长度不一样，所以<code>while</code>的条件很重要。然后就是对于其中某个指针有没有值的判断，用三目运算符。接着就是对于头指针是否为空，因为初始化的时候头指针和尾指针都是空指针。然后是原来两个指针的更新逻辑。以及进位逻辑。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化结果链表的头节点和尾节点</span></span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;      <span class="comment">// 初始化头节点</span></span><br><span class="line">        ListNode* tail = <span class="literal">nullptr</span>;      <span class="comment">// 初始化尾节点</span></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;                 <span class="comment">// 进位符号</span></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;             <span class="comment">// 当其中一个链表指针不为空</span></span><br><span class="line">            <span class="type">int</span> n1 = l1 ? l1-&gt;val : <span class="number">0</span>; <span class="comment">// 创建一个新的值存储l1</span></span><br><span class="line">            <span class="type">int</span> n2 = l2 ? l2-&gt;val : <span class="number">0</span>; <span class="comment">// 创建一个新的值存储l2</span></span><br><span class="line">            <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            <span class="comment">// 如果头指针为空</span></span><br><span class="line">            <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果头节点不为空</span></span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>; <span class="comment">// 进位处理</span></span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123; <span class="comment">//如果两个数分别是99和88，那么head和tail同时移动到末尾的时候。还需要创建一个新的节点</span></span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/submissions/575965011/">https://leetcode.cn/problems/reverse-linked-list/submissions/575965011/</a></p>
<p>代码如下：</p>
<p>用三个指针实现，curr,next和prev，curr指向当前，next指向下一个，prev指向curr的前一个，（一开始curr指向传入的头指针）然后prev和next是空指针，更新逻辑是：</p>
<ul>
<li>保存当前节点curr的下一个指针为next</li>
<li>令当前节点curr指向前一个节点prev</li>
<li><strong>先</strong>将prev更新为curr</li>
<li><strong>后</strong>将当前指针更新为之前保存的next</li>
<li>直到当前指针为空，因为在循环中更新了，所以返回prev</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* next=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* current=head;</span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next=current-&gt;next;<span class="comment">//保存下一个节点的指针</span></span><br><span class="line">            current-&gt;next=prev;<span class="comment">//将当前节点指向之前的指针</span></span><br><span class="line">            prev=current;<span class="comment">//将上一个节点的指针向前移动</span></span><br><span class="line">            current=next;<span class="comment">//将当前节点的指针向前移动（和上一句的顺序有关系）            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;<span class="comment">//最后返回的是有数值的指针。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++中一个结构体的对象可以用.或者-&gt;访问，但是一个结构体指针的对象只能用-&gt;，不能用.</p>
<p>C++中类的结尾要有分号</p>
</blockquote>
<h1 id="删除单向链表的倒数第n个节点"><a href="#删除单向链表的倒数第n个节点" class="headerlink" title="删除单向链表的倒数第n个节点"></a>删除单向链表的倒数第n个节点</h1><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>思路是用两个距离为n的指针，每次同时更新这两个指针，当后面的指针为空的时候前面的指针刚好到达倒数第n个。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        ListNode* tail=head; <span class="comment">//尾节点</span></span><br><span class="line">        ListNode* front=head;<span class="comment">//待删除结点的前一个节点，初始化为头结点</span></span><br><span class="line">        ListNode* del=head;<span class="comment">//待删除的节点</span></span><br><span class="line">        <span class="comment">//将尾节点向后移动N个，保持尾节点和待删除的节点相差n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将双指针都向后更新，直到尾指针为空</span></span><br><span class="line">        <span class="keyword">while</span>(tail!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">            front=del; <span class="comment">//更新待删除节点的前一个指针指向待删除节点</span></span><br><span class="line">            del=del-&gt;next;<span class="comment">//待删除节点向后更新</span></span><br><span class="line">            tail=tail-&gt;next;<span class="comment">//将尾节点向后更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单独判断只有一个结点的情况，此时上述while循环并未进入，</span></span><br><span class="line">        <span class="keyword">if</span>(del==head)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next; <span class="comment">//返回头节点的下一个，即空指针。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是只有一个节点的情况，就可以将节点删除。</span></span><br><span class="line">        front-&gt;next=del-&gt;next;  <span class="comment">//删除节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="合并两个升序链表"><a href="#合并两个升序链表" class="headerlink" title="合并两个升序链表"></a>合并两个升序链表</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个升序链表</a></p>
<h2 id="解法一：遍历"><a href="#解法一：遍历" class="headerlink" title="解法一：遍历"></a>解法一：遍历</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode*p1=list1;<span class="comment">//第一个链表</span></span><br><span class="line">        ListNode*p2=list2;<span class="comment">//第二个链表</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//哑结点,方便找回结果链表的初始节点</span></span><br><span class="line">        ListNode* result=&amp;dummy;<span class="comment">//结果的链表的指针,初始化为哑结点的地址</span></span><br><span class="line">        <span class="keyword">while</span>(p1&amp;&amp;p2)&#123;  <span class="comment">//循环条件：两个链表都不为空</span></span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val&lt;p2-&gt;val)&#123;  <span class="comment">//如果链表1的值大于链表2的值，将其值加入结果链表中</span></span><br><span class="line">                result-&gt;next=p1;  <span class="comment">//，将其值加入结果链表中</span></span><br><span class="line">                p1=p1-&gt;next;  <span class="comment">//将添加过一个值的那个链表的指针向后移动</span></span><br><span class="line">                result=result-&gt;next;  <span class="comment">//将结果链表的指针向后移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result-&gt;next=p2;</span><br><span class="line"></span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">                result=result-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后跳出来循环的时候，由于链表不等长，可能一个链表不为空，此时判断一下，直接把那个链表给接起来。</span></span><br><span class="line">        p1==<span class="literal">nullptr</span>?result-&gt;next=p2:result-&gt;next=p1; </span><br><span class="line">        <span class="keyword">return</span> dummy.next;  <span class="comment">//返回哑结点的next指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1)&#123; <span class="comment">//边界判断，如果指针为空，返回另一个指针</span></span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!list2)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123; <span class="comment">//比较值，如果其中一个链表的值比较小</span></span><br><span class="line">            list1-&gt;next=<span class="built_in">mergeTwoLists</span>(list2,list1-&gt;next); <span class="comment">//就将这个链表的指针接到计算后的结果，即看后面的结果，如果遇到空指针，再向后回溯</span></span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next=<span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>思路：用一个哑结点 <code>dummyHead</code>放在头节点前，再用一个指针 <code>tmp</code>去遍历，从<code>dummyHead</code>开始，终止条件是指针<code>tmp</code>指向空或者下一个指针指向空。</p>
<p>在循环的内部，可以初始化两个节点，指向<code>tmp</code>的下一个和下下一个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//哑结点，初始化为0</span></span><br><span class="line">        dummy-&gt;next=head; <span class="comment">//让哑结点指向头节点</span></span><br><span class="line"></span><br><span class="line">        ListNode*tmp=dummy;<span class="comment">//定义一个指针，用来遍历</span></span><br><span class="line">        <span class="keyword">while</span>((tmp-&gt;next!=<span class="literal">nullptr</span>)&amp;&amp;(tmp-&gt;next-&gt;next!=<span class="literal">nullptr</span>))&#123;</span><br><span class="line">            ListNode*back=tmp-&gt;next;</span><br><span class="line">            ListNode*forward=back-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            back-&gt;next=forward-&gt;next; <span class="comment">//先把back指向forward的下一个，防止丢失</span></span><br><span class="line">            forward-&gt;next=back; <span class="comment">//再把forward指向back</span></span><br><span class="line">            tmp-&gt;next = forward;<span class="comment">//这一步很关键，是为了链表整体还是连接起来，作用是把交换后的节点对连接到前面的链表部分 ，如果没有这一步，  链表就会乱</span></span><br><span class="line">            tmp=back;<span class="comment">//此时back已经通过交换移动到了前面，所以tmp更新为back</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;<span class="comment">//返回原来头指针的下一个</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>为了得到交换后的链表，我们可以认为，递归的条件是递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个或者没有节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123;  <span class="comment">//注意此处的两个条件的顺序，一旦变为head-&gt;next==nullptr||head==nullptr会报错</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则</span></span><br><span class="line">        <span class="comment">//交换头节点和头节点的下一个节点</span></span><br><span class="line">        ListNode* newhead=head-&gt;next;</span><br><span class="line">        head-&gt;next=<span class="built_in">swapPairs</span>(newhead-&gt;next); <span class="comment">//此时用以下递归</span></span><br><span class="line">        newhead-&gt;next=head;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="求数组中和为目标值的下标"><a href="#求数组中和为目标值的下标" class="headerlink" title="求数组中和为目标值的下标"></a>求数组中和为目标值的下标</h1><h2 id="方法一（暴力遍历）"><a href="#方法一（暴力遍历）" class="headerlink" title="方法一（暴力遍历）"></a>方法一（暴力遍历）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123; <span class="comment">//函数返回值是int类型的数组</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>(); <span class="comment">//获取数组长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;; <span class="comment">//返回一个由i和j组成的数组</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">//如果没有找到，返回空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="方法二（哈希表）"><a href="#方法二（哈希表）" class="headerlink" title="方法二（哈希表）"></a>方法二（哈希表）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123; <span class="comment">//函数返回值是int类型的数组</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;myHash; <span class="comment">//建立一个键值类型都是整型的hash表，命名为myHash.其中键为数组的值，值为数组的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;  <span class="comment">//遍历这个数组</span></span><br><span class="line">			<span class="keyword">auto</span> it=myHash.<span class="built_in">find</span>(target-nums[i]);<span class="comment">//查找第i个元素所对应的“另一半”是否在myHash的值中</span></span><br><span class="line">            <span class="keyword">if</span>(it!=myHash.<span class="built_in">end</span>())&#123; <span class="comment">//如果第i个元素的“另一半”在myHash的值中，证明匹配成功，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> &#123;i,it-&gt;second&#125;; <span class="comment">//返回下标i和hash表元素it的值（it-&gt;first是键）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果第i个元素的“另一半”不在myHash的值中，证明未匹配成功，将当前元素加入Hash表中</span></span><br><span class="line">            myHash[nums[i]]=i;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">//如果没有找到，返回空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h1><p>[<a href="https://leetcode.cn/problems/search-insert-position/description/">https://leetcode.cn/problems/search-insert-position/description/</a>]</p>
<p>二分法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)  <span class="comment">//</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 未找到时返回插入位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></h1></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hexo插入视频和音乐</title>
    <url>/2024/07/23/Hexo%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<p>我彩用的是githubpages+hexo+butterfly配置的个人博客。</p>
<p>视频默认是B站视频</p>
<h1 id="方法一-直接粘贴链接"><a href="#方法一-直接粘贴链接" class="headerlink" title="方法一(直接粘贴链接)"></a>方法一(直接粘贴链接)</h1><p>不推荐这个方法，因为调整大小比较麻烦。</p>
<p>以bilibili为例，可以在分享的选项中找到”嵌入代码”:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=291342710&amp;bvid=BV1ff4y1t7mH&amp;cid=357644741&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<p>实现效果如下:</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=291342710&bvid=BV1ff4y1t7mH&cid=357644741&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<p>可以发现，非常的小，集中在左下角，不能全屏而且不美观。</p>
<p>解决方案如下:<br>参考文章:<a href="https://blog.laoda.de/archives/bilibili-video-adaptation-hexo-butterfly">Hexo-Butterfly主题解决B站视频自适应的方法</a></p>
<h2 id="css文件配置"><a href="#css文件配置" class="headerlink" title="css文件配置"></a>css文件配置</h2><p>首先在主题文件夹下source/css里面创建一个bilibili.css的文件，里面写入下面的内容:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/<span class="emphasis">*哔哩哔哩视频适配*</span>/</span><br><span class="line">.bilibili&#123;</span><br><span class="line"><span class="code">    position: relative;</span></span><br><span class="line"><span class="code">    width: 100%;</span></span><br><span class="line"><span class="code">    height: 0;              /*高度设置这里无效，设置为0，用padding撑开div*/</span></span><br><span class="line"><span class="code">    padding-bottom: 75%;    /*68%到80%都可以*/</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">.bilibili iframe &#123;</span></span><br><span class="line"><span class="code">    position: absolute;</span></span><br><span class="line"><span class="code">    width: 100%;</span></span><br><span class="line"><span class="code">    height: 100%;</span></span><br><span class="line"><span class="code">    left: 0;</span></span><br><span class="line"><span class="code">    top: 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="主题文件配置"><a href="#主题文件配置" class="headerlink" title="主题文件配置"></a>主题文件配置</h2><p>然后去主题的配置文件，在inject的head一栏里面增加下面的内容:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/bilibili.css&quot;&gt;</span>  </span><br></pre></td></tr></table></figure>
<h2 id="在链接前面添加class信息"><a href="#在链接前面添加class信息" class="headerlink" title="在链接前面添加class信息"></a>在链接前面添加class信息</h2><p>配置好以后，我们在粘贴B站”内嵌链接”的时候，注意在首尾添加以下信息:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=291342710&amp;bvid=BV1ff4y1t7mH&amp;cid=357644741&amp;p=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<div class="bilibili">
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=291342710&bvid=BV1ff4y1t7mH&cid=357644741&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>

<h1 id="方法二-下载插件-（！目前该方法已失效）。"><a href="#方法二-下载插件-（！目前该方法已失效）。" class="headerlink" title="方法二(下载插件)（！目前该方法已失效）。"></a>方法二(下载插件)（<strong>！目前该方法已失效</strong>）。</h1><h2 id="安装dplayer插件"><a href="#安装dplayer插件" class="headerlink" title="安装dplayer插件"></a>安装dplayer插件</h2><p>在博客的根目录(即含有themes、sources、scaffolds等文件夹的文件夹)，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-dplayer</span><br></pre></td></tr></table></figure>
<p>（<strong>非必须</strong>）接着确保hexo根目录下的配置文件_config.yaml的设置如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这个设置会使得在创建文章的时候生成一个同名的文件夹，方便插入视频和图片。</p>
<h2 id="获取url地址"><a href="#获取url地址" class="headerlink" title="获取url地址"></a>获取url地址</h2><p>获取B站视频的url地址:</p>
<ul>
<li><p><a href="https://zhouql.vip/bilibili/">B站视频下载工具 | 极简纯净</a></p>
</li>
<li><p><a href="https://xbeibeix.com/api/bilibili/">贝贝</a> (推荐）</p>
</li>
<li><p><a href="https://www.bilibili.com/read/cv27735928/">整理了几个视频解析工具</a></p>
</li>
</ul>
<p>如果需要插入<strong>视频</strong>，可以在markdown中写入下列代码:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">dplayer</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;url=https://upos-sz-mirrorali.bilivideo.com/upgcxcode/56/23/1525102356/1525102356-1-192.mp4?e=ig8euxZM2rNcNbRVhwdVhwdlhWdVhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&amp;uipk=5&amp;nbs=1&amp;deadline=1722402726&amp;gen=playurlv2&amp;os=alibv&amp;oi=2018263300&amp;trid=7fe85ac497254790a0875259aaea6509T&amp;mid=3546668876172024&amp;platform=html5&amp;og=hw&amp;upsig=3cdce61ad891ff715b19098f3b04cee0&amp;uparams=e,uipk,nbs,deadline,gen,os,oi,trid,mid,platform,og&amp;bvc=vod&amp;nettype=0&amp;bw=57581&amp;orderid=0,1&amp;buvid=&amp;build=0&amp;mobi_app=&amp;f=T_0_0&amp;logo=80000000#这个是真实的解析地址，而非浏览器复制的地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">pic=https://s2.loli.net/2024/07/08/MS8NfnWJoVabvDx.jpg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;loop=no&quot;</span> <span class="comment">#不循环播放</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;autoplay=false&quot;</span> <span class="comment">#不自动播放</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;volume=0.5&quot;</span> <span class="comment">#音量默认为0.5</span></span><br><span class="line"></span><br><span class="line"><span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"volume":0.5,"video":{"url":"https://upos-sz-mirrorali.bilivideo.com/upgcxcode/56/23/1525102356/1525102356-1-192.mp4?e=ig8euxZM2rNcNbRVhwdVhwdlhWdVhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1722402726&gen=playurlv2&os=alibv&oi=2018263300&trid=7fe85ac497254790a0875259aaea6509T&mid=3546668876172024&platform=html5&og=hw&upsig=3cdce61ad891ff715b19098f3b04cee0&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,mid,platform,og&bvc=vod&nettype=0&bw=57581&orderid=0,1&buvid=&build=0&mobi_app=&f=T_0_0&logo=80000000#这个是真实的解析地址，而非浏览器复制的地址\n\npic=https://s2.loli.net/2024/07/08/MS8NfnWJoVabvDx.jpg\""}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<p><strong>目前该方法已失效</strong>。<br>dplayer还有其他的参数如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>视频链接地址</td>
<td>必须</td>
</tr>
<tr>
<td>pic</td>
<td>封面图</td>
<td></td>
</tr>
<tr>
<td>loop</td>
<td>循环播放</td>
<td></td>
</tr>
<tr>
<td>autoplay</td>
<td>自动播放</td>
<td></td>
</tr>
<tr>
<td>screenshot</td>
<td>允许截图</td>
<td></td>
</tr>
<tr>
<td>volume</td>
<td>初始音量</td>
<td>可能是从0到1</td>
</tr>
<tr>
<td>lang</td>
<td>语言</td>
<td>zh-cn就行</td>
</tr>
<tr>
<td>mutex</td>
<td>播放互斥</td>
<td></td>
</tr>
<tr>
<td>theme</td>
<td>主题</td>
</tr>
</tbody>
</table>
</div>
<h1 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h1><p>如果需要插入<strong>音频</strong>，可以在网易云音乐的网页端找到链接。具体操作如下:</p>
<ol>
<li><p>在网页版（music.163.com）进入单曲、歌单、专辑、电台节目页面后，点击 <em>“生成外链播放器”</em> 链接。</p>
</li>
<li><p>歌单和专辑外链播放器可以选择大中小三种尺寸，单曲和电台节目可以选择中小两种尺寸。你可以选择最适合你网站设计的尺寸。</p>
</li>
<li><p>还可以选择是否要自动播放，打上勾后，别人访问网站时播放器会自动开始播放。</p>
</li>
<li><p>最后将播放器的代码黏贴到你的网站上，大功告成！</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;iframe</span> <span class="string">frameborder=&quot;no&quot;</span> <span class="string">border=&quot;0&quot;</span> <span class="string">marginwidth=&quot;0&quot;</span> <span class="string">marginheight=&quot;0&quot;</span> <span class="string">width=420</span> <span class="string">height=86</span> <span class="string">src=&quot;//music.163.com/outchain/player?type=2&amp;id=28188434&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28188434&auto=0&height=66"></iframe>

<p>参考教程</p>
<ul>
<li><p><a href="https://rimbaud-lee.github.io/2021/08/25/blog_deploy_1/">记一次异常艰难的博客部署（一）—— Hexo博客插入视频的若干种方法 | 邓小闲的小楼</a></p>
</li>
<li><p><a href="_https://www.bilibili.com/read/cv27735928/">解析工具</a></p>
</li>
<li><p><a href="https://github.com/MoePlayer/hexo-tag-dplayer#usage">hexo-tag-dplayer源地址</a></p>
</li>
<li><p><a href="https://teamssix.com/190614-111">https://teamssix.com/190614-111</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>视频</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Computations-Cholesky Factorization</title>
    <url>/2024/10/07/Matrix%20Computations-Cholesky%20Factorization/</url>
    <content><![CDATA[<h1 id="对称正定矩阵的若干性质"><a href="#对称正定矩阵的若干性质" class="headerlink" title="对称正定矩阵的若干性质"></a>对称正定矩阵的若干性质</h1><p>有下列性质:</p>
<ul>
<li>$A$ 是正定矩阵 $\Leftrightarrow$ $A$ 的所有顺序主子式均为正</li>
<li>$A$ 是正定矩阵 $\Leftrightarrow$ $A$ 的所有主子式均为正</li>
<li>$A$ 是正定矩阵 $\Leftrightarrow$ $A$ 的所有特征值均为正</li>
<li>$A$ 是正定矩阵 $\Leftrightarrow$ 存在主对角元素全为正的三角矩阵 $R$ ,使得$A=RR^T$ </li>
<li>$A$ 是正定矩阵 $\Leftrightarrow$ 存在可逆矩阵 $C$ ,使得$A=C^TC$ </li>
<li>$A$ 是正定矩阵 $\Leftrightarrow$ $A$ 的所有主对角元素都是正数，且 $\max<em>\limits{i\neq j}{|a</em>{ij}|}&lt;\max<em>\limits i {a</em>{ii}}$ </li>
</ul>
<h1 id="Cholesky-分解定理"><a href="#Cholesky-分解定理" class="headerlink" title="Cholesky 分解定理"></a>Cholesky 分解定理</h1><blockquote>
<p>若矩阵 $A\in \mathbb{R}^{n\times n}$ 对称正定，则存在一个对角元均为正数的下三角矩阵  $L\in \mathbb{R}^{n\times n}$ ,使得</p>
<script type="math/tex; mode=display">
A=LL^T</script><p>上式被称为Cholesky分解，其中 $L$ 被称为 $A$ 的 Cholesky因子。</p>
</blockquote>
<h1 id="平方根法分解"><a href="#平方根法分解" class="headerlink" title="平方根法分解"></a>平方根法分解</h1><img src="/2024/10/07/Matrix%20Computations-Cholesky%20Factorization/image-20241007234334465-1728354401358-2.png" class="" alt="image-20241007234334465">
<p>来自Chat GPT的四阶矩阵示例:</p>
<blockquote>
<p>下面是一个四阶对称正定矩阵的Cholesky平方根法求解过程，目标是求解下三角矩阵 ($L$)，使得 $A = LL^T$。</p>
<h3 id="矩阵-A"><a href="#矩阵-A" class="headerlink" title="矩阵 (A)"></a>矩阵 (A)</h3><p>考虑以下矩阵：</p>
<script type="math/tex; mode=display">
A = \begin{pmatrix}
16 &  24 &  32 &  8 \\
24 &  64 &  80 & 16 \\
32 &  80 &  128 & 32 \\
8  &  16 &  32 &  16
\end{pmatrix}</script><h3 id="步骤-1：计算下三角矩阵-L"><a href="#步骤-1：计算下三角矩阵-L" class="headerlink" title="步骤 1：计算下三角矩阵 (L)"></a>步骤 1：计算下三角矩阵 (L)</h3><p>我们将下三角矩阵 (L) 表示为：</p>
<script type="math/tex; mode=display">
L = \begin{pmatrix}
l_{11} & 0 & 0 & 0 \\
l_{21} & l_{22} & 0 & 0 \\
l_{31} & l_{32} & l_{33} & 0 \\
l_{41} & l_{42} & l_{43} & l_{44}
\end{pmatrix}</script><h4 id="计算-L-的元素"><a href="#计算-L-的元素" class="headerlink" title="计算 (L) 的元素"></a>计算 (L) 的元素</h4><ol>
<li><p><strong>计算$l_{11}$</strong>：</p>
<script type="math/tex; mode=display">
l_{11} = \sqrt{A_{11}} = \sqrt{16} = 4</script></li>
<li><p><strong>计算 $l_{21}$</strong>：</p>
<script type="math/tex; mode=display">
l_{21} = \frac{A_{21}}{l_{11}} = \frac{24}{4} = 6</script></li>
<li><p><strong>计算 $l_{31}$</strong>：</p>
<script type="math/tex; mode=display">
l_{31} = \frac{A_{31}}{l_{11}} = \frac{32}{4} = 8</script></li>
<li><p><strong>计算 $l_{41}$</strong>：</p>
<script type="math/tex; mode=display">
l_{41} = \frac{A_{41}}{l_{11}} = \frac{8}{4} = 2</script></li>
<li><p><strong>计算 $l_{22}$</strong>：</p>
<script type="math/tex; mode=display">
l_{22} = \sqrt{A_{22} - l_{21}^2} = \sqrt{64 - 6^2} = \sqrt{64 - 36} = \sqrt{28} = 2\sqrt{7}</script></li>
<li><p><strong>计算 $l_{32}$</strong>：</p>
<script type="math/tex; mode=display">
l_{32} = \frac{A_{32} - l_{31}l_{21}}{l_{22}} = \frac{80 - 8 \cdot 6}{2\sqrt{7}} = \frac{80 - 48}{2\sqrt{7}} = \frac{32}{2\sqrt{7}} = \frac{16}{\sqrt{7}}</script></li>
<li><p><strong>计算 $l_{42}$</strong>：</p>
<script type="math/tex; mode=display">
l_{42} = \frac{A_{42} - l_{41}l_{21}}{l_{22}} = \frac{16 - 2 \cdot 6}{2\sqrt{7}} = \frac{16 - 12}{2\sqrt{7}} = \frac{4}{2\sqrt{7}} = \frac{2}{\sqrt{7}}</script></li>
<li><p><strong>计算 $l_{33}$</strong>：</p>
<script type="math/tex; mode=display">
l_{33} = \sqrt{A_{33} - l_{31}^2 - l_{32}^2} = \sqrt{128 - 8^2 - \left(\frac{16}{\sqrt{7}}\right)^2} = \sqrt{128 - 64 - \frac{256}{7}} = \sqrt{64 - \frac{256}{7}} = \sqrt{\frac{448 - 256}{7}} = \sqrt{\frac{192}{7}} = \frac{8\sqrt{3}}{\sqrt{7}}</script></li>
<li><p><strong>计算 $l_{43}$</strong>：</p>
<script type="math/tex; mode=display">
l_{43} = \frac{A_{43} - l_{31}l_{41} - l_{32}l_{42}}{l_{33}} = \frac{32 - 8 \cdot 2 - \left(\frac{16}{\sqrt{7}}\right) \cdot \left(\frac{2}{\sqrt{7}}\right)}{l_{33}} = \frac{32 - 16 - \frac{32}{7}}{\frac{8\sqrt{3}}{\sqrt{7}}} = \frac{16 - \frac{32}{7}}{\frac{8\sqrt{3}}{\sqrt{7}}} = \frac{\frac{112 - 32}{7}}{\frac{8\sqrt{3}}{\sqrt{7}}} = \frac{\frac{80}{7}}{\frac{8\sqrt{3}}{\sqrt{7}}} = \frac{10}{\sqrt{3}}</script></li>
<li><p><strong>计算 $l_{44}$</strong>：</p>
<script type="math/tex; mode=display">
l_{44} = \sqrt{A_{44} - l_{41}^2 - l_{42}^2 - l_{43}^2} = \sqrt{16 - 2^2 - \left(\frac{2}{\sqrt{7}}\right)^2 - \left(\frac{10}{\sqrt{3}}\right)^2}
= \sqrt{16 - 4 - \frac{4}{7} - \frac{100}{3}} = \sqrt{12 - \frac{4}{7} - \frac{100}{3}}</script><p>需要统一分母，计算后可以得到最终结果。</p>
</li>
</ol>
<h3 id="最终的下三角矩阵-L"><a href="#最终的下三角矩阵-L" class="headerlink" title="最终的下三角矩阵 (L)"></a>最终的下三角矩阵 (L)</h3><p>经过上述计算，得到了矩阵 $L$的元素。最终矩阵 $L$ 形状为：</p>
<script type="math/tex; mode=display">
L = \begin{pmatrix}
4 & 0 & 0 & 0 \\
6 & 2\sqrt{7} & 0 & 0 \\
8 & \frac{16}{\sqrt{7}} & \frac{8\sqrt{3}}{\sqrt{7}} & 0 \\
2 & \frac{2}{\sqrt{7}} & \frac{10}{\sqrt{3}} & l_{44}
\end{pmatrix}</script></blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>Cholesky</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Computation-Conjugate gradient method</title>
    <url>/2024/11/04/Matrix%20Computation-Conjugate%20gradient%20method/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>对于系数矩阵<strong>对称正定</strong>的实线性方程组$Ax=b$,其解存在唯一，记为$x<em>*.$由于$A$对称正定，令$|x|_A=\sqrt{x^\mathrm{T}Ax}$  ,则求$x</em>*$等价于求如下问题</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol{x}\in\mathbb{R}^n}\|\boldsymbol{x}-\boldsymbol{x}_*\|_A^2</script><p>的最优解.由于$Ax_*=b$,则</p>
<script type="math/tex; mode=display">
\|x-x_*\|_A^2=(x-x_*)^\mathrm{T}A(x-x_*)=x^\mathrm{T}Ax-2b^\mathrm{T}x+x_*^\mathrm{T}Ax_*.</script><p>记 $\varphi(x)=x^\mathrm{T}Ax-2b^\mathrm{T}x$<br>故求$x_*$的问题等价于求如下最优化问题</p>
<script type="math/tex; mode=display">
\tag{4.2}
\min_{x\in\mathbb{R}^n}\varphi(\boldsymbol{x}):=\boldsymbol{x}^\mathrm{T}\boldsymbol{A}\boldsymbol{x}-2\boldsymbol{b}^\mathrm{T}\boldsymbol{x}</script><p>的最优解。</p>
<p>考虑利用迭代法求解最优化问题(4.2).首先任意给定初始向量$x_0$,沿下降方向$d_0$ ,经过步长$\alpha_0$得到一个新的向量$x_1=x_0+\alpha_0d_0$,使得</p>
<script type="math/tex; mode=display">
\varphi(\boldsymbol{x}_1)=\varphi(\boldsymbol{x}_0+\alpha_0\boldsymbol{d}_0)=\min_{\alpha\in\mathbb{R}}\varphi(\boldsymbol{x}_0+\alpha\boldsymbol{d}_0).</script><p>然后从$x_1$出发，再沿下降方向$d_1$前进步长$\alpha_1$,使得</p>
<script type="math/tex; mode=display">\varphi\left(x_{2}\right)=\varphi\left(x_{1}+\alpha_{1}d_{1}\right)=\min\limits_{\alpha\in\mathbb{R}}\varphi\left(x_{1}+\alpha d_{1}\right).</script><p>此过程一直进行下去，直到求得问题(4.2)的最优解，不同的下降方向和步长确定策略可以给出来不同的迭代法.</p>
<h1 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h1><h2 id="原理-amp-算法"><a href="#原理-amp-算法" class="headerlink" title="原理&amp;算法"></a>原理&amp;算法</h2><p>首先考虑步长的选择策略.明显地，若下降方向$d_k$给定，则$\alpha_k$的选取应使得函数</p>
<script type="math/tex; mode=display">
\begin{aligned}\varphi\left(x\right)&=\quad\varphi\left(\boldsymbol{x}_{k}+\alpha\boldsymbol{d}_{k}\right)\\&=\quad(\boldsymbol{x}_{k}+\alpha\boldsymbol{d}_{k})^{\mathrm{T}}\boldsymbol{A}(\boldsymbol{x}_{k}+\alpha\boldsymbol{d}_{k})-2\boldsymbol{b}^{\mathrm{T}}(\boldsymbol{x}_{k}+\alpha\boldsymbol{d}_{k})\\&=\quad\alpha^{2}\boldsymbol{d}_{k}^{\mathrm{T}}\boldsymbol{A}\boldsymbol{d}_{k}-2\alpha(\boldsymbol{b}-\boldsymbol{A}\boldsymbol{x}_{k})^{\mathrm{T}}\boldsymbol{d}_{k}+\varphi(\boldsymbol{x}_{k})\end{aligned}</script><p>在$x=x_k+\alpha_kd_k$处取得最小值.记$r_k=b-Ax_k$,对上式关于$\alpha$求导得</p>
<script type="math/tex; mode=display">
2\alpha\boldsymbol{p}_k^\mathrm{T}\boldsymbol{A}\boldsymbol{p}_k-2\boldsymbol{r}_k^\mathrm{T}\boldsymbol{p}_k=0.</script><p>由此确定的$\alpha$即为所求的步长</p>
<script type="math/tex; mode=display">
\alpha_{k}=\frac{r_{k}^{\mathrm{T}}d_{k}}{d_{k}^{\mathrm{T}}Ad_{k}}.</script><p>其次考虑下降方向的选择策略。由微积分知识可知，若在局部要求下降最快，则下<br>降方向应为负梯度方向，故我们可以选择在$x_k$点的负梯度方向</p>
<script type="math/tex; mode=display">
d_{k}=r_{k}=b-Ax_{k}</script><p>作为下降方向，此时，</p>
<script type="math/tex; mode=display">
\varphi\left(x_{k+1}\right)-\varphi\left(x_{k}\right)=\alpha_{k}^{2}d_{k}^{T}Ad_{k}-2\alpha_{k}r_{k}^{T}d_{k}=-\frac{\left(r_{k}^{T}d_{k}\right)^{2}}{d_{k}^{T}Ad_{k}}.</script><p>由$A$的正定性知，只要$r<em>k\neq0$,有$r_k^\mathrm{T}d_k=r_k^\mathrm{T}r_k\neq0$,则$\varphi(x</em>{k+1})&lt;\varphi(x_k).$<br>此算法简单有效并且算法过程中主要是矩阵和向量的乘积及向量的内积运算，故<br>可以充分利用问题的稀疏性.综合上面的讨论可以得到以下算法流程：</p>
<blockquote>
<p><strong>算法 4.1 对称正定线性方程组的最速下降法</strong></p>
<p><font color=green >输入</font>:矩阵$A$、向量$b$、初始向量$x_0$ 及精度$\varepsilon$</p>
<p><font color=green >输出</font>:向量$x$ </p>
<p>计算残量$r_0=b-Ax_0;$</p>
<p>$k=0$</p>
<p>while $|r_k|\geqslant\varepsilon$ do</p>
<p>​    $k=k+1;$</p>
<p>​    计算步长$\alpha<em>k-1=r</em>{k-1}^{\mathrm{T}}r<em>{k-1}/\left(r</em>{k-1}^{\mathrm{T}}Ar_{k-1}\right);$ </p>
<p>​    计算更新后的向量$x<em>k=x</em>{k-1}+\alpha<em>{k-1}r</em>{k-1};$ </p>
<p>​    计算当前残量$r_k=b-Ax_k;$</p>
<p>end while</p>
</blockquote>
<h2 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h2><h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><blockquote>
<p><strong>定理1.18</strong></p>
<p>若 $A$ 为Hermit矩阵(共轭转置等于本身),则</p>
<script type="math/tex; mode=display">
\rho(A)=\|A\|_2=\max_{\lambda \in \lambda(A)}|\lambda|</script></blockquote>
<h3 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h3><blockquote>
<p><strong>定理4.1</strong></p>
<p>设$A$为对称正定矩阵，$p(x)$为实系数多项式，则对于任意向量$x$,有</p>
<script type="math/tex; mode=display">
\|p(\boldsymbol{A})\boldsymbol{x}\|_A\leqslant\max_{\lambda\in\lambda(\boldsymbol{A})}|p(\lambda)|\|\boldsymbol{x}\|_A.</script><p><font color=blue>证明</font> :由$A$为对称正定矩阵，则有谱分解$A=Q\Lambda Q^\mathrm{T}$,其中$Q$为正交矩阵，$\Lambda$为对角元均为正的对角矩阵.定义$A^{\frac12}=Q\Lambda ^{\frac12}Q^{\mathrm{T}}$,故对任意的$x$有：$|x|_A=\sqrt{x^\mathrm{T}Ax}=$ $\sqrt{x^T\boldsymbol{A}^{\frac12}\boldsymbol{A}^{\frac12}\boldsymbol{x}}=|\boldsymbol{A}^{\frac12}\boldsymbol{x}|_2$(因为2-范数的定义就是各个元素平方然后求和开方,等价于和自己做点乘然后开方).</p>
<p>我们再考虑 $p(\boldsymbol{A})$ ,设$p(\boldsymbol{A})=p_0+p_1x+\cdots+p_nx^n$ 因此 $p(\boldsymbol{A})=p_0+p_1A+\cdots+p_nA^n$ ,我们将谱分解$A=Q\Lambda Q^\mathrm{T}$带入其中,由于 $Q$ 的正定性,可以得到 </p>
<script type="math/tex; mode=display">
\begin{align}
p(\boldsymbol{A})&=p_0+p_1A+\cdots+p_nA^n\\
&=p_0+p_1Q\Lambda Q^T+\cdots+p_nQ\Lambda ^nQ^T\\
&=\sum_{i=0}^n p_iQ\Lambda^iQ^T\\


A^{\frac{1}{2}}p(A)&=Q\Lambda^{\frac12}Q^{\mathrm{T}}\sum_{i=0}^np_i Q\Lambda^iQ^T\\
&=\sum_{i=0}^np_i Q\Lambda^{\frac12}Q^{\mathrm{T}} Q\Lambda^iQ^T\\
&=\sum_{i=0}^np_i Q\Lambda^{\frac12}(Q^{\mathrm{T}} Q)\Lambda^iQ^T\\
&=\sum_{i=0}^np_i Q\Lambda^{\frac12}\Lambda^iQ^T\\

p(A)A^{\frac{1}{2}}&=\sum_{i=0}^np_i Q\Lambda^iQ^T(Q\Lambda^{\frac12}Q^{\mathrm{T}})\\
&=\sum_{i=0}^np_i Q\Lambda^i(Q^TQ)\Lambda^{\frac12}Q^{\mathrm{T}}\\
&=\sum_{i=0}^np_i Q\Lambda^i\Lambda^{\frac12}Q^{\mathrm{T}}\\

\text{So,}\\
p(A)A^{\frac{1}{2}}&=A^{\frac{1}{2}}p(A)

\end{align}</script><p>所以:</p>
<script type="math/tex; mode=display">
\begin{aligned}\|p(\boldsymbol{A})\boldsymbol{x}\|_{\boldsymbol{A}}&=\quad\|\boldsymbol{A}^{\frac12}p(\boldsymbol{A})\boldsymbol{x}\|_2=\|p(\boldsymbol{A})\boldsymbol{A}^{\frac12}\boldsymbol{x}\|_2\\&\leqslant\quad\|p(\boldsymbol{A})\|_2\|\boldsymbol{A}^{\frac12}\boldsymbol{x}\|_2=\|p(\boldsymbol{A})\|_2\|\boldsymbol{x}\|_A\\&=\max_{\lambda\in\lambda(A)}|p(\lambda)|\|x\|_A.\end{aligned}</script></blockquote>
<h3 id="最速下降法的收敛性定理"><a href="#最速下降法的收敛性定理" class="headerlink" title="最速下降法的收敛性定理:"></a>最速下降法的收敛性定理:</h3><blockquote>
<p><strong>最速下降法的收敛性定理</strong></p>
<p>设系数矩阵 $A$ 的特征值为 $0&lt;\lambda<em>1\leq \lambda_2\cdots \lambda_n$ ,$ x</em>*$ 为方程 $Ax=b$ 的解,则最速下降法产生的迭代序列  ${x<em>k}</em>{k=0}^{\infty}$ 满足:</p>
<script type="math/tex; mode=display">
\|x_k-x_*\|_A\leqslant\left(\frac{\lambda_n-\lambda_1}{\lambda_1+\lambda_n}\right)^k\|x_0-x_*\|_A.</script></blockquote>
<h3 id="收敛速度"><a href="#收敛速度" class="headerlink" title="收敛速度"></a>收敛速度</h3><p>从任一向量出发,最速下降法生成的迭代向量都会收敛到问题的解,并且其收敛速度依赖于 $\frac{\lambda_n-\lambda_1}{\lambda_1+\lambda_n}$的大小,当 $\lambda_n \approx \lambda_1$ 的时候,收敛速度很快,但是当 $\lambda_n &gt;&gt;\lambda_1$ 的时候,收敛速度很慢.</p>
<h1 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>共轭梯度法是在 20 世纪 50 年代初期由 Hestenes 和 Stiefel 首先提出的，目前已成为求解大型稀疏线性方程组的一类重要算法.从最速下降法的讨论可知，每步选取最速下降方向并不是最合适的，应选择更加合理有效的下降方向，并且方向的选择不应带来太多的额外计算量.<br>首先考虑步长的选择策略.假设已得到了迭代向量$x_k$及下降方向$d_k$,则下一步在<br>直线$x_k+\alpha\boldsymbol{d}_k$上寻找极小点，与最速下降法的讨论类似，可得</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k+\alpha_k\boldsymbol{d}_k</script><p>其中</p>
<script type="math/tex; mode=display">
\tag{4.3}
\alpha_{k}=\frac{r_{k}^{T}d_{k}}{d_{k}^{T}Ad_{k}},r_{k}=b-Ax_{k}.</script><p>下面考虑如何选择迭代方向$d<em>k.$在初始步，可用信息少，此时选择负梯度方向$d_0=r_0=b-Ax_0$作为下降方向，在后续迭代步中，从式(4.3)可以看出，在下步步长的计算中$r_k$ 是必需的；而上步方向$d</em>{k-1}$ 是已知的，故在选取当前步的下降方向 $d<em>k$的时候可以充分利用 $r_k$ 以及 $d</em>{k-1}$ 的信息,这并未引入额外的计算量.</p>
<p>由于</p>
<script type="math/tex; mode=display">
\begin{aligned}d_{k-1}^\mathrm{T}r_{k}
&=\quad d_{k-1}^\mathrm{T}(b-A(x_{k-1}+\alpha_{k-1}d_{k-1}))\\
&=\quad d_{k-1}^\mathrm{T}(r_{k-1}-\alpha_{k-1}Ad_{k-1}))\\
&=\quad d_{k-1}^\mathrm{T}r_{k-1}-\alpha_{k-1}d_{k-1}^\mathrm{T}Ad_{k-1}\\
&=\quad d_{k-1}^\mathrm{T}r_{k-1}-\frac{r_{k-1}^{T}d_{k-1}}{d_{k-1}^{T}Ad_{k-1}}d_{k-1}^\mathrm{T}Ad_{k-1}\\
&=0,\end{aligned}</script><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>
<p>最后一个等号用到了(4.3)</p>
<p>这说明: <font color=red>上一步的下降方向和下一步的残差垂直</font>.</p>
<p>所以我们可以在过 $x<em>k$ 由$r_k$ 及$d</em>{k-1}$ 张成的平面</p>
<script type="math/tex; mode=display">
\{x=x_{k}+\xi r_{k}+\eta d_{k-1},\quad\xi,\eta\in\mathbb{R}\}</script><p>中寻找下一步迭代点,类似前述分析, $\eta$ 和 $\xi$必须满足:</p>
<script type="math/tex; mode=display">
\frac{\partial\varphi\left(\boldsymbol{x}_{k}+\xi\boldsymbol{r}_{k}+\eta\boldsymbol{d}_{k-1}\right)}{\partial\xi}=0,\quad\frac{\partial\varphi\left(\boldsymbol{x}_{k}+\xi\boldsymbol{r}_{k}+\eta\boldsymbol{d}_{k-1}\right)}{\partial\eta}=0.</script><p>计算并且整理可以得到</p>
<script type="math/tex; mode=display">
\tag{4.5}
\left\{\begin{array}{ll}
\xi \boldsymbol{r}_{k}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{r}_{k}+\eta \boldsymbol{r}_{k}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{d}_{k-1} & =\boldsymbol{r}_{k}^{\mathrm{T}} \boldsymbol{r}_{k} \\
\xi \boldsymbol{r}_{k}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{d}_{k-1}+\eta \boldsymbol{d}_{k-1}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{d}_{k-1} & =\boldsymbol{d}_{k-1}^{\mathrm{T}} \boldsymbol{r}_{k}
\end{array}\right.</script><p> 根据 $\boldsymbol{d}<em>{k-1}^{\mathrm{T}} \boldsymbol{r}</em>{k}=0$,可以得到第二个式子为 $0$.</p>
<p>若$ \boldsymbol{r}<em>{k}\neq 0$,我们观察 $\xi$ ,<font color=blue>如果 $\xi = 0$ </font>,那么为了使得第二个式子 $\xi \boldsymbol{r}</em>{k}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{d}<em>{k-1}+\eta \boldsymbol{d}</em>{k-1}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{d}<em>{k-1} =0$ 成立,由于 $A$ 是一个正定矩阵,$ \boldsymbol{r}</em>{k}\neq 0$,说明此时迭代没有终止,因此 $d<em>{k-1}\neq 0$ .所以 那么$\boldsymbol{d}</em>{k-1}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{d}_{k-1}&gt;0$ ,此时<font color=blue>立即得到 $\eta=0$ </font>,只有这样才可以使得这个式子成立.这个时候观察第一个式子,很显然,第一个式子不成立.</p>
<p>因此,<font color=blue>$\xi\neq 0$</font></p>
<p>上述仅仅是为了保证 $\xi$作为分母的时候不为 $0$ .</p>
<p>我们可以取下降方向如下:</p>
<script type="math/tex; mode=display">
\begin{align}
d_{k}&=r_{k}+\frac{\eta}{\xi}d_{k-1}\\
&=r_{k}+\beta_{k-1}d_{k-1}\\

\text{where}\\

\beta_{k-1}&=\frac{\eta}{\xi}\\
&=\frac{-d_{k-1}^\mathrm{T}Ar_{k}}{d_{k-1}^\mathrm{T}Ad_{k-1}}
\end{align}</script><p>其中,</p>
<script type="math/tex; mode=display">
\begin{align}
\beta_{k-1}&=\frac{\eta}{\xi}\\
&=\frac{-d_{k-1}^\mathrm{T}Ar_{k}}{d_{k-1}^\mathrm{T}Ad_{k-1}}
\end{align}</script><p>由此得到了下面的递推公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\alpha_{k}=d_{k}^{T}r_{k}/d_{k}^{T}Ad_{k}, \\
&x_{k+1}=x_{k}+\alpha_{k}d_{k} \\
&r_{k+1}=b-Ax_{k+1}, \\
&\beta_{k}=-d_{k}^{T}Ar_{k+1}/d_{k}^{T}Ad_{k}, \\
&d_{k+1}=r_{k+1}+\beta_kd_k\\
\text{where,}\\
&k=0,1,2,\cdots
\end{aligned}</script><p> 实际应用中，上述公式可进行进一步简化.对于每步残量 $r<em>{k+1}$,由于在计算 $\alpha_k$时$\boldsymbol{Ad}_k$ 已计算，故$\boldsymbol{r}</em>{k+1}$ 可写为如下形式</p>
<script type="math/tex; mode=display">
r_{k+1}=b-Ax_{k+1}=b-A(x_k+\alpha_kd_k)=r_k-\alpha_kAd_k.</script><p>由关系式(4.4)有$d<em>{k-1}^\mathrm{T}r_k=0.$进而由$d_k=r_k+\beta</em>{k-1}d_{k-1}$有</p>
<script type="math/tex; mode=display">
\tag{步长的另一种表示}
\begin{align}
\alpha_k&=\frac{\boldsymbol{d}_k^\mathrm{T}\boldsymbol{r}_k}{\boldsymbol{d}_k^\mathrm{T}A\boldsymbol{d}_k}\\
&=\frac{(\boldsymbol{r}_k+\beta_{k-1}\boldsymbol{d}_{k-1})^\mathrm{T}\boldsymbol{r}_k}{\boldsymbol{d}_k^\mathrm{T}A\boldsymbol{d}_k}\\
&=\frac{\boldsymbol{r}_k^\mathrm{T}\boldsymbol{r}_k}{\boldsymbol{d}_k^\mathrm{T}\boldsymbol{A}\boldsymbol{d}_k}.

\end{align}</script><p>由$r<em>{k+1}=r_k-\alpha_kAd_k$,并结合后面定理4.3中的关系式$r</em>{k+1}^\mathrm{T}r_k=0$,有</p>
<script type="math/tex; mode=display">
\begin{align}
\beta_k&=-\frac{d_k^\mathrm{T}Ar_{k+1}}{d_k^\mathrm{T}Ad_k}\\
&=-\frac{(d_k^\mathrm{T}Ar_{k+1})^T}{d_k^\mathrm{T}Ad_k}\\
&=-\frac{r_{k+1}^\mathrm{T} A d_k}{d_k^\mathrm{T}Ad_k}\\
&=-\frac{r_{k+1}^\mathrm{T}(r_k-r_{k+1})}{\alpha_kd_k^\mathrm{T}Ad_k}\\
&=\frac{r_{k+1}^\mathrm{T}r_{k+1}}{r_k^\mathrm{T}r_k}.
\end{align}</script><p>其中,最后一步等式用到了步长$\alpha$ 的另一种表示</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p><strong>算法 4.2 求解对称正定线性方程组的共轭梯度法</strong></p>
<p><font color=green >输入</font>: 矩阵$\boldsymbol A$、向量$\boldsymbol b$、初始向量$\boldsymbol x_0$</p>
<p><font color=green >输出</font>:向量$x$<br>计算残量及方向$r_0=b-Ax_0,p_0=r_0$ ;<br>$k= 1$ ;<br>计算步长$\alpha_0=r_0^{\mathrm{T}}r_0/(p_0^{\mathrm{T}}Ap_0)$ ; </p>
<p>计算更新后向量$x_1=x_0+\alpha_0p_0;$ </p>
<p>计算当前残量$r<em>1=b-Ax_1$ ;<br>$\mathbf{while} $ $r_k\neq 0$ $\mathbf{do}$<br>    $k= k+ 1$ ;<br>    计算参数$\beta</em>{k-2}=\dfrac{r<em>{k-1}^\mathrm{T}r</em>{k-1}}{(r<em>{k-2}^\mathrm{T}r</em>{k-2})};$<br>    计算方向$p<em>k-1=r</em>{k-1}+\beta<em>{k-2}p</em>{k-2};$<br>    计算步长$\alpha<em>{k-1}=\dfrac{r</em>{k-1}^\mathrm{T}r<em>{k-1}}{(p</em>{k-1}^\mathrm{T}Ap_{k-1})};$ </p>
<p>​    计算更新后的向量$x<em>k=x</em>{k-1}+\alpha<em>{k-1}p</em>{k-1};$ </p>
<p>​    计算当前残量$r<em>k=r</em>{k-1}-\alpha<em>{k-1}Ap</em>{k-1};$<br>$\mathbf{endwhile}$ </p>
</blockquote>
<p>共轭梯度法具有良好的性质，可以归纳为如下定理：</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>定理4.3 共轭梯度法的性质</strong></p>
<p>对于任意给定的初始向量$x<em>0$,由共轭梯度法迭代$m$步产生的残量序列${\boldsymbol{r}_k}</em>{k=0}^m$及方向序列${\boldsymbol{d}_k}^m_k=0$满足：</p>
<ul>
<li>当前步的<strong>残量</strong>与前面<strong>任一步的下降方向</strong>均<font color="blue">正交</font>，即<script type="math/tex; mode=display">
r_k^\mathrm{T}\boldsymbol{d}_i=0,
\\i=0,\cdots,k-1,
\\1\leqslant k\leqslant m;</script></li>
</ul>
<p>​    <script type="math/tex">r_k^\mathrm{T}\boldsymbol{d}_i=0,\:i=0,\cdots,k-1,\:1\leqslant k\leqslant m;\quad p_i^\mathrm{T}r_j=0\\0\leq i<j\leq4</script></p>
<ul>
<li><p><strong>任意两步的残量</strong>均<font color="blue">正交</font>，即</p>
<script type="math/tex; mode=display">
r_i^\mathrm{T}r_j=0,\\0\leqslant i\neq j\leqslant m;</script></li>
<li><p><strong>任意两步的下降方向</strong>均关于矩阵$A$<font color="blue">正交</font>，即</p>
<script type="math/tex; mode=display">
d_i^\mathrm{T}Ad_j=0,\\
0\leqslant i\neq j\leqslant m;</script></li>
</ul>
<ul>
<li><script type="math/tex; mode=display">
\text{span}\{r_0,r_1,\cdots,r_k\}\\
=\text{span}\{d_0,d_1,\cdots,d_k\}\\
=\text{span}\{r_0,Ar_0,\cdots,A^kr_0\}\\
0\leq k \leq m.</script><p>对于给定的非奇异矩阵$A\in\mathbb{R}^n\times n$及向量$r_0\in\mathbb{R}^n$,定义</p>
<script type="math/tex; mode=display">\mathcal{K}_m(\boldsymbol{A},\boldsymbol{r}_0)=\operatorname{span}\left\{\boldsymbol{r}_0,\boldsymbol{A}\boldsymbol{r}_0,\cdots,\boldsymbol{A}^{m-1}\boldsymbol{r}_0\right\}</script><p>为$\mathbb{R}^n$关于$A$及$r_0$的 Krylov 子空间，其维数为</p>
<script type="math/tex; mode=display">\dim(\mathcal{K}_m(\boldsymbol{A},\boldsymbol{r}_0))=\min\left\{m,\operatorname{grad}(\boldsymbol{A},\boldsymbol{r}_0)\right\},</script><p>其中$\mathrm{grad}(\boldsymbol{A},\boldsymbol{r}<em>0)$为使得$p(\boldsymbol{A})\boldsymbol{r}_0=0$ 成立的所有首项系数为$1$W的多项式的最低次数.由残量的正交性可知，<strong>共轭梯度法最多经过$n$ 步 一 定 会 终 止 </strong>, 故 共 轭 梯 度 法 可 以 看作是直接法.但是由于实际使用中舍入误差的存在使得正交性很快会丢失，其有限步终止的性质也会不成立，故实际中一般作为迭代法使用.另外，在算法4.2中，部分运算是重复性的，例如 $r</em>{k-1}^\mathrm{T}r<em>{k-1},Ap</em>{k-1}$ 等，这些重复计算可以通过存储已计算结果避免. 综合上述讨论，可得如下实用的算法：</p>
<h2 id="实用算法"><a href="#实用算法" class="headerlink" title="实用算法"></a>实用算法</h2><blockquote>
<p><strong>算法 4.3 求解对称正定线性方程组的共轭梯度法</strong><br><font color=green>输入</font>：矩阵$\boldsymbol A$、向量$\boldsymbol b$、初始向量$x$、精度$\varepsilon$ 及最大迭代步数$k_\mathrm{max}$<br><font color=green>输出</font>：向量$x$<br>$r=b-Ax,\gamma=r^{\mathrm{T}}r,p=r;$ </p>
<script type="math/tex; mode=display">k=1,\omega=Ap,\alpha=\dfrac{\gamma}{(p^\mathrm{T}\omega)},x=x+\alpha p\:;</script><p>$r=r-\alpha\omega,\widetilde{\gamma}=\gamma,\gamma=r^{\mathrm{T}}r;$<br>$\mathbf{while}\sqrt{\gamma}\geqslant\varepsilon\left|b\right|\&amp;k&lt;k_{\max}\mathbf{do}$</p>
<pre><code>$$k=k+1,\beta=\gamma/\widetilde&#123;\gamma&#125;,p=r+\beta p;$$
$$\omega=Ap,\alpha=\gamma/(p^\mathrm&#123;T&#125;\omega),x=x+\alpha p;$$
$r=r-\alpha\omega,\widetilde&#123;\gamma&#125;=\gamma,\gamma=r^&#123;T&#125;r;$
</code></pre><p>$\textbf{endwhile}$</p>
</blockquote>
</li>
</ul>
<h2 id="定理4-4"><a href="#定理4-4" class="headerlink" title="定理4.4"></a>定理4.4</h2><blockquote>
<p><strong>定理4.4</strong></p>
<p>令$x_k$为利用共轭梯度法得到的第$k$个迭代向量，则有</p>
<script type="math/tex; mode=display">
\varphi(\boldsymbol{x}_k)=\min\left\{\varphi(\boldsymbol{x}):\boldsymbol{x}\in\boldsymbol{x}_0+\mathcal{K}_k(\boldsymbol{A},\boldsymbol{r}_0)\right\},</script><p>即:</p>
<script type="math/tex; mode=display">
\left\|x_{k}-x_{*}\right\|_{A}=\min\left\{\left\|x-x_{*}\right\|_{A}:x\in x_{0}+\mathcal{K}_{k}\left(A,r_{0}\right)\right\}.</script></blockquote>
<p><strong>在空间逐步增大的过程中. $\varphi(x_{k})$始终最优</strong></p>
<h2 id="定理4-5"><a href="#定理4-5" class="headerlink" title="定理4.5"></a>定理4.5</h2><p>关于共轭梯度法的收敛性估计，有以下定理成立</p>
<blockquote>
<p><strong>定理4.5</strong></p>
<p>由共轭梯度法产生的迭代序列${x<em>k}</em>{k=0}^\infty$满足：</p>
<script type="math/tex; mode=display">
\|x_k-x_*\|_A\leqslant2\left(\frac{\sqrt{\kappa_2(\boldsymbol{A})}-1}{\sqrt{\kappa_2(\boldsymbol{A})}+1}\right)^k\|x_0-x_*\|_A.</script></blockquote>
<p>由定理4.5可知，<strong>共轭梯度法的收敛性依赖于系数矩阵的条件数.当系数矩阵的条件数接近于1或者大部分的特征值集中在一点附近时，共轭梯度法具有较快的收敛速度</strong>.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>共轭梯度法</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Computations-LU Factorization</title>
    <url>/2024/09/25/Matrix%20Computations-LU%20Factorization/</url>
    <content><![CDATA[<h1 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h1><h2 id="Some-concepts"><a href="#Some-concepts" class="headerlink" title="Some concepts"></a>Some concepts</h2><p>We suppose $v \in \mathbb{R}^n$ with $v_k \neq0$ .If</p>
<script type="math/tex; mode=display">
\tag{3.2.3}
\tau^T=[0,\cdots,0,\tau_{k+1},\cdots,\tau_n],\tau_i=\dfrac{v_i}{v_k},i=k+1,\cdots,n,</script><p>and we difine </p>
<script type="math/tex; mode=display">
M_k=I_n-\tau e_k^T,</script><p>then </p>
<script type="math/tex; mode=display">
\left.M_kv = \left[\begin{array}{cccccc}1&\cdots&0&0&\cdots&0\\\vdots&\ddots&\vdots&\vdots&&\vdots\\0&&1&0&&0\\0&&-\tau_{k+1}&1&&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\\0&\cdots&-\tau_n&0&\cdots&1\end{array}\right.\right]\left[\begin{array}{c}v_1\\\vdots\\v_k\\v_{k+1}\\\vdots\\v_n\end{array}\right] = \left[\begin{array}{c}v_1\\\vdots\\v_k\\0\\\vdots\\0\end{array}\right]</script><p>A matrix of the form $M_k = I_n - \tau e_k^T\in \mathbb{R}^{nxn}$ is a <strong>Gauss transformation</strong> if the first $k$  components of $\tau \in \mathbb{R}^n$ are zero. Such a matrix is unit lower triangular. The components  of $\tau(k +1:n)$ are called <strong>multipliers.</strong> The vector $\tau$ is called the <strong>Gauss vector</strong>. </p>
<h2 id="LU-Factorization"><a href="#LU-Factorization" class="headerlink" title="LU Factorization"></a>LU Factorization</h2><p>If no zero pivots are encountered in (3.2.3), then Gauss transformations $M<em>1,M_2,\cdots,M</em>{n-1}$ are generated such that $M<em>{n-1}\cdots M_2M_1 A = U$ is upper triangular. It is easy to check  that if $M_k = I_n - \tau^{(k)}e_k^T$ , then its inverse is prescribed by $M</em>{k}^{-1}=I_n+\tau^{(k)}e_k^T$  and so </p>
<script type="math/tex; mode=display">
\tag{3.2.4}
A=LU</script><p>where</p>
<script type="math/tex; mode=display">
\tag{3.2.5}
L=M_1^{-1}\cdots M_{n-1}^{-1}</script><p>It is clear that L is a <strong>unit lower triangular matrix</strong> because each $M_k^{-1}$ is unit lower  triangular. The factorization (3.2.4) is called the <strong>LU factorization</strong>. </p>
<blockquote>
<p>Theorem 3.2.1 (LU Factorization)</p>
</blockquote>
<p>If $A \in \mathbb{R}^{n\times n}$ and $det(A(1:k,1:k))\neq 0$ for  $k = 1:n-1$ ,  then there exists a unit lower triangular $L \in \mathbb{R}^{n\times n}$ and an upper triangular  $U \in \mathbb{R}^{n\times n}$ such that $A = LU$. If this is the case and $A$ is <strong>nonsingular</strong>, then the  factorization is <strong>unique</strong> and $det(A) = u<em>{11}\cdots   u</em>{nn}$ </p>
<h2 id="存在的充要条件"><a href="#存在的充要条件" class="headerlink" title="存在的充要条件"></a>存在的充要条件</h2><blockquote>
<p>矩阵 $A$ 的顺序主子阵 $A_i$ 均非奇异  </p>
<script type="math/tex; mode=display">
\Leftrightarrow</script><p>矩阵 $A$ 的主元 $a_{ii}^{(i-1)}(i=1,\cdots,k)$ 均不为$0$</p>
<script type="math/tex; mode=display">
\Leftrightarrow</script><p>存在唯 一的单位下三角阵  $L\in \mathbb{R}^{n\times n}$和下三角阵$U\in \mathbb{R}^{n\times n}$使得 $A=LU$</p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><img src="/2024/09/25/Matrix%20Computations-LU%20Factorization/image-20241007185955860.png" class="" alt="image-20241007185955860">
<p>第二行中的 $A(k+1:n,k)$ 就是高斯变换中的乘子。</p>
<p>需要进行的浮点数运算(包含加减和乘除)一共是:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n-1}[(n-i)+2(n-i)^2]
=\frac{2}{3}
n^3+O(n)</script><h1 id="全主元高斯消去"><a href="#全主元高斯消去" class="headerlink" title="全主元高斯消去"></a>全主元高斯消去</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了解决两个问题</p>
<ul>
<li>主元值较小</li>
<li>主元值为 $0$</li>
</ul>
<h2 id="初等置换矩阵"><a href="#初等置换矩阵" class="headerlink" title="初等置换矩阵"></a>初等置换矩阵</h2><p>将单位矩阵$I$的第$p,q$两列交换得到的矩阵记为<strong>初等置换矩阵</strong>$I_{pq}$,即</p>
<script type="math/tex; mode=display">
I_{pq}=\begin{bmatrix}1&&&&&&&\\&\ddots&&&&&&\\&&0_{pp}&&&1_{pq}&&&\\&&&\ddots&&&&\\&&&1_{qp}&&0_{qq}&&&\\&&&&&\ddots&&\\&&&&&&1\end{bmatrix}</script><p>有如下的性质:</p>
<ul>
<li>$I<em>{pq}=I</em>{pq}^T=I_{qp}^{-1}$</li>
<li>$\det{(I_{pq})}=-1$</li>
</ul>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><blockquote>
<p>设  $A \in \mathbb{R}^{n\times n}$ ,则存在排列矩阵 $P,Q\in \mathbb{R}^{n\times n}$ ,以及单位下三角矩阵  $L \in \mathbb{L}^{n\times n}$  和上三角矩阵  $U \in \mathbb{R}^{n\times n}$  ,使得</p>
<script type="math/tex; mode=display">
PAQ=LU</script><p>且$L$ 的所有元素均满足 $|a_{ij}|&lt;1$ ,$U$的非零对角元的个数恰好等于矩阵 $A$ 的秩。</p>
</blockquote>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><img src="/2024/09/25/Matrix%20Computations-LU%20Factorization/image-20241007184719176.png" class="" alt="image-20241007184719176">
<p>复杂度分析，如果 $A$非奇异，那么全选主元必须要进行 </p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^{n-1}(n-k+1)^2=\frac{1}{3}n^3+O(n^3)</script><p>次两两元素之间的比较和逻辑判断，为了解决上述问题，列主元消去法被提出来。</p>
<p>列主元消去法的改进就是每次选取的时候，不是选取剩余的方阵的最大值，而是选取在这一列中的最大值，然后进行行交换。</p>
<p>算法如下:</p>
<img src="/2024/09/25/Matrix%20Computations-LU%20Factorization/image-20241007185234684.png" class="" alt="image-20241007185234684">
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>LU分解</tag>
      </tags>
  </entry>
  <entry>
    <title>Kalman filter</title>
    <url>/2024/09/07/Kalman-filter/</url>
    <content><![CDATA[<ul>
<li><p>sticky是<code>sticky</code> 值越大，顶置的文章越靠前</p>
</li>
<li><p>thumbnail: “IMAGE_LINK”</p>
<p>redefine对首页文章添加缩略图</p>
</li>
<li><p>摘要</p>
<p>excerpt: “这是文章摘要 This is the excerpt of the post”或者直接设置为false</p>
</li>
<li><p>massage: 文章的密码的提示，但是似乎没有什么用，总是显示Hey,password is required here.</p>
</li>
</ul>
<h1 id="参考文档（手把手教，强烈推荐）"><a href="#参考文档（手把手教，强烈推荐）" class="headerlink" title="参考文档（手把手教，强烈推荐）"></a>参考文档（手把手教，强烈推荐）</h1><p><a href="https://www.kalmanfilter.net/CN/default_cn.aspx">卡尔曼滤波教程</a></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Computations-Norm</title>
    <url>/2024/10/08/Matrix%20Computations-Norm/</url>
    <content><![CDATA[<h1 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个从 $\mathbb{R}^n$ 到 $\mathbb{R}$ 的非负函数$||·||$ 叫做  $\mathbb{R}^n$ 上的向量范数,如果它满足:</p>
<ul>
<li>正定性：对任意 $x\in\mathbb{R}^n$  ，有 $||x||\ge 0$ ，当且仅当 $x=0$ 的时候  $||x||= 0$ ；</li>
<li>齐次性:  对任意 $x\in\mathbb{R}^n$ 和 $\alpha\in\mathbb{R}$ ,有 $||\alpha x||=|\alpha|·||x||$；</li>
<li>三角不等式，  对任意 $x,y\in\mathbb{R}^n$ ，有 $||x+y||\leq ||x||+||y||$.</li>
</ul>
<p>向量范数是一个连续函数。</p>
<h2 id="常见的向量范数"><a href="#常见的向量范数" class="headerlink" title="常见的向量范数"></a>常见的向量范数</h2><h3 id="p-范数和闭单位球"><a href="#p-范数和闭单位球" class="headerlink" title="$p$范数和闭单位球"></a>$p$范数和闭单位球</h3><script type="math/tex; mode=display">
||x||_p=(|x_1|^p+\cdots+|x_n|^p)^{\frac{1}{p}},\quad p\ge1</script><p>特别的，当 $p=1,2,\infty$ 是最重要的，即</p>
<script type="math/tex; mode=display">
\begin{cases}
||x||_1=|x_1|+\cdots+|x_n|;\\
||x||_2=(|x_1|^2+\cdots+|x_n|^2)^{\frac{1}{2}};\\
||x||_{\infty}=\max\{|x_i|:i=1,\cdots,n\}.
\end{cases}</script><p>有了 $p$ 范数的定义，我们可以定义在不同范数下的闭单位球:</p>
<img src="/2024/10/08/Matrix%20Computations-Norm/image-20241008105616111.png" class="" alt="image-20241008105616111">
<h3 id="带权重的向量范数"><a href="#带权重的向量范数" class="headerlink" title="带权重的向量范数"></a>带权重的向量范数</h3><blockquote>
<p>给定任意向量范数$||·||$,对任意<strong>非奇异矩阵</strong>$W$,定义：</p>
<script type="math/tex; mode=display">
||x||_W=||Wx||</script><p>可以证明，$||·||_W$ 也是向量范数。</p>
</blockquote>
<h2 id="向量范数的等价性"><a href="#向量范数的等价性" class="headerlink" title="向量范数的等价性"></a>向量范数的等价性</h2><blockquote>
<p>设 $||·||<em>\alpha $ 和 $||·||</em>\beta $ 是 $\mathbb{R}^{n}$上任意两个范数，则存在正常数 $c_1,c_2$ 使得对于任意 $x\in\mathbb{R}^{n}$,有:</p>
<script type="math/tex; mode=display">
c_1||x||_\alpha\leq ||x||_\beta\le c_2||x||_\alpha</script></blockquote>
<h2 id="向量序列的范数收敛"><a href="#向量序列的范数收敛" class="headerlink" title="向量序列的范数收敛"></a>向量序列的范数收敛</h2><p>向量序列的范数收敛等价于其分量收敛</p>
<blockquote>
<p>设 $x<em>k\in \mathbb{R}^n$ ,则 $\lim</em>{k\to\infty}||x_k-x||=0$ 的充分必要条件是:</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}||x_i^{(k)}-x_i||=0,\qquad i=1,2,\cdots,n</script></blockquote>
<h1 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>一个从  $\mathbb{R}^{n\times n}$ 到 $\mathbb{R}$ 的非负函数$||·||$ 叫做  $\mathbb{R}^{n\times n}$ 上的矩阵范数,如果它满足:</p>
<ul>
<li>正定性：对任意 $A\in\mathbb{R}^{n\times n}$  ，有 $||A||\ge 0$ ，当且仅当 $A=0$ 的时候  $||A||= 0$ ；</li>
<li>齐次性:  对任意 $A\in\mathbb{R}^{n\times n}$ 和 $\alpha\in\mathbb{R}$ ,有 $||\alpha A||=|\alpha|·||A||$；</li>
<li>三角不等式，  对任意 $A,B\in\mathbb{R}^{n\times n}$ ，有 $||A+B||\leq ||A||+ ||B||$；</li>
<li><em>*相容性</em>，有 $||AB||\leq ||A||· ||B||$.</li>
</ul>
<h2 id="矩阵范数的性质"><a href="#矩阵范数的性质" class="headerlink" title="矩阵范数的性质"></a>矩阵范数的性质</h2><h3 id="继承自向量范数"><a href="#继承自向量范数" class="headerlink" title="继承自向量范数"></a>继承自向量范数</h3><p>由于  $\mathbb{R}^{n\times n}$  上矩阵范数可以看作是  $\mathbb{R}^{n^2}$  上的向量范数的推广,所以矩阵范数具有向量范数的<strong>一切性质</strong>,例如:</p>
<ul>
<li><p>$\mathbb{R}^{n\times n}$  上的任意两个矩阵范数是等价的;</p>
</li>
<li><p>矩阵序列的范数收敛等价于其元素收敛,即 </p>
<script type="math/tex; mode=display">
\lim _{k\to \infty}||A_k-A||=0 \Leftrightarrow \lim _{k\to \infty}a_{ij}^{(k)}=a_{ij},\qquad i,j=1,\cdots,n</script></li>
</ul>
<h3 id="矩阵向量范数的相容性"><a href="#矩阵向量范数的相容性" class="headerlink" title="矩阵向量范数的相容性"></a>矩阵向量范数的相容性</h3><p>若矩阵范数$||·||_M$和向量范数$||·||_v$满足:</p>
<script type="math/tex; mode=display">
\left\|Ax\right\|_v\leq\left\|A\right\|_M\left\|x\right\|_v, A\in\mathbb{R}^{n\times n}, x\in\mathbb{R}^n,</script><p>则称矩阵范数$||·||_M$和向量范数$||·||_v$是相容的。</p>
<h2 id="Frobenius范数-F-范数-和算子范数"><a href="#Frobenius范数-F-范数-和算子范数" class="headerlink" title="Frobenius范数($F$-范数)和算子范数"></a>Frobenius范数($F$-范数)和算子范数</h2><h3 id="F-范数"><a href="#F-范数" class="headerlink" title="$F$-范数"></a>$F$-范数</h3><script type="math/tex; mode=display">
\left\|A\right\|_F=\sqrt{\sum_{i=1}^n\sum_{j=1}^n|a_{ij}|^2}.</script><p>若干性质如下:</p>
<ul>
<li>(正交不变性)对任意的 $n$ 阶正交矩阵$U$和$V$,有$||UA||_F=||AV||_F=||A||_F$</li>
<li><script type="math/tex; mode=display">||A||_F^2=tr(A^TA)=tr(AA^T)</script></li>
<li><script type="math/tex; mode=display">||AB||_F^2\ge ||A||_F^2\cdot ||B||_F^2</script></li>
<li></li>
</ul>
<h3 id="算子范数"><a href="#算子范数" class="headerlink" title="算子范数"></a>算子范数</h3><blockquote>
<p>设 $||·||$是  $\mathbb{R}^{n}$ 上的一个向量范数，若定义</p>
<script type="math/tex; mode=display">
\begin{align}
||A||&=\max_{||x||=1}||Ax||\\
&=\max_{||x||\neq 0}\frac{||Ax||}{||x||},\quad A\in \mathbb{R}^{n\times n}
\end{align}</script><p>则 $||·||$ 是  $\mathbb{R}^{n\times n}$  上的一个矩阵范数.该矩阵范数称为<strong>从属于向量范数$||·||$的矩阵范数</strong>,也称为由向量范数$||·||$<strong>诱导出的算子范数</strong>.</p>
</blockquote>
<h3 id="矩阵-p-范数"><a href="#矩阵-p-范数" class="headerlink" title="矩阵 $p$-范数"></a>矩阵 $p$-范数</h3><blockquote>
<script type="math/tex; mode=display">
||A||_p=\max_{||x||_p=1}||Ax||_p</script></blockquote>
<p>矩阵 $p$-范数随 $p$ 取值的不同，未必满足矩阵范数的定义的三条性质。</p>
<h4 id="1-范数"><a href="#1-范数" class="headerlink" title="$1$-范数"></a>$1$-范数</h4><p>即<strong>列</strong>和的最大值</p>
<script type="math/tex; mode=display">
\left\|A\right\|_1=\max_{1\leq j\leq n}\left(\sum_{i=1}^n\left|a_{ij}\right|\right);</script><h4 id="infty-范数"><a href="#infty-范数" class="headerlink" title="$\infty$-范数"></a>$\infty$-范数</h4><p>即<strong>行</strong>和的最大值</p>
<script type="math/tex; mode=display">
\left\|A\right\|_1=\max_{1\leq j\leq n}\left(\sum_{i=1}^n\left|a_{ij}\right|\right);</script><p><strong>注意: $\infty$-范数不满足相容性。</strong></p>
<h4 id="2-范数"><a href="#2-范数" class="headerlink" title="$2$-范数"></a>$2$-范数</h4><script type="math/tex; mode=display">
||A||_2=\sqrt{\lambda_\max(A^TA)}</script><p>关于 $2$- 范数，有如下定理:</p>
<blockquote>
<ol>
<li><p>$\left|A\right|_2=\max{\left|y^\mathrm{T}Ax\right|:x,y\in\mathbb{C}^n,\left|x\right|_2=\left|y\right|_2=1}$</p>
</li>
<li><p>$\left|A^\mathrm{T}\right|_2=\left|A\right|_2=\sqrt{\left|A^\mathrm{T}A\right|_2}$</p>
</li>
<li>对任意的$n$阶正交矩阵$U$和$V$,有$||UA||_2=||AV||_2=||A||_2$</li>
<li>.对任意的$n$阶正交矩阵$U$和$V$,有$||UA||_F=||AV||_F=||A||_F$</li>
</ol>
</blockquote>
<p>由此可知，<strong>$F$-范数和$2$-范数具有正交不变性。</strong></p>
<h1 id="谱半径"><a href="#谱半径" class="headerlink" title="谱半径"></a>谱半径</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>设 $A\in \mathbb{C}^{n\times n}$ ,则称</p>
<script type="math/tex; mode=display">
\rho(A)=\max\{|\lambda|: \lambda\in\lambda(A)\}</script><p>为 $A$ 的谱半径，这里 $\lambda(A)$ 表示矩阵 $A$ 的特征值的全体。</p>
</blockquote>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>设 $A\in \mathbb{C}^{n\times n}$ ,则有</li>
</ol>
<ul>
<li>对 $\mathbb{C}^{n\times n}$上的任意矩阵范数 $||·||$，有$\rho(A)\leq ||A||$；（谱半径一定小于任一矩阵范数）</li>
<li>对于任给的 $\epsilon&gt;0$ ,存在 $\mathbb{C}^{n\times n}$上的算子范数 $||·||$ ,使得 $||A||\leq \rho(A)+\epsilon $</li>
</ul>
<ol>
<li><p>设 $A\in \mathbb{C}^{n\times n}$ ,则有</p>
<script type="math/tex; mode=display">
\lim\limits_{k\to\infty}A^k=\mathrm 0\Leftrightarrow \rho(A)<1\Leftrightarrow \sum\limits_{k=0}^\infty A^k收敛</script></li>
<li><p>当$\sum\limits_{k=0}^\infty A^k$收敛时，有</p>
<script type="math/tex; mode=display">
\sum\limits_{k=0}^\infty A^k=(I-A)^{-1},</script><p>且存在 $\mathbb{C}^{n\times n}$上的算子范数 $||·||$ ,使得</p>
<script type="math/tex; mode=display">
\left\|(I-A)^{-1}-\sum_{k=0}^mA^k\right\|\leq\frac{\left\|A\right\|^{m+1}}{1-\left\|A\right\|}</script><p>对一切的自然数 $m$ 成立.</p>
<h2 id="范数估计"><a href="#范数估计" class="headerlink" title="范数估计"></a>范数估计</h2><blockquote>
<p>设 $||·||$ 是 $\mathbb{C}^{n\times n}$ 上的一个满足 <script type="math/tex">||I||=1</script> 的范数，假定 $A\in \mathbb{C}^{n\times n}$ ，$A$ 满足  $||A||&lt;1$ 且 $I-A$ 可逆，则</p>
<script type="math/tex; mode=display">
||(I-A)^{-1}||<\frac{1}{1-||A||}</script></blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>norm</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Computations-Round-off error analysis</title>
    <url>/2024/10/09/Matrix%20Computations-Round-off%20error%20analysis/</url>
    <content><![CDATA[<h1 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>设 $||·||$ 是 $\mathbb{C}^{n\times n}$ 上的一个满足 <script type="math/tex">||I||=1</script> 的范数，假定</p>
<ul>
<li>$A\in \mathbb{C}^{n\times n}$ 且非奇异；</li>
<li>$b\in \mathbb{R}^n$ 非零;</li>
<li>$\delta A\in \mathbb{C}^{n\times n}$ 且$\left|A\right|^{-1}\left|\delta A\right|&lt;1$ .</li>
</ul>
<p>若 $x$ 和 $\delta x$ 分别是线性方程组</p>
<script type="math/tex; mode=display">
Ax=b\quad\text{和}\quad (A+\delta A)(x+\delta x)=b+\delta b</script><p>的解，则</p>
<script type="math/tex; mode=display">
\frac{\|\delta x\|}{\|x\|}\leq\frac{\kappa(A)}{1-\kappa(A)\frac{\|\delta A\|}{\|A\|}}\Big(\frac{\|\delta A\|}{\|A\|}+\frac{\|\delta b\|}{\|b\|}\Big)</script><p>其中，$\kappa(A)=||A||·||A^{-1}||$</p>
</blockquote>
<p>我们将  $\kappa(A)=||A||·||A^{-1}||$ 称之为线性方程组 $Ax=b$ 的条件数。</p>
<h2 id="病态和良态"><a href="#病态和良态" class="headerlink" title="病态和良态"></a>病态和良态</h2><p>通常，如果矩阵 $A$ 的条件数 $\kappa (A)$ 很大，则称 $A$ 是<strong>病态</strong>的；反之，若矩阵 $A$ 的条件数 $\kappa (A)$ 很小，则称 $A$ 是<strong>良态</strong>的；</p>
<h2 id="条件数的等价性"><a href="#条件数的等价性" class="headerlink" title="条件数的等价性"></a>条件数的等价性</h2><p>由矩阵范数的等价性可推出，$\mathbb{R}^{n\times n}$ 上任意两个范数下的条件数  $\kappa<em>\alpha(A)$和 $\kappa</em>\alpha(B)$ 都是等价的, 即存在常数 $c_1$  和 $c_2$  , 使得</p>
<script type="math/tex; mode=display">
c_1\kappa_\alpha(A)\leq\kappa_\beta(A)\leq c_2\kappa_\alpha(A).</script><h2 id="推论和定理"><a href="#推论和定理" class="headerlink" title="推论和定理"></a>推论和定理</h2><blockquote>
<p>设 $||·||$ 是 $\mathbb{C}^{n\times n}$ 上的一个满足 <script type="math/tex">||I||=1</script> 的范数，假定</p>
<ul>
<li><p>$A\in \mathbb{C}^{n\times n}$ 且非奇异；</p>
</li>
<li><p>$\delta A\in \mathbb{C}^{n\times n}$ 且$\left|A\right|^{-1}\left|\delta A\right|&lt;1$ .</p>
</li>
</ul>
<p>则 $A+\delta A$ 也是非奇异的，且有</p>
<script type="math/tex; mode=display">
\frac{\left\|(A+\delta A)^{-1}-A^{-1}\right\|}{\|A^{-1}\|}\leq\frac{\kappa(A)}{1-\kappa(A)\frac{\|\delta A\|}{\|A\|}}\frac{\|\delta A\|}{\|A\|}</script><p>设$A\in \mathbb{C}^{n\times n}$ 且非奇异，则</p>
<script type="math/tex; mode=display">
\min\Big\{\frac{\left\|\delta A\right\|_2}{\left\|A\right\|_2}:A+\delta A\text{奇异}\Big\}=\frac{1}{\left\|A\right\|_2\left\|A^{-1}\right\|_2}=\frac{1}{\kappa_2(A)}</script><p>注意，该定理在<strong>谱范数</strong>意义下成立。</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>舍入误差</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Computations-古典迭代法求解线性方程组</title>
    <url>/2024/12/12/Matrix-Computations-%E5%8F%A4%E5%85%B8%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<h1 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h1><h2 id="定理3-4"><a href="#定理3-4" class="headerlink" title="定理3.4"></a>定理3.4</h2><p>Jacobi迭代的迭代矩阵$B$ 的无穷范数小于$1$，则Gauss-Seidel迭代法收敛。</p>
<h2 id="定理3-5"><a href="#定理3-5" class="headerlink" title="定理3.5"></a>定理3.5</h2><p>Jacobi迭代的迭代矩阵$B$ 的1范数小于$1$，则Gauss-Seidel迭代法收敛。</p>
<h2 id="定理3-6"><a href="#定理3-6" class="headerlink" title="定理3.6"></a>定理3.6</h2><p>若系数矩阵A对称，对角线元素$a_{ii}&gt;0$,则$Jacobi$迭代法的充分必要条件是$A$和$2D-A$均正定。</p>
<h2 id="定理3-7"><a href="#定理3-7" class="headerlink" title="定理3.7"></a>定理3.7</h2><p>若系数矩阵$A$对称正定，则$Gauss-Seidel$迭代法收敛。</p>
<h2 id="定理3-8"><a href="#定理3-8" class="headerlink" title="定理3.8"></a>定理3.8</h2><p>若系数矩阵$A$对称正定，则不带松弛因子的迭代法 $\boldsymbol x_{k+1}=(I-A)\boldsymbol x_k+b$收敛的充要条件是A的所有特征值 $\lambda_i \in (0,2)$</p>
<h2 id="定理3-9"><a href="#定理3-9" class="headerlink" title="定理3.9"></a>定理3.9</h2><p>若系数矩阵$A$对称正定，则带松弛因子的迭代法 $\boldsymbol x<em>{k+1}=(I-\omega A)\boldsymbol x_k+\omega b$ (即Richard迭代)收敛的充要条件是 $0&lt;\omega &lt;\dfrac{2}{\lambda</em>{\max}(A)}$</p>
<p>而无需考虑$A$的特征值范围。</p>
<h2 id="定理3-11"><a href="#定理3-11" class="headerlink" title="定理3.11"></a>定理3.11</h2><p>若系数矩阵 $A$对称正定，则JOR迭代法 $\boldsymbol x<em>{k+1}=(I-\omega D^{-1}A)\boldsymbol x_k+\omega D^{-1} b$收敛的充要条件是 $0&lt;\omega &lt;\dfrac{2}{\lambda</em>{\max}(D^{-1}A)}$</p>
<h2 id="定理3-12"><a href="#定理3-12" class="headerlink" title="定理3.12"></a>定理3.12</h2><p>若系数矩阵$A$正定，对角线元素$a_{ii}&gt;0$,则$SOR$和$SSOR$迭代法的充分必要条件是<script type="math/tex">A</script>正定且 $0&lt;\omega &lt;2$ </p>
<h2 id="定理3-13"><a href="#定理3-13" class="headerlink" title="定理3.13"></a>定理3.13</h2><p>不可约弱对角占优矩阵或者严格对角占优矩阵是非奇异的，且对角元一定不为$0$.</p>
<h2 id="定理3-14"><a href="#定理3-14" class="headerlink" title="定理3.14"></a>定理3.14</h2><p>若$A$为不可约弱对角占优矩阵或者严格对角占优矩阵，且其对角线元素为正，则A为正定阵。</p>
<h2 id="定理３-１５"><a href="#定理３-１５" class="headerlink" title="定理３.１５"></a>定理３.１５</h2><p>若$A$为不可约弱对角占优矩阵或者严格对角占优矩阵，则$Jacobi$迭代和$Gauss-Seidel$迭代收敛。</p>
<h2 id="定理3-16"><a href="#定理3-16" class="headerlink" title="定理3.16"></a>定理3.16</h2><p>若$A$为不可约弱对角占优矩阵或者严格对角占优矩阵，则松弛因子$0&lt;\omega\le 1$的SOR迭代法收敛。</p>
<h2 id="最佳松弛因子"><a href="#最佳松弛因子" class="headerlink" title="最佳松弛因子"></a>最佳松弛因子</h2><h3 id="Richardson"><a href="#Richardson" class="headerlink" title="Richardson"></a>Richardson</h3><script type="math/tex; mode=display">
\omega_{opt}=\dfrac{2}{\lambda_1+\lambda_n}</script>]]></content>
  </entry>
  <entry>
    <title>Matrix Compututations-Classical iteration method for solving linear equations</title>
    <url>/2024/10/08/Matrix%20Compututations-Classical%20iteration%20method%20for%20solving%20linear%20equations/</url>
    <content><![CDATA[<h1 id="迭代法及其收敛条件"><a href="#迭代法及其收敛条件" class="headerlink" title="迭代法及其收敛条件"></a>迭代法及其收敛条件</h1><p>一般来说，$l$步迭代可以表示为:</p>
<script type="math/tex; mode=display">
\tag{3.2}
\boldsymbol{x_k}=\phi_k(\boldsymbol{x_{k-1}},\cdots,\boldsymbol{x_{k-1}})</script><p>其中，$\phi<em>k$为<strong>迭代算子</strong>，$\boldsymbol x_0,\cdots \boldsymbol x</em>{l-1}$为迭代初值，当$l=1$的时候是<strong>单步迭代法</strong>；</p>
<p>若迭代过程中，迭代算子不变则称改迭代法为<strong>定常迭代法</strong>，否则为不定长迭代；</p>
<p>若迭代算子为线性算子，则称改迭代法为<strong>线性迭代法</strong>，否则为非线性迭代。</p>
<h2 id="线性定常迭代法收敛的充要条件"><a href="#线性定常迭代法收敛的充要条件" class="headerlink" title="线性定常迭代法收敛的充要条件"></a>线性定常迭代法收敛的充要条件</h2><p>迭代法（3.2）收敛充要条件为 $\rho(\boldsymbol G)&lt;1$</p>
<h2 id="收敛的性质1"><a href="#收敛的性质1" class="headerlink" title="收敛的性质1"></a>收敛的性质1</h2><p>若相容矩阵范数$\lVert ·\rVert_M$ 满足$\lVert G\rVert_M&lt;1$ 则迭代公式（3.2）收敛，且</p>
<script type="math/tex; mode=display">
\tag{定理3.2}
\lVert\boldsymbol x_k-\boldsymbol x_*\rVert_V\le\frac{\lVert \boldsymbol G\rVert_M^k}{1-\lVert \boldsymbol G\rVert_M}
\lVert\boldsymbol x_0-\boldsymbol x_1\rVert_V</script><p>可以发现，$\boldsymbol x_k$收敛的速度依赖于$\lVert \boldsymbol G\rVert_M$和$1$的接近程度，当$\lVert \boldsymbol G\rVert_M$很接近$1$的时候，收敛速度很慢，<strong>当$\lVert \boldsymbol G\rVert_M$很小的时候，收敛较快。</strong></p>
<h2 id="收敛的性质2"><a href="#收敛的性质2" class="headerlink" title="收敛的性质2"></a>收敛的性质2</h2><p>设一阶线性定常迭代法的迭代算子为 $\boldsymbol G$,如果其范数$\lVert G\rVert_M=q&lt;1$，那么很显然其收敛，我们有以下结论:</p>
<script type="math/tex; mode=display">
(1).&\lim_{k\to\infty}\boldsymbol x_k=\boldsymbol x_*\\
(2).&\lVert \boldsymbol x_*-\boldsymbol x_k\rVert\leq q^k\lVert \boldsymbol x_*-\boldsymbol x_0\rVert\\
(3).&\lVert \boldsymbol x_*-\boldsymbol x_k\rVert\leq\frac{q}{1-q}\lVert \boldsymbol x_k-\boldsymbol x_{k-1}\rVert\\
(4).&\lVert \boldsymbol x_*-\boldsymbol x_k\rVert\leq\frac{q^k}{1-q}\lVert \boldsymbol x_1-\boldsymbol x_0\rVert</script><h1 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h1><h1 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h1>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>古典迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System-process</title>
    <url>/2024/10/18/Operating%20System-process/</url>
    <content><![CDATA[<h1 id="程序顺序执行与并发执行"><a href="#程序顺序执行与并发执行" class="headerlink" title="程序顺序执行与并发执行"></a><strong>程序顺序执行与并发执行</strong></h1><h2 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h2><p>衡量一个系统效率的一个指标就是吞吐率，计算公式如下:</p>
<script type="math/tex; mode=display">
吞吐率=\frac{作业道数}{全部作业时间}</script><p>提高系统的吞吐量应当提高系统资源的利用率</p>
<h2 id="多道程序的缺点"><a href="#多道程序的缺点" class="headerlink" title="多道程序的缺点"></a>多道程序的缺点</h2><p>多道下内存和处理机利用率得到显著提高。但是内存存放程序数量并非越多越好</p>
<ul>
<li>影响系统的响应速度</li>
<li>产生过多的系统开销（系统本身运行的时空耗费）。</li>
</ul>
<p>多道程序设计提高了系统效率，也带来了<strong>系统资源的竞争，因此要协调程序与资源的关系。</strong>处理机、存储器和外部设备是计算机系统中重要的硬件资源，因而需要解决处理机资源管理、存储器分配和回收以及外部设备资源管理等问题。</p>
<h1 id="现代操作系统的重要特征"><a href="#现代操作系统的重要特征" class="headerlink" title="现代操作系统的重要特征"></a>现代操作系统的重要特征</h1><p><strong>现代操作系统重要特征：并发、资源共享、用户随机使用资源。</strong></p>
<h1 id="程序的顺序执行与并发执行"><a href="#程序的顺序执行与并发执行" class="headerlink" title="程序的顺序执行与并发执行"></a><strong>程序的顺序执行与并发执行</strong></h1><h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p><strong>前驱图是一个</strong>有向无循环图，记为DAG(Directed Acyclic Graph)，可用于描述进程之间执行的前后关系。</p>
<img src="/2024/10/18/Operating%20System-process/image-20241018205602561.png" class="" alt="image-20241018205602561">
<p>与之相关的概念如下:</p>
<ul>
<li><p>结点：一个程序段、进程或一条语句；</p>
</li>
<li><p>有向边：两个结点之间的前趋关系；</p>
</li>
<li><p>重量：结点所含有的程序量或执行时间；</p>
</li>
<li><p>直接前驱、直接后继、开始结点、终止结点</p>
</li>
</ul>
<p>上述DAG图存在的前驱关系如下:</p>
<p>P1→P2，P1→P3，P1→P4，P2→P5，P3→P5，P4→P6，P4→P7，P5→P8，P6→P8，P7→P9，P8→P9；</p>
<p><strong>前趋图中必须不存在循环。</strong></p>
<h2 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h2><p>程序顺序执行具有如下 3 个特点： </p>
<ul>
<li><strong>顺序性；</strong>顺序执行行过程可看作一系列严格按程序规定的状态转移过程。 </li>
<li><strong>封闭性；</strong>程序执行得到的最终结果由给定的初始条件决定，<strong>不受外界因素的影响</strong>。 </li>
<li><strong>可再现性；</strong>只要输入的初始条件相同，则无论何时重复执行该程序都会得到相同的结果。 </li>
</ul>
<p><strong>程序顺序执行的特性为程序员检测和校正程序错误带来很大的方便！</strong></p>
<h2 id="多道的执行环境特点"><a href="#多道的执行环境特点" class="headerlink" title="多道的执行环境特点"></a>多道的执行环境特点</h2><p>计算机能够<strong>同时处理多个具有独立功能的程序</strong>。多道的执行环境具有如下 3 个特点： </p>
<ul>
<li><strong>独立性；</strong>每道程序都是逻辑上独立的。 </li>
<li><strong>随机性；</strong>多道程序环境下，特别是多用户环境下，程序和数据输入与执行开始时间都是随机的。</li>
<li><strong>资源共享；</strong> <strong>资源共享将导致对程序执行速度的制约</strong>。外设有限将导致这些设备被共享、内存有限将导致内存被共享等。对单CPU系统更如此。 </li>
</ul>
<h2 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h2><img src="/2024/10/18/Operating%20System-process/image-20241018210539066.png" class="" alt="image-20241018210539066">
<p>不同程序之间可以并发执行，这是<strong>系统的并发性</strong>，一个程序<strong>内部语句之间在并发环境下依然有并发执行的情况</strong>，如下面的情况:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">S0：x = a+10；</span><br><span class="line">S1：y = b - a；</span><br><span class="line">S2：z = x+y-10；</span><br><span class="line">S3：<span class="built_in">print</span>（z）；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>程序内部各程序段间是否具备并发执行是由它们之间依赖关系所决定</strong>。</p>
<p><strong>并发性是增强计算机系统的处理能力和提高资源利用率所采取的一种技术</strong>。程序的并发执行通过前面的分析可分为两种： </p>
<ul>
<li><strong>多道程序系统的程序执行环境变化所引起的多道程序的并发执行</strong>。多道程序并发执行在<strong>宏观上是同时</strong>进行的，但在<strong>微观上仍是顺序</strong>执行的。 </li>
<li>并发执行是在某道程序的几个程序段中，包含着一部分可以同时执行或顺序颠倒执行的代码。</li>
</ul>
<p>​     在时间上来表示，<strong>并发执行是一个程序的开始是在另一个程序结束之前</strong>。</p>
<h2 id="并发执行的特点"><a href="#并发执行的特点" class="headerlink" title="并发执行的特点"></a>并发执行的特点</h2><h3 id="间断性"><a href="#间断性" class="headerlink" title="间断性"></a>间断性</h3><p>程序在并发执行时，由于它们共享资源或为完成某一项任务而合作，致使在<strong>并发程序之间存在相互制约的关系。</strong></p>
<h3 id="失去封闭性"><a href="#失去封闭性" class="headerlink" title="失去封闭性"></a>失去封闭性</h3><p>程序在并发执行时，是多个程序<strong>共享系统中的各种资源</strong>，因而这些<strong>资源的状态将由多个程序来改变</strong>，<strong>致使程序的运行失去了封闭性</strong>。当处理机资源被其它程序占用时，有条件运行的任何程序都必须等待<strong>。</strong> </p>
<h3 id="不可再现性"><a href="#不可再现性" class="headerlink" title="不可再现性"></a>不可再现性</h3><p>程序在并发执行时，<strong>由于失去了封闭性，也导致失去了可再现性</strong>。</p>
<h2 id="并发执行的条件"><a href="#并发执行的条件" class="headerlink" title="并发执行的条件"></a>并发执行的条件</h2><p>在某些情况下，程序的并发执行使得执行结果不再具有封闭性和可再现性，且可能造成出现错误（<strong>执行结果受执行速度影响的结果</strong>）。</p>
<p>为了使在并发执行时不出现错误结果，必须<strong>采取某些措施来制约、控制各并发程序段执行速度</strong>。</p>
<p>1966年Bernstein 提出了相邻语句S1，S2可以并发执行的条件：</p>
<p>语句Si划分为两个变量集合R(Si)和W(Si)；分别为 Si 的<strong>读集和写集</strong>。</p>
<p>其中，<strong>R(Si)={a1</strong>，<strong>a2</strong>，…，<strong>am}</strong>是语句Si在执行期间对其进行<strong>参考</strong>的变量；aj(j=1，…，m)。</p>
<p>​      <strong>W(Si)={b1</strong>，<strong>b2</strong>，…，<strong>bn}</strong>是语句Si在执行期间对其进行访问的变量；bj(j=1，…，n)。</p>
<p>如果对于语句 S1 和 S2，有</p>
<p>① R(S1)∩ W(S2)=Ø，即S1读变量不是S2 修改的变量。</p>
<p>② W(S1)∩ R(S2)=Ø，即S2读变量不是S1 修改的变量。</p>
<p>③ W(S1)∩ W(S2)=Ø，即双方都不修改相同的变量。</p>
<p>如果并发执行的各程序段中语句或指令满足上述Bernstein 的三个条件（同时成立），则认为并发执行不会对执行结果的封闭性和可再现性产生影响（证明略）。</p>
<p>但在一般情况下，<strong>这个条件对于软件设计（模块化）过于苛刻，系统要判定并发执行的各程序段是否满足Bernstein条件是相当困难的</strong>。从而，如果并发执行的程序段不按照特定的规则和方法进行资源共享和竞争，则其执行结果将不可避免地失去封闭性和可再现性。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的提出"><a href="#进程的提出" class="headerlink" title="进程的提出"></a>进程的提出</h2><p>根据Bernstein 条件，我们不能通过限制程序的编写方式和内容来获得系统的可再现性，因此<strong>解决此问题可能需要依靠控制程序的执行过程来解决</strong>。因为操作系统用户随机性与各道程序逻辑独立的特点将使得每个用户程序所使用的软、硬件资源都受到其他并发程序的共享和竞争，从而得到非预料的或不正确的结果。<strong>为了控制和协调各程序执行过程中的软、硬件资源的共享和竞争</strong>，显然， 需要有一个<strong>能描述程序的执行过程且能用来共享资源的基本单位</strong>。这个基本单位被称为<strong>进程（或任务）</strong>。</p>
<blockquote>
<p> 进程是可并发执行的程序在一个数据集合上的运行过程。</p>
<p>  进程是指进程实体的运行过程。</p>
</blockquote>
<h2 id="进程和程序的比较"><a href="#进程和程序的比较" class="headerlink" title="进程和程序的比较"></a>进程和程序的比较</h2><ul>
<li><p>程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。<strong>程序是静态的，进程是动态的</strong></p>
</li>
<li><p>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<strong>程序是永久的，进程是暂时的；</strong></p>
</li>
<li><p><strong>进程更能真实地描述并发，而程序不能；</strong></p>
</li>
<li><p>进程是由<strong>程序和数据、进程控制块、PCB、三部分组成的；</strong></p>
</li>
<li><p><strong>进程具有创建其他进程的功能，而程序没有</strong></p>
</li>
<li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说<strong>同一程序可以对应多个进程</strong></li>
</ul>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><ul>
<li><p><strong>结构性</strong>：由进程段、数据段、进程控制块三部分组成；</p>
</li>
<li><p><strong>动态性</strong>：进程是程序的执行过程；</p>
</li>
<li><p><strong>并发性</strong>：多个进程可同存于内存中，能在一段时间内同时运行；</p>
</li>
<li><p><strong>独立性</strong>：独立运行的基本单位，独立获得资源和调度的基本单位；</p>
</li>
<li><p><strong>异步性</strong>：各进程按各自独立的不可预知的速度向前推进</p>
</li>
</ul>
<h1 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h1><h2 id="进程的三个基本状态"><a href="#进程的三个基本状态" class="headerlink" title="进程的三个基本状态"></a>进程的三个基本状态</h2><p>进程在生命消亡前处于且仅处于三种基本状态之一。<strong>（就绪，运行，阻塞)</strong></p>
<h3 id="就绪状态-Ready"><a href="#就绪状态-Ready" class="headerlink" title="就绪状态(Ready)"></a>就绪状态(Ready)</h3><p>存在于处理机调度队列中的所有进程，它们已经准备就绪，<strong>一旦得到CPU，就立即可以运行</strong>。这些进程所处的状态为就绪状态。</p>
<p><strong>就绪队列</strong>：处于就绪状态的进程按一定的策略排队，同一时刻可有多个就绪队列。</p>
<h3 id="运行状态-Running"><a href="#运行状态-Running" class="headerlink" title="运行状态(Running)"></a>运行状态(Running)</h3><p><strong>正在运行的进程所处的状态为运行状态。</strong></p>
<p>  单处理机系统只有一个进程处于该状态。</p>
<p>  多处理机系统有多个进程处于运行状态。</p>
<h3 id="等待-睡眠-阻塞状态-Wait-Blocked"><a href="#等待-睡眠-阻塞状态-Wait-Blocked" class="headerlink" title="等待/睡眠/阻塞状态(Wait/Blocked)"></a>等待/睡眠/阻塞状态(Wait/Blocked)</h3><p>若一进程正在等待某一事件发生（如等待输入输出工作完成），这时，<strong>即使给它CPU，它也无法运行，称该进程处于等待状态（阻塞、 睡眠、封锁状态）。</strong></p>
<p>  阻塞队列：根据阻塞原因可以设置多个队列。</p>
<p><img src="./Operating System-process/image-20241018212836219.png" alt="image-20241018212836219" style="zoom:50%;" /></p>
<h2 id="新建状态、完成-终止-结束状态"><a href="#新建状态、完成-终止-结束状态" class="headerlink" title="新建状态、完成/终止/结束状态"></a>新建状态、完成/终止/结束状态</h2><p>运行、就绪、阻塞是进程的三个基本状态，而操作系统的规模和设计目的不同，在有些系统中，还增加了两个基本状态，新建状态、完成状态/终止状态/结束状态，这两个状态对进程管理是非常有用的。 </p>
<h3 id="新建状态"><a href="#新建状态" class="headerlink" title="新建状态"></a>新建状态</h3><p>对应于刚刚定义的进程，还<strong>未进入就绪队列的状态</strong>，此时系统未将进程全部工作完成（如内存尚待分配等）。如果一个新用户试图登陆到分时系统，新的批处理作业被选中准备投入内存；只有进程代码和数据进入内存，才进入就绪队列。</p>
<h3 id="完成状态"><a href="#完成状态" class="headerlink" title="完成状态"></a>完成状态</h3><p>指<strong>进程正常，或非正常结束而终止的状态</strong>。处于该状态的进程还未从系统中消失，可能由于一些善后工作尚未完成（如记帐，未完成的输出等）。但<strong>处于完成状态的进程以后不再被调度执行</strong>。</p>
<h2 id="五状态的进程状态关系转换"><a href="#五状态的进程状态关系转换" class="headerlink" title="五状态的进程状态关系转换"></a>五状态的进程状态关系转换</h2><p>含有五个状态的进程状态转换关系如下：</p>
<img src="/2024/10/18/Operating%20System-process/image-20241020094626532.png" class="" alt="image-20241020094626532">
<h3 id="空→新建"><a href="#空→新建" class="headerlink" title="空→新建"></a>空→新建</h3><p>通常有四个事件可能导致创建一个新进程：</p>
<img src="/2024/10/18/Operating%20System-process/image-20241020094857058.png" class="" alt="导致进程创建的原因">
<p>接着，”就绪”和”进程优先数”会被写入。</p>
<img src="/2024/10/18/Operating%20System-process/1729389414997.jpg" class="" alt="1729389414997">
<h3 id="新建→就绪"><a href="#新建→就绪" class="headerlink" title="新建→就绪"></a>新建→就绪</h3><p>操作系统接纳一个进程时，将<strong>新建状态</strong>修改为<strong>就绪状态</strong>。</p>
<h3 id="就绪→运行"><a href="#就绪→运行" class="headerlink" title="就绪→运行"></a>就绪→运行</h3><p>从就绪队列选择一个进程占用处理机,将<strong>就绪态</strong>改为<strong>运行态</strong></p>
<h3 id="运行→就绪"><a href="#运行→就绪" class="headerlink" title="运行→就绪"></a>运行→就绪</h3><p>通常原因是正在运行进程时间片到，从<strong>运行态</strong>进入<strong>就绪态</strong></p>
<h3 id="运行→阻塞"><a href="#运行→阻塞" class="headerlink" title="运行→阻塞"></a>运行→阻塞</h3><p>若当前进程所请求事件，或条件未能得到满足，则进入<strong>阻塞态</strong>。由<strong>运行</strong>进入<strong>阻塞态</strong>原因可能很多 </p>
<h3 id="阻塞→就绪"><a href="#阻塞→就绪" class="headerlink" title="阻塞→就绪"></a>阻塞→就绪</h3><p>系统内发生事件时，根据事件原因查找阻塞队列中的进程，查到，将<strong>阻塞态</strong>转换为<strong>就绪态</strong>。 </p>
<h3 id="运行→完成"><a href="#运行→完成" class="headerlink" title="运行→完成"></a>运行→完成</h3><p>任务执行完成，或由于其它原因无法继续运行，系统将当前进程从<strong>运行态</strong>转变为<strong>完成状态</strong>。    </p>
<p>系统设置多少状态与系统对进程管理方式有关，也与系统资源利用有关，但要注意，<strong>系统中设置过多状态会造成系统参数和状态转换过程增加。</strong></p>
<p><strong>进程在生存期间</strong>，可以多次地从一个<strong>状态转换到另一个状态</strong>，即多次地处于<strong>运行状态</strong>、<strong>就绪状态</strong>、<strong>阻塞状态</strong>，反映了并发程序“<strong>走走停停</strong>”的运行轨迹。进程不断地从一个状态转换到另一个状态是有条件，或原因的。这些状态随着进程的执行和外界条件发生变化而转换。事实上，进程的状态转换是一个非常复杂的过程。从一个状态到另一个状态的转换除了不同的控制过程，有时还要借助于硬件才能完成 。</p>
<h2 id="进程的挂起状态"><a href="#进程的挂起状态" class="headerlink" title="进程的挂起状态"></a>进程的挂起状态</h2><p><strong>三个基本状态提供了构造进程活动和模型的系统方法</strong>，并指导操作系统设计与实现。但这种系统不充分；</p>
<p><strong>一方面</strong>，处理机、内存等系统硬件资源的利用率得不到充分发挥。</p>
<p><strong>另一方面</strong>，处在活动空间进程可能由于某原因暂时静止下来，不处于活动，但也不从系统中彻底退出，这就导致<strong>三种状态模型扩充</strong>，引入挂起状态。 </p>
<p>挂起状态是为了解决内存不够的问题，进程被挂起后，就转移到了外存中，挂起是一种被动的行为。</p>
<img src="/2024/10/18/Operating%20System-process/image-20241020100947885.png" class="" alt="image-20241020100947885">
<h3 id="新建→静止就绪"><a href="#新建→静止就绪" class="headerlink" title="新建→静止就绪"></a>新建→静止就绪</h3><p>创建一个新进程可以进入静止就绪队列。系统初始执行期间，操作系统倾向建立更多就绪进程维护大量未被阻塞进程。这样使以后新进程由于主存空间不足而无法进入，这时就使用新建 →静止就绪<strong>。</strong> </p>
<h3 id="静止就绪→活动就绪"><a href="#静止就绪→活动就绪" class="headerlink" title="静止就绪→活动就绪"></a>静止就绪→活动就绪</h3><p>若主存中没有就绪进程，一般操作系统需要调入一个进程。而当处于静止就绪状态的进程的优先级高于就绪进程的优先级时，操作系统则往往将处于静止就绪进程通过激活而将其转换为就绪状态。 </p>
<h3 id="活动就绪→静止就绪"><a href="#活动就绪→静止就绪" class="headerlink" title="活动就绪→静止就绪"></a>活动就绪→静止就绪</h3><p>通常，操作系统倾向挂起阻塞态进程。但有两种情况需要这种转换；一是得到主存更大空间唯一方法是挂起一个就绪进程；二是如果能够确定处于高优先级阻塞状态进程可以很快进入就绪状态。</p>
<h3 id="静止阻塞→静止就绪"><a href="#静止阻塞→静止就绪" class="headerlink" title="静止阻塞→静止就绪"></a>静止阻塞→静止就绪</h3><p>同基本状态转换一样，如果等待的事件发生了，则将处于静止阻塞的进程修改为静止就绪状态。</p>
<h3 id="活动阻塞→静止阻塞"><a href="#活动阻塞→静止阻塞" class="headerlink" title="活动阻塞→静止阻塞"></a>活动阻塞→静止阻塞</h3><p>若当前系统中没有就绪态进程，就将处于阻塞态进程至少挂起一个，而进入静止阻塞状态，为没有被阻塞的进程让出主存空间。</p>
<p>若操作系统确定当前正在运行进程，或就绪态进程为维护基本性能要求而需要更大内存空间，则既使存在可运行状态就绪进程也可能出现这样状态转换而被挂起进入静止阻塞。</p>
<h3 id="静止阻塞→活动阻塞"><a href="#静止阻塞→活动阻塞" class="headerlink" title="静止阻塞→活动阻塞"></a>静止阻塞→活动阻塞</h3><p>这种情况较少发生。如果一个进程处于阻塞，又不在主存,调入它进入主存似乎意义不大。但运行进程执行完，发现静止阻塞队列存在优先级较高者时.</p>
<h3 id="各种状态→完成"><a href="#各种状态→完成" class="headerlink" title="各种状态→完成"></a>各种状态→完成</h3><p>在正常情况下，一个运行进程<strong>正常，或非正常结束，都进入完成状态</strong>。但如表5.2所列出进程终止事件，如果<strong>父进程终止，或被创建它的进程终止</strong>，则一个进程可以在<strong>任何状态下终止而进入完成状态</strong>。 </p>
<h1 id="进程控制块-Process-Control-Block"><a href="#进程控制块-Process-Control-Block" class="headerlink" title="进程控制块(Process Control Block)"></a>进程控制块(<strong>Process Control Block</strong>)</h1><p>•<strong>为了描述一个进程和其它进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，采用了一个与进程相联系的数据结构，称为进程控制块（**</strong>PCB）。**</p>
<p>•<strong>PCB**</strong>是<strong>OS</strong>中最重要的记录型数据结构。**</p>
<h2 id="PCB-作用"><a href="#PCB-作用" class="headerlink" title="PCB 作用"></a>PCB 作用</h2><ul>
<li><p><strong>作用是将一个不能独立运行的程序变成一个可以独立运行的基本单位，一个能与其他进程并发执行的进程。</strong></p>
</li>
<li><p>OS利用<strong>PCB</strong>来对并发执行的进程进行控制和管理，<strong>PCB是OS感知进程存在的唯一标志。</strong></p>
</li>
<li><p>进程与<strong>PCB</strong>是<strong>一一对应</strong>的。</p>
</li>
<li><p><strong>PCB随进程创建而建立，随进程结束而回收。</strong></p>
</li>
<li><p><strong>PCB</strong>应常驻内存。</p>
</li>
</ul>
<h2 id="PCB的内容"><a href="#PCB的内容" class="headerlink" title="PCB的内容"></a>PCB的内容</h2><p>有下列信息</p>
<ul>
<li><p><strong><font color="#eb507e">进程描述信息</font></strong></p>
<ul>
<li><strong>进程标识符(process ID)</strong>,唯一，通常是一个整数。</li>
<li><strong>进程名</strong>:通常基于可执行文件名(不唯一)</li>
<li><strong>用户标识符(user ID)</strong>:进程组关系</li>
</ul>
</li>
<li><p><strong><font color="#eb507e">进程控制信息</font></strong></p>
<ul>
<li><strong>当前状态</strong></li>
<li><strong>优先级(priority)</strong></li>
<li><strong>代码的执行入口地址</strong></li>
<li><strong>程序的外存地址</strong></li>
<li><strong>运行统计信息(执行时间、页面调度)</strong></li>
<li><strong>进程间同步和通信；阻塞原因</strong></li>
<li><strong>进程的队列指针</strong></li>
<li><strong>进程的消息队列指针</strong></li>
</ul>
</li>
<li><p><strong><font color="#eb507e">所拥有的资源和使用情况</font></strong></p>
<ul>
<li><strong>虚拟地址空间的现状</strong></li>
<li><strong>打开文件列表</strong></li>
</ul>
</li>
<li><p><strong><font color="#eb507e">CPU 现场保护信息</font></strong></p>
<ul>
<li><p><strong>寄存器值（通用、程序计数器PC、状态字PSW、地址包括栈指针）</strong></p>
</li>
<li><p>指向赋予该进程的段/页表的指针。</p>
</li>
</ul>
</li>
</ul>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>进程控制指对系统中的所有进程实施管理。</p>
<p> 如：</p>
<ul>
<li><p>创建一个新进程；</p>
</li>
<li><p>终止一个已完成的进程；</p>
</li>
<li><p>终止一个因出现某事件而使其无法运行下去的进程；</p>
</li>
<li><p>进程运行中状态的转换</p>
</li>
</ul>
<p>进程控制一般由<strong>OS的内核</strong>来实现。</p>
<h2 id="OS的内核"><a href="#OS的内核" class="headerlink" title="OS的内核"></a>OS的内核</h2><p>通常将<strong>OS</strong>中一些<strong>与硬件紧密相关的模块</strong>（如：中断处理程序；各种常用设备的驱动程序）以及运行频率较高的模块（时钟管理、进程调度以及许多模块公用的一些基本操作）都安排在紧靠硬件的软件层次中，并使它们<strong>常驻内存，以提高OS的运行效率，并对它们加以特殊的保护。这部分就是OS的内核。</strong></p>
<h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><p><strong>原语</strong>：由多条指令组成，是一种特殊的系统功能调用，它可以完成一个特定的功能。</p>
<p>原语的特点：</p>
<ul>
<li><p><strong>执行时不可中断</strong></p>
</li>
<li><p><strong>不可并发</strong></p>
</li>
<li><p><strong>在管态下执行，常驻内存</strong></p>
<h3 id="常用的进程控制原语"><a href="#常用的进程控制原语" class="headerlink" title="常用的进程控制原语"></a>常用的进程控制原语</h3><ul>
<li>创建原语 Create</li>
<li>终止原语Destory</li>
<li>阻塞原语Block，唤醒原语Wakeup</li>
<li>挂起原语Suspend、激活原语Active</li>
</ul>
</li>
</ul>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>1.申请空白PCB</p>
<p>2.为新进程分配资源 如内存</p>
<p>3.初始化进程控制块 </p>
<p>4.将新进程插入就绪队列 </p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Create</span><span class="params">(n,S0,P0,M0,R0,acc)</span> &#123;     </span><br><span class="line">    i=getinternal_name(n);   </span><br><span class="line">    id(i)=n;</span><br><span class="line">    priority(i)=P0;    </span><br><span class="line">    cpupstate(i)=S0; </span><br><span class="line">    main_store(i)=M0;  </span><br><span class="line">    resources(i)=R0; </span><br><span class="line">    status(i)=“readys”;  </span><br><span class="line">    sdata(i)=RL; </span><br><span class="line">    parent(i)=*;  </span><br><span class="line">    progeny(i)=<span class="literal">NULL</span>; </span><br><span class="line">    insert(progeny(*),i); </span><br><span class="line">    <span class="built_in">set</span> accounting data;  </span><br><span class="line">    insert(RL,i);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><ul>
<li><p>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB； </p>
</li>
<li><p>若被终止进程处于执行状态，应立即终止执行，并置调度标志为真，调度其他进程；</p>
</li>
<li><p>结束该进程所有子孙进程的执行，以防止成为不可控进程；</p>
</li>
<li><p>将进程所拥有的资源交给父进程或系统进程； 释放PCB 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(n)</span> &#123; </span><br><span class="line">    sched=<span class="literal">false</span>;</span><br><span class="line">    i=getinternal name(n);</span><br><span class="line">    kill(i);</span><br><span class="line">    <span class="keyword">if</span> sched then scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Void <span class="title function_">kill</span><span class="params">(i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">status</span><span class="params">(i)</span>=“executing” then&#123;</span><br><span class="line">        stop(i);   sched=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   remove(sdata(i),i);</span><br><span class="line">   <span class="keyword">for</span> all s∈progeny(i)</span><br><span class="line">       <span class="keyword">do</span> <span class="title function_">kill</span><span class="params">(s)</span>;</span><br><span class="line">   <span class="keyword">for</span> all r∈(main store(i)∪resources(i)) <span class="keyword">do</span>     <span class="comment">//资源归还给父进程</span></span><br><span class="line">       <span class="keyword">if</span> <span class="title function_">owned</span><span class="params">(r)</span> then <span class="title function_">insert</span><span class="params">(avail(semaphore(r)),data(r))</span>;</span><br><span class="line">   <span class="keyword">for</span> all r∈created <span class="title function_">resources</span><span class="params">(i)</span> <span class="keyword">do</span>             <span class="comment">//资源归还给系统</span></span><br><span class="line">       remove resource <span class="title function_">descriptor</span><span class="params">(r)</span>;</span><br><span class="line">   remove <span class="title function_">PCB</span><span class="params">(i)</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>阻塞：当一个进程所期待的某一事件尚未出现时，该进程调用阻塞原语将自己阻塞。</p>
<p>  <strong>进程阻塞是进程自身的一种主动行为。</strong></p>
<p>步骤如下：</p>
<ul>
<li><p><strong>1.停止运行</strong></p>
</li>
<li><p><strong>2.转变状态</strong></p>
</li>
<li><p><strong>3.插入相应事件队列</strong></p>
</li>
<li><p><strong>4.重新调度</strong></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">block</span><span class="params">(n)</span></span><br><span class="line">&#123;   i=getinternal name(n);</span><br><span class="line">     stop(i);</span><br><span class="line">     status(i)=“blockeda”;</span><br><span class="line">     insert(WL(r),i);</span><br><span class="line">     scheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="进程的唤醒"><a href="#进程的唤醒" class="headerlink" title="进程的唤醒"></a>进程的唤醒</h2></li>
</ul>
<p>唤醒：<strong>处于阻塞状态的进程是绝不可能叫醒它自己的，必须由它的合作进程用唤醒原语唤醒它。</strong></p>
<p>步骤如下：</p>
<ul>
<li><strong>1.移出阻塞队列</strong></li>
<li><strong>2.转变状态</strong></li>
<li><strong>3.插入就绪队列</strong></li>
<li><strong>4.重新调度</strong></li>
</ul>
<h2 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h2><ul>
<li><strong>1.检查/转换状态</strong></li>
<li><strong>2.复制PCB到指定内存</strong></li>
<li><strong>3.变活动就绪时，重新调度</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">suspend</span><span class="params">(n,a)</span></span><br><span class="line">&#123;   i=getinternal name(n);</span><br><span class="line">     s=status(i);</span><br><span class="line">     <span class="keyword">if</span> s=“executing” then stop(i);</span><br><span class="line">     a=copyPCB(i);</span><br><span class="line">      status(i)=(s= =“blockeda”)? “blockeds”: “readys”;</span><br><span class="line">     <span class="keyword">if</span> s=“executing” then  scheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h2><ul>
<li><strong>1.检查/转换状态</strong></li>
<li><strong>2.变活动就绪时，重新调度</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activate</span><span class="params">(n)</span>&#123; </span><br><span class="line">    i=getinternal name(n);</span><br><span class="line">     status(i)=(s= =“readys”)? “readya”: “blockeda”;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">status</span><span class="params">(i)</span>=“readya” then  scheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Operating System-Old knowledge</title>
    <url>/2024/10/09/Operating%20System-Old%20knowledge/</url>
    <content><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="十进制-→-二进制"><a href="#十进制-→-二进制" class="headerlink" title="十进制  → 二进制"></a>十进制  → 二进制</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>除二取余，每次除法的商和余数放到同一行，直到商为 $0$ 停止，此时把所有的数字（包含最后的商为 $0$ 产生的余数），从下往上排列，即可。</p>
<img src="/2024/10/09/Operating%20System-Old%20knowledge/image-20241009190729837.png" class="" alt="image-20241009190729837">
<h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><p>乘二取整，每次除法的积和积的整数放到同一行，直到某次运算得到的小数部分为 $0$ 停止，此时把所有的数字（包含最后的小数为 $0$ 的整数），从上忘下排列，最后加上小数点即可。</p>
<img src="/2024/10/09/Operating%20System-Old%20knowledge/image-20241009191055146.png" class="" alt="image-20241009191055146">
<h1 id="原码、反码、补码、移码"><a href="#原码、反码、补码、移码" class="headerlink" title="原码、反码、补码、移码"></a>原码、反码、补码、移码</h1><p>原码、反码和补码这三个概念主要是针对<strong>有符号数</strong>（signed numbers）而言的。</p>
<p>原码表示法中，规定整数的符号位和数值位之间用逗号(，)隔开，小数的符号位和数值位之间用点号(.)隔开</p>
<ul>
<li><p>对于正数来说，<strong>原码$=$反码$=$补码</strong></p>
</li>
<li><p>对于负数来说，反码$=$原码除符号位各位取反，补码$=$反码$+1$，所以负数的原码、反码、补码的符号位都是 $1$</p>
</li>
</ul>
<p>例子</p>
<p>在 $8$ 位寄存器中，</p>
<ul>
<li><p>无符号数，可以表示从 $0$ 到 $+127$ 的整数。</p>
</li>
<li><p>用原码表示，最高位为符号位，则可以表示从 $-127$ 到 $+127$ 的整数，其中 $0$ 有两种表示方法：$[+0]<em>原=0,0000000$ ，$[-0]</em>原=1,0000000$</p>
</li>
<li>用反码表示，最高位为符号位，则可以表示从 $-127$ 到 $+127$ 的整数，其中 $0$ 有两种表示方法：$[+0]<em>反=0,0000000$ ，$[-0]</em>反=1,1111111$</li>
<li>用补码表述，最高位为符号位，则可以表示从 $-128$ 到 $+127$ 的整数，比原码多了一个。<ul>
<li>其中 $0$ 只有一种表示方法，$[+0]<em>补=[-0]</em>补=0,0000000$;</li>
<li>$[-128]<em>补=1,0000000$ ,是从 $[-0]</em>原=0,0000000$ 转换过来，如果对 $[-128]<em>补$ 再次求补，会得到$[-0]</em>原$</li>
</ul>
</li>
</ul>
<p>移码是为了便于比较，将每一个正值加上 $2^n$ ,其中 $n$ 为整数的位数，就得到了移码。</p>
<p>移码可以快速计算，计算出来正值的补码之后，将补码的符号位取反就可以得到移码。</p>
<h1 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h1><p>小数点固定在某一位置的数被称为定点数。</p>
<ul>
<li><p>当小数点位于数符和第一数值位之间，表示的是纯小数；</p>
</li>
<li><p>当小数点位于数值位之后，表示的是纯整数。</p>
</li>
</ul>
<p>当机器处理的数不是纯小数或者纯整数的时候，必须乘以一个“比例因子”，以避免溢出。</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数通常被表示为</p>
<script type="math/tex; mode=display">
N=S\times r^j</script><p>其中， $N$ 是要表示的数， $S$ 是尾数（可正可负）， $j$ 是阶码（可正可负），$r$ 是基数，可以取 $2，4，8，16,\cdots$</p>
<img src="/2024/10/09/Operating%20System-Old%20knowledge/d920313c565a5e5905da6c1ec0cf0ee.jpg" class="" alt="计算机组成原理-唐朔飞">
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System-操作系统的硬件环境</title>
    <url>/2024/10/14/Operating%20System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="8086处理器的结构"><a href="#8086处理器的结构" class="headerlink" title="8086处理器的结构"></a>8086处理器的结构</h1><p>8086处理器内部结构有两个功能模块，完成一条指令的取值和执行：</p>
<ul>
<li>总线接口单元BIU，主要负责读取指令和操作数；</li>
<li>执行单元EU，主要负责指令译码和执行。</li>
</ul>
<h2 id="8086处理器的寄存器："><a href="#8086处理器的寄存器：" class="headerlink" title="8086处理器的寄存器："></a>8086处理器的寄存器：</h2><ul>
<li><p>8个通用寄存器（以16位为例）</p>
<ul>
<li><p>数据寄存器</p>
<ul>
<li><p>AX:累加器(Accumulate Rerister)，使用频度最高，用于算术、逻辑运算以及与外设传送信息等；</p>
</li>
<li><p>BX:基址寄存器(Base Rerister)，常用做存放存储器地址；</p>
</li>
<li>CX:计数器(Counter Rerister)，作为循环和串操作等指令中的隐含计数器；</li>
<li>DX:数据寄存器(Data Rerister)，常用来存放双字长数据的高16位，或存放外设端口地址。</li>
</ul>
</li>
<li><p>变址寄存器（常用于存储器寻址时提供地址）</p>
<ul>
<li>SI:源变址寄存器 (Source index)</li>
<li>DI:目的变址寄存器(Destination index)</li>
</ul>
</li>
<li><p>指针寄存器(用于寻址内存堆栈内的数据)</p>
</li>
</ul>
</li>
</ul>
<pre><code>- SP:堆栈指针寄存器(Stack Pointer)，指示栈顶的偏移地址
- BP:基址指针寄存器(Base Pointer)，表示数据在堆栈段中的基地址
SP和BP寄存器与SS段寄存器联合使用以确定堆栈段中的存储单元地址
</code></pre><ul>
<li><p>1个指令指针寄存器</p>
<p>指令指针寄存器IP，指示代码段中指令的偏移地址。它与代码段寄存器CS联用，确定下一条指令的物理地址</p>
<p>计算机通过CS : IP寄存器来控制指令序列的执行流程</p>
<p>IP寄存器是一个专用寄存器</p>
</li>
<li><p>1个标志寄存器</p>
<p>标志（Flag）用于反映指令执行结果或控制指令执行形式</p>
<p>8086处理器的各种标志形成了一个16位的标志寄存器FLAGS（程序状态字PSW寄存器）</p>
<p>程序设计需要利用标志的状态,比如C语言里的条件语句，if (a=b) {…}</p>
</li>
<li><p>1个段寄存器</p>
</li>
</ul>
<ul>
<li><p>32位通用寄存器</p>
<p> EAX  EBX  ECX  EDX</p>
<p> ESI   EDI   EBP  ESP</p>
</li>
</ul>
<h2 id="标志的分类："><a href="#标志的分类：" class="headerlink" title="标志的分类："></a>标志的分类：</h2><ul>
<li><p>状态标志</p>
<p>用来记录程序运行结果的状态信息，许多指令的执行都将相应地设置它</p>
<ul>
<li><p>CF 对于无符号数运算，当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF = 1；否则CF = 0。Debug表示: CY(Carry) CF = 1; NC(No Carry) CF = 0</p>
</li>
<li><p>ZF若运算结果为0，则ZF = 1；否则ZF = 0.Debug表示: ZR(Zero) ZF = 1; NZ(No Zero) ZF = 0</p>
</li>
<li><p>SF 运算结果最高位为1，则SF = 1；否则SF = 0.Debug表示: NG(Negative) SF = 1; PL(Plus) SF = 0</p>
</li>
<li><p>PF</p>
</li>
<li><p>OF 对于有符号数运算,若算术运算的结果有溢出，则OF＝1；否则 OF＝0</p>
<p>Debug表示: OV(Overflow) OF = 1; NV(No Overflow) OF = 0</p>
</li>
<li><p>AF</p>
</li>
</ul>
</li>
<li><p>控制标志</p>
<p>可由程序根据需要用指令设置，用于控制处理器执行指令的方式</p>
<ul>
<li>DF</li>
<li>IF</li>
<li>TF</li>
</ul>
<p>Debug中对标志位不同状态的表示：</p>
<p>NV  UP  DI  PL  NZ NA  PO  NC      状态为 0</p>
<p>OV  DN  EI  NG ZR AC  PE  CY      状态为 1</p>
</li>
</ul>
<h2 id="CPU五类指令"><a href="#CPU五类指令" class="headerlink" title="CPU五类指令:"></a>CPU五类指令:</h2><ul>
<li>访问存储器指令</li>
</ul>
<p>​    处理器和存储器间数据传送</p>
<ul>
<li><p>I/O指令</p>
<p>处理器和I/O模块间数据传送和命令发送</p>
</li>
<li><p>算数逻辑指令</p>
<p>执行数据算数和逻辑操作</p>
</li>
<li><p>控制转移指令</p>
<p>指定一个新的指令的执行起点</p>
</li>
<li><p>处理器控制指令</p>
<p>修改处理器状态，该边处理器工作方式。</p>
</li>
</ul>
<p>数据信息的表达单位：</p>
<ul>
<li>二进制位bit:存储一位二进制数，0或者1</li>
<li>字节Byte：8个二进制位，D7～D0</li>
<li>字Word：16位，2个字节，D15～D0</li>
<li>双字DWord：32位，4个字节，D31～D0</li>
</ul>
<h1 id="8086的寻址（数据存取）方式"><a href="#8086的寻址（数据存取）方式" class="headerlink" title="8086的寻址（数据存取）方式"></a>8086的寻址（数据存取）方式</h1><h2 id="立即数寻址方式"><a href="#立即数寻址方式" class="headerlink" title="立即数寻址方式"></a>立即数寻址方式</h2><p>指令中的操作数直接存放在机器代码中，紧跟在操作码之后（操作数作为指令的一部分存放在操作码之后的主存单元中）</p>
<p>这种操作数被称为立即数imm</p>
<p>它可以是8位数值i8（00H～FFH）</p>
<p>也可以是16位数值i16（0000H～FFFFH）</p>
<p>立即数寻址方式常用来给寄存器赋值</p>
<h2 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h2><p>操作数存放在CPU的内部寄存器reg中，可以是：</p>
<p>8位寄存器r8：</p>
<p>AH、AL、BH、BL、CH、CL、DH、DL</p>
<p>16位寄存器r16：</p>
<p>AX、BX、CX、DX、SI、DI、BP、SP</p>
<p>4个段寄存器seg：</p>
<p>CS、DS、SS、ES</p>
<h2 id="存储器寻址方式"><a href="#存储器寻址方式" class="headerlink" title="存储器寻址方式"></a>存储器寻址方式</h2><p>指令中给出操作数的主存地址信息（偏移地址，称之为有效地址EA），而段地址在默认的或用段超越前缀指定的段寄存器中</p>
<p>8086设计了多种存储器寻址方式</p>
<h3 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h3><p>有效地址在指令中直接给出</p>
<p>默认的段地址在DS段寄存器，可使用段超越前缀改变</p>
<p>MOV AX,[2000H]</p>
<p>；AX←DS:[2000H]</p>
<p>；指令代码：A10020</p>
<p>MOV AX,ES:[2000H]</p>
<p>；AX←ES:[2000H]</p>
<p>；指令代码：26A10020</p>
<h3 id="寄存器间接寻址方式"><a href="#寄存器间接寻址方式" class="headerlink" title="寄存器间接寻址方式"></a>寄存器间接寻址方式</h3><p>有效地址存放在基址寄存器BX或变址寄存器SI、DI中</p>
<p>默认的段地址在DS段寄存器，可使用段超越前缀改变</p>
<p>MOV AX,[SI] ；AX←DS:[SI]</p>
<h3 id="寄存器相对寻址方式"><a href="#寄存器相对寻址方式" class="headerlink" title="寄存器相对寻址方式"></a>寄存器相对寻址方式</h3><p>有效地址是寄存器内容与有符号8位或16位位移量之和，寄存器可以是BX、BP或SI、DI</p>
<p>有效地址＝BX/BP/SI/DI＋8/16位位移量</p>
<p>段地址对应BX/SI/DI寄存器默认是DS，对应BP寄存器默认是SS；可用段超越前缀改变.</p>
<h4 id="寄存器相对寻址指令"><a href="#寄存器相对寻址指令" class="headerlink" title="寄存器相对寻址指令"></a>寄存器相对寻址指令</h4><p>MOV AX,[DI+06H]</p>
<p> ；AX←DS:[DI+06H]</p>
<p>MOV AX,[BP+06H]</p>
<p> ；AX←SS:[BP+06H]</p>
<h3 id="基址变址寻址方式"><a href="#基址变址寻址方式" class="headerlink" title="基址变址寻址方式"></a>基址变址寻址方式</h3><p>有效地址由基址寄存器（BX或BP）的内容加上变址寄存器（SI或DI）的内容构成：</p>
<p>有效地址＝BX/BP＋SI/DI</p>
<p>段地址对应BX基址寄存器默认是DS，对应BP基址寄存器默认是SS；可用段超越前缀改变</p>
<h3 id="相对基址变址寻址方式"><a href="#相对基址变址寻址方式" class="headerlink" title="相对基址变址寻址方式"></a>相对基址变址寻址方式</h3><p>有效地址是基址寄存器（BX/BP）、变址寄存器（SI/DI）与一个8位或16位位移量之和：</p>
<p>有效地址＝BX/BP＋SI/DI＋8/16位位移量</p>
<p>段地址对应BX基址寄存器默认是DS，对应BP基址寄存器默认是SS；可用段超越前缀改变</p>
<h4 id="相对基址变址寻址指令"><a href="#相对基址变址寻址指令" class="headerlink" title="相对基址变址寻址指令"></a>相对基址变址寻址指令</h4><p>MOV AX,[BX+SI+06H]</p>
<p>；AX←DS:[BX+SI+06H]</p>
<h1 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h1><p>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序。</p>
<p>特点：</p>
<p>1) 中断是随机的<br>2) 中断是可恢复的<br>3) 中断是自动处理的</p>
<p>引入中断的目的：</p>
<p>解决主机与外设的并行工作问题</p>
<p>实现实时控制</p>
<h1 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h1><p>I/O控制使用下面几种技术：</p>
<p>程序控制</p>
<p>中断驱动</p>
<p>直接存储器存取（DMA）</p>
<p>通道</p>
<h2 id="程序控制I-O技术"><a href="#程序控制I-O技术" class="headerlink" title="程序控制I/O技术"></a>程序控制I/O技术</h2><p>由处理器提供I/O相关指令来实现</p>
<ul>
<li><p>I/O处理单元处理请求并设置I/O状态寄存器相关位</p>
</li>
<li><p>不中断处理器，也不给处理器警告信息</p>
</li>
<li><p>处理器定期轮询I/O单元的状态，直到处理完毕</p>
</li>
</ul>
<p>I/O软件包含直接操纵I/O的指令</p>
<ul>
<li><p>控制指令: 用于激活外设，并告诉它做什么</p>
</li>
<li><p>状态指令: 用于测试I/O控制中的各种状态和条件</p>
</li>
<li><p>数据传送指令: 用于在设备和主存之间来回传送数据</p>
</li>
</ul>
<p>主要缺陷：处理器必须关注I/O处理单元的状态，因而耗费大量时间轮询信息，严重地降低了系统性能</p>
<h2 id="中断驱动I-O技术"><a href="#中断驱动I-O技术" class="headerlink" title="中断驱动I/O技术"></a>中断驱动I/O技术</h2><p>为了解决程序控制I/O方法的主要问题</p>
<ul>
<li><p>应该让处理器从轮询任务中解放出来</p>
</li>
<li><p>使I/O操作和指令执行并行起来</p>
</li>
</ul>
<p>具体作法：</p>
<ul>
<li><p>当I/O处理单元准备好与设备交互的时候</p>
</li>
<li><p>通过物理信号通知处理器，即中断处理器的执行</p>
</li>
</ul>
<h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>中断的引入大大地提高了处理器处理I/O的效率，但是当处理器和I/O间传送数据时，效率仍旧不高。</p>
<p>解决方法：</p>
<p>——直接存储器访问（DMA：Direct Memory Access）</p>
<p>通过系统总线中一独立控制单元——DMA控制器，自动控制成块数据在内存和I/O单元间的传送。</p>
<p>大大提高处理I/O的效能。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>通道又称为I/O处理机，独立于中央处理器，是专门负责数据I/O传输的处理机。</p>
<ul>
<li><p>它对外设实现统一管理</p>
</li>
<li><p>代替CPU对I/O操作进行控制</p>
</li>
<li><p>使CPU和外设可以并行工作</p>
</li>
</ul>
<p>引入通道的目的:</p>
<ul>
<li><p>为了使CPU从I/O事务中解脱出来</p>
</li>
<li><p>同时为了提高CPU/设备、设备/设备之间的并行度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System-Process synchronization</title>
    <url>/2024/11/05/Operating%20System-Process%20synchronization/</url>
    <content><![CDATA[<h1 id="进程同步的概念及其术语"><a href="#进程同步的概念及其术语" class="headerlink" title="进程同步的概念及其术语"></a>进程同步的概念及其术语</h1><h2 id="进程间两种形式的制约关系"><a href="#进程间两种形式的制约关系" class="headerlink" title="进程间两种形式的制约关系"></a>进程间两种形式的制约关系</h2><h3 id="直接制约关系"><a href="#直接制约关系" class="headerlink" title="直接制约关系"></a>直接制约关系</h3><p>进程间的相互联系是有意识的安排的。</p>
<h3 id="间接制约关系"><a href="#间接制约关系" class="headerlink" title="间接制约关系"></a>间接制约关系</h3><p>进程间要通过某种中介发生联系，是无意识安排的。</p>
<h2 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h2><p>一般来说，一个进程相对另一个进程的运行速度是不确定的。也就是说，进程之间是在异步环境下运行的，每个进程都以各自独立的、不可预知的速度向运行的终点推进。<br>但是，相互合作的几个进程需要在某些确定点上协调其工作。一个进程到达了这些点后，除非另一进程已完成了某些操作，否则就不得不停下来等待这些操作的结束。<br>所谓进程同步是指<strong>多个相互合作的进程，在一些关键点上可能需要互相等待或互相交换信息</strong>，这种相互制约关系称为<strong>进程同步</strong>。</p>
<h2 id="进程的互斥"><a href="#进程的互斥" class="headerlink" title="进程的互斥"></a>进程的互斥</h2><p>由于各进程要求共享资源，而有些资源需要互斥使用，因此各<strong>进程间竞争使用这些资源，进程的这种关系为进程的互斥。</strong><br>其实<strong>互斥是进程同步的一种特殊情况</strong>，互斥也是为了达到让进程之间协调推进的目的。</p>
<h2 id="临界区和临界资源"><a href="#临界区和临界资源" class="headerlink" title="临界区和临界资源"></a>临界区和临界资源</h2><p>系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量。</p>
<p>在进程中涉及到临界资源的程序段叫<strong>临界区</strong></p>
<p>多个进程的临界区称为<strong>相关临界区</strong></p>
<p>进程须在临界区前面增加一段用于进行上述检查的代码，称为进入区(entry section)。在临界区后面加上一段称为退出区(exit section)的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While (1)</span><br><span class="line">&#123;</span><br><span class="line">   进入区代码;</span><br><span class="line">   临界区代码;</span><br><span class="line">   退出区代码;</span><br><span class="line">   其余代码 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="互斥区原则"><a href="#互斥区原则" class="headerlink" title="互斥区原则"></a>互斥区原则</h2><ul>
<li><strong>空闲让进</strong>:当无进程在互斥区时，任何有权使用互斥区的进程可进入</li>
<li><strong>忙则等待</strong>:不允许两个以上的进程同时进入互斥区</li>
<li><strong>有限等待</strong>:任何进入互斥区的要求应在有限的时间内得到满足</li>
<li><strong>让权等待</strong>:处于等待状态的进程应放弃占用CPU,以使其他进程有机会得到CPU的使用权</li>
</ul>
<h1 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h1><ul>
<li><strong>硬件方法 </strong>：中断禁用</li>
<li><strong>软件方法</strong>:<ul>
<li>锁变量</li>
<li>严格轮换法</li>
<li>Peterson方法</li>
</ul>
</li>
</ul>
<h2 id="硬件方法-：中断禁用"><a href="#硬件方法-：中断禁用" class="headerlink" title="硬件方法 ：中断禁用"></a><strong>硬件方法 </strong>：中断禁用</h2><p>为保证互斥，只需保证进程不被中断就可以了，通过系统内核为启用中断和禁用中断定义的原语实现。进程结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While(true)</span><br><span class="line"> &#123; </span><br><span class="line">    禁用中断;     </span><br><span class="line">    临界区; </span><br><span class="line">    启用中断; </span><br><span class="line">    其余部分;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方案并不好，因为把屏蔽中断的权力交给用户进程是不明智的。设想一下，<strong>若一个进程屏蔽中断后不再打开中断，其结果将会如何？整个系统可能会因此终止。</strong></p>
<p><strong>而且，如果系统是多处理器（有两个或可能更多的处理器），则屏蔽中断仅仅对执行disable指令的那个CPU有效。其他CPU仍将继续运行，并可以访问共享内存。</strong></p>
<p>所以结论是：屏蔽中断对于操作系统本 身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</p>
<h2 id="单标志-锁方法"><a href="#单标志-锁方法" class="headerlink" title="单标志-锁方法"></a>单标志-锁方法</h2><p>设置一个公用整形变量<code>lock</code>，用来指示临界区内是否有进程在运行。<code>0</code>表示空闲，没有进程。<code>1</code>表示忙，有进程。</p>
<p>进程进入临界区前，检查<code>lock</code>,若为<code>0</code>，进入临界区，同时把<code>lock</code>置为<code>1</code>。</p>
<p>若<code>lock</code>为1，进程等待直到<code>lock</code>值变为<code>0</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int lock=0；</span><br><span class="line"> </span><br><span class="line">//第一个程序</span><br><span class="line"> P0:&#123;</span><br><span class="line">   Do&#123;</span><br><span class="line"> While(lock!=0); </span><br><span class="line"> lock=1;</span><br><span class="line"> 进入 P0 的临界区代码 CS0; </span><br><span class="line"> lock=0;</span><br><span class="line"> 进入 P0 的其他代码;</span><br><span class="line">&#125;</span><br><span class="line">   While(true)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> //第二个程序</span><br><span class="line"> P1:&#123;</span><br><span class="line">  Do&#123;</span><br><span class="line"> While(lock!=0);</span><br><span class="line"> lock=1;</span><br><span class="line"> 进入 P1 的临界区代码 CS1; </span><br><span class="line"> lock=0;</span><br><span class="line"> 进入 P1的其他代码;</span><br><span class="line">&#125;</span><br><span class="line">   While(true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设P0 进程读出锁变量的值发现它为0， 而恰好在它将其值设置为1之前，P1 进程被调度运行，发现它为0，将该锁变量设置为1，P1 进入临界区。</p>
<p>当P0 进程进程再次能运行时，它继续将该锁设置为1，并进入临界区</p>
<p>P0 ，P1 两个进程同时进入临界区中。违背了临界区的访问规则“<strong>忙则等待</strong>”。</p>
<h2 id="单标志-改进-严格轮换法"><a href="#单标志-改进-严格轮换法" class="headerlink" title="单标志-改进-严格轮换法"></a>单标志-改进-严格轮换法</h2><p>设置一个公用整形变量 turn，用来指示允许进入临界区的进程标识。若 turn 为 0，则允许进程 P0 进入临界区；否则循环检查该变量，直到 turn 变为本进程标识；在退出区，修改允许进入进程的标识 turn 为1。进程 P1 的算法与此类似。两个进程的程序结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int turn=0；</span><br><span class="line"></span><br><span class="line">//程序0</span><br><span class="line"> P0: &#123;</span><br><span class="line">   Do&#123;</span><br><span class="line"> While(turn!=0); </span><br><span class="line"> 进入 P0 的临界区代码 CS0; </span><br><span class="line"> turn=1;</span><br><span class="line"> 进入 P0 的其他代码;</span><br><span class="line">&#125;</span><br><span class="line">    While(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序1</span><br><span class="line"> P1: &#123;</span><br><span class="line">   Do&#123;</span><br><span class="line"> While(turn!=1); </span><br><span class="line"> 进入 P1 的临界区代码 CS1; </span><br><span class="line"> turn=0;</span><br><span class="line"> 进入 P1的其他代码;</span><br><span class="line">&#125;</span><br><span class="line">    While(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此方法可<strong>保证互斥访问临界资源</strong>，但存在问题是强制两个进程<strong>交替</strong>进入临界区，造成资源浪费。</p>
<p>例如，当进程P0 退出临界区后将 turn 置为 1，以便允许进程P1 进入临界区。但如果进程 P1 暂时并未要求访问该临界资源，而 P0 又想再次访问临界资源，P1没有把标志位恢复为0，则P0将无法进入临界区。</p>
<p>可见，此算法不能保证实现“<strong>空闲让进</strong>”准则。</p>
<h2 id="改进-双标志先检查"><a href="#改进-双标志先检查" class="headerlink" title="改进-双标志先检查"></a>改进-双标志先检查</h2><p>设置标志数组 <code>flag[]</code>表示进程是否在临界区中执行，初值均为假。在每个进程访问该临界资源之前，先检查另一个进程是否在临界区中，若不在则修改本进程的临界区标志为真并进入临界区，在退出区修改本进程临界区标志为假。两进程的程序结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean flag[2]=&#123;false,false&#125;;</span><br><span class="line">P0:&#123;</span><br><span class="line">	Do&#123;</span><br><span class="line">    While flag[1];</span><br><span class="line">    flag[0]=true;</span><br><span class="line">    进程 P0 的临界区代码 CS0; </span><br><span class="line">    flag[0]=false;</span><br><span class="line">    进程 P0 的其他代码;</span><br><span class="line">	&#125;</span><br><span class="line">	While(true)</span><br><span class="line">&#125;</span><br><span class="line">P1:&#123;</span><br><span class="line">	Do&#123;</span><br><span class="line">    While flag[0];</span><br><span class="line">    flag[1]=true;</span><br><span class="line">    进程 P1 的临界区代码 CS1; </span><br><span class="line">    flag[1]=false;</span><br><span class="line">    进程 P1 的其他代码;</span><br><span class="line">	&#125;</span><br><span class="line">	While(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此算法解决了“<strong>空闲让进</strong>”的问题，但又出现了新问题。</p>
<p>当两个进程都未进入临界区时，它们各自的访问标志都为 false，若此时刚好两个进程同时都想进入临界区，并且都发现对方的标志值为 false（当两进程交替执行了检查语句后，都满足 flag[]=false 的条件）， 于是两个进程同时进入了各自的临界区。</p>
<p>违背了临界区的访问规则“<strong>忙则等待</strong>”。</p>
<h2 id="改进-双标志后检查"><a href="#改进-双标志后检查" class="headerlink" title="改进-双标志后检查"></a>改进-双标志后检查</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean flag[2]=&#123;false,false&#125;;</span><br><span class="line">P0:&#123;</span><br><span class="line">	Do&#123;</span><br><span class="line">	  flag[0]=true;</span><br><span class="line">      While flag[1]; </span><br><span class="line">      进程 P0 的临界区代码 CS0; </span><br><span class="line">      flag[0]=false;</span><br><span class="line">      进程 P0 的其他代码;</span><br><span class="line">	&#125;</span><br><span class="line">	While(true)</span><br><span class="line">&#125;</span><br><span class="line">P1:&#123;</span><br><span class="line">	Do&#123;</span><br><span class="line">	  flag[1]=true;</span><br><span class="line">      While flag[0]; </span><br><span class="line">      进程 P0 的临界区代码 CS0; </span><br><span class="line">      flag[1]=false;</span><br><span class="line">      进程 P1 的其他代码;</span><br><span class="line">	&#125;</span><br><span class="line">	While(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此算法可以有效地防止两进程同时进入临界区，但存在两个进程都进不了临界区的问题。</p>
<p>即当两个进程同时想进入临界区时，它们分别将自己的标志位设置为 true，并且同时 去检查对方的状态，发现对方也要进入临界区，于是对方互相谦让，结果都无法进入临界区， 造成“死等”现象。</p>
<p>违背了“<strong>有限等待</strong>”的准则。</p>
<h2 id="Peterson方法"><a href="#Peterson方法" class="headerlink" title="Peterson方法"></a>Peterson方法</h2><p>1981年，G. L. Peterson 发现了一种简单得多的互斥算法。终于完美地解决了问题。</p>
<p>算法思想是算法3和算法1的结合。标志数组 flag[]表示进程是否希望进入临界区或是否在临界区中执行。此外，还设置了一个turn 变量，用于指示允许进入临界区的进程标识。两进程的程序结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean flag[2]=&#123;false,false&#125;;</span><br><span class="line">int turn;</span><br><span class="line">P0:&#123;</span><br><span class="line">    Do&#123;</span><br><span class="line">        flag[0]=true;</span><br><span class="line">        turn=1; </span><br><span class="line">        While (flag[1] &amp;&amp; turn==1);</span><br><span class="line">        进程 P0 的临界区代码 CS0; </span><br><span class="line">        flag[0]=false;</span><br><span class="line">        进程 P0 的其他代码;</span><br><span class="line">      &#125;</span><br><span class="line">    While(true)</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line">P1:&#123;</span><br><span class="line">    Do&#123;</span><br><span class="line">      flag[1]=true;</span><br><span class="line">      turn=0; </span><br><span class="line">      While (flag[0] &amp;&amp; turn==0);</span><br><span class="line">      进程 P1 的临界区代码 CS1; </span><br><span class="line">      flag[1]=false;</span><br><span class="line">      进程 P1的其他代码;</span><br><span class="line">      &#125;</span><br><span class="line">    While(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始，没有任何进程处于临界区中，现在P0进程执行。它通过设置其数组元素和将turn置为1, 并进入临界区执行。如果P1现在执行，P1将在此处挂起直到 flag[0]变成false，该事件只有在P0退出临界区时才会发生。</p>
<p>ü现在考虑两个进程几乎同时要进入临界区的情况。P0将turn 置为1，P1将turn置为0。但只有后被保存进去的值才有效，前一个因被重写而丢失。假设P1是后存入的，则turn为0。当两个进程都运行到while语句时，P0将循环0次并进入临界区，而P1则将不停地循环且不能进入临界区，直到P0退出临界区为止。</p>
<p>至此，软件方法可以<strong>正确</strong>地解决上述同步问题。</p>
<p><strong>缺点：**</strong>并不完美**</p>
<p>上述解法是正确的，但它们都有忙等待的缺点。这些解法在本质上是这样的：</p>
<p>“<strong>当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止”</strong></p>
<h1 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h1><h2 id="sleep和wakeup原语"><a href="#sleep和wakeup原语" class="headerlink" title="sleep和wakeup原语"></a>sleep和wakeup原语</h2><p>原语：由多条指令组成，是一种特殊的系统功能调用，它可以完成一个特定的功能。</p>
<p>原语的特点：</p>
<ul>
<li><p>执行时不可中断</p>
</li>
<li><p>不可并发</p>
</li>
<li><p>在管态下执行，常驻内存</p>
</li>
</ul>
<p>现在来考察两条进程间通信原语：<code>sleep</code>和<code>wakeup</code></p>
<p>它们一起合作，实现<strong>进程在无法进入临界区时阻塞，而不是忙等待。而当临界区可用时，可以通过wakeup唤醒相关阻塞的进程。</strong></p>
<ul>
<li><p><strong>Sleep原语：不需要参数，</strong>调用时将使得调用进程进入阻塞状态，直到另外一个进程将其唤醒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sleep()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>Wakeup原语：需要输入一个参数，即需要被**</strong>唤醒的指定进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakeup(process)</span><br></pre></td></tr></table></figure>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>作为使用这些原语的一个例子，我们考虑<strong>生产者-消费者问题</strong>，也称作<strong>有界缓冲区问题</strong>。</p>
<p>两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。</p>
<p>也可以把这个问题一般化为<em>m</em>个生产者和<em>n</em> 个消费者问题，但是我们只讨论一个生产者和一个消费者的情况，这样可以简化解决方案。</p>
<font color="red">同步问题</font>

<ul>
<li><strong>生产进程不能往“满”的缓冲区中放产品</strong></li>
<li><strong>消费进程不能从“空”的缓冲区中取产品</strong></li>
</ul>
</li>
</ul>
<p>  当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况。其解决办法是让生产者睡眠，待消费者从缓冲区中取出一个或多个数据项时再唤醒它。</p>
<p>  同样地，当消费者试图从缓冲区中 取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。</p>
<p>  这个方法听起来简单，但它包含与前边问题一样的竞争条件。为了跟踪缓冲区中的数据项数，我们需要一个<strong>变量count</strong>。如果缓冲区最多存放N个数据项，则生产者代码将首先检查count是否达到N，若是，则生产者睡眠；否则生产者向缓冲区中放入一个数据项并增量count的值。</p>
<p>  消费者的代码与此类似：首先测试count是否为0，若是，则睡眠；否则从中取走一个数据项并递减count 的值。</p>
<p>  每个进程同时也检测另一个进程是否应被唤醒，若是则唤醒之。生产者和消费者的代码如图所示。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#defind N 100</span><br><span class="line">int count = 0;</span><br><span class="line">//生产者</span><br><span class="line">void producer(void)</span><br><span class="line">&#123;</span><br><span class="line">    int item;</span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">           item=produce_item(); //产生下一个数据项</span><br><span class="line">           if (count == N) </span><br><span class="line">           		sleep();   	//如果缓冲区满，则生产者睡眠，后续程序不执行</span><br><span class="line">           insert_item(item);  //如果缓冲区不为满或者被唤醒，将数据项存入缓冲区</span><br><span class="line">           count = count+1; //缓冲区数据项个数+1</span><br><span class="line">           if (count == 1)   </span><br><span class="line">           		wakeup(consumer);//如果缓冲区为空，唤醒消费者</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消费者</span><br><span class="line">void consumer(void)</span><br><span class="line">&#123;</span><br><span class="line">    int item;</span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">           if (count == 0) </span><br><span class="line">           		sleep();    //如果缓冲区为空，睡眠</span><br><span class="line">           item=remove_item();  //如果缓冲区不为空或者被唤醒，睡眠取出来一个数据</span><br><span class="line">           count = count-1;   //将缓冲区的数据项计数器减1 </span><br><span class="line">           if (count == N-1) </span><br><span class="line">           		wakeup(producer);  //如果缓冲区为满，唤醒生产者。</span><br><span class="line">           consume_item(item);  //消费一个数据项。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>问题：</strong></p>
<p>  这里有可能会出现竞争条件，其原因是对count的访问未加限制。可能出现以下情况：缓冲区为空，消费者刚刚读取count的值发现它为0。此时调度程序决定暂停消费者并启动运行生产者。生产者向缓冲区中加入一个数据项，count加1。现在count的值变成了1。它推断认为于count刚才为0，所以消费者此时一定在睡眠，于是生产者调用wakeup来唤醒消费者。</p>
<p>  但是，消费者此时在逻辑上并未睡眠，所以wakeup信号丢失。当消费者下次运行时，它将测试先前读到的count值，发现它为0，于是睡眠。生产者迟早会填满整个缓冲区，然后睡眠。这样一来,<font color=red>两个进程都将永远睡眠下去。</font></p>
<p>  问题的实质在于发给一个（尚)未睡眠进程的wakeup信号丢失了。如果它没有丢失，则一切都很正常。</p>
<h1 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h1><p>1965年，由荷兰学者 迪科斯彻 Dijkstra 提出，是一种卓有成效的进程同步机制。</p>
<p>经历整型信号量、记录型信号量，发展为“信号量集”机制。</p>
<p><strong>P、V</strong>操作是原语。</p>
<p>信号量的值除初始化外，只能由P、V原语修改。(wait、signal)</p>
<p>信号量是Dijkstra提出的一种方法，它使用一个整型变量来累计唤醒次数，供以后使用。在他的建议中引入了一个新的变量类型，称作信号量（semaphore）。</p>
<p>一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。Dijkstra建议设立两种操作：down和up（分别为<strong>一般化后的sleep和wakeup</strong>)。在Dijkstra 原来的论文中，他分别使用名称 P 和 V 而不是 down 和 up ，荷兰语中， Proberen的意思是尝试，Verhogen的含义是增加或升高。</p>
<ul>
<li><p>对一信号量执行 <strong>P (down) 操作，是检查其值是否大于0。若该值大于0，则将其值减1</strong>（即用掉一个保存的唤醒信号)并继续；<strong>若该值为0，则进程将睡眠，而且此时down操作并未结束。</strong></p>
<p>检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成。保证一旦一个信号量操作开始，则在该操作完 成或阻塞之前，其他进程均不允许访问该信号量。这种原子性对于解决同步问题和避免竞争条件是绝对必要的。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行</p>
</li>
<li><p><strong>V (up) 操作对信号量的值增1。</strong>如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作， 则由系统选择其中的一个（如随机挑选)并允许该进程完成它的down操作。于是，对一个有进程在其上睡眠的信号量执行一次up操作之后，该信号量的值仍旧是0，但在其上睡眠的进程却少了一个。信号 量的值增1和唤醒一个进程同样也是不可分割的。不会有某个进程因执行V而阻塞。</p>
</li>
</ul>
<h2 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h2><ul>
<li>整型信号量</li>
<li>记录型信号量</li>
<li>AND型信号量</li>
<li>信号量集</li>
</ul>
<h2 id="整型信号量原语"><a href="#整型信号量原语" class="headerlink" title="整型信号量原语"></a>整型信号量原语</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(S):</span><br><span class="line">	while S&lt;=0 do no-op;</span><br><span class="line">		S:=S-1;</span><br><span class="line">V(S):</span><br><span class="line">	S:=S+1;</span><br></pre></td></tr></table></figure>
<h3 id="前驱关系用整型信号量实现"><a href="#前驱关系用整型信号量实现" class="headerlink" title="前驱关系用整型信号量实现"></a>前驱关系用整型信号量实现</h3><p>如果是下面的前驱关系</p>
<script type="math/tex; mode=display">
P_1\to P_2</script><p>我们可以设置一个信号量S，其初值为0，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P1;</span><br><span class="line">V(S);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(S);</span><br><span class="line">P2;</span><br></pre></td></tr></table></figure>
<h3 id="多个进程同步用整型信号量实现进程同步"><a href="#多个进程同步用整型信号量实现进程同步" class="headerlink" title="多个进程同步用整型信号量实现进程同步"></a>多个进程同步用整型信号量实现进程同步</h3><img src="/2024/11/05/Operating%20System-Process%20synchronization/image-20241110150155772.png" class="" alt="image-20241110150155772">
<p>设5个信号量</p>
<p><code>semaphore fl=f2=f3=f4=f5=O</code></p>
<p><strong>含义：</strong>分别表示进程S1、S2、S3、S4、S5是否执行完成。 </p>
<img src="/2024/11/05/Operating%20System-Process%20synchronization/PVcodes.png" class="" alt="PVcodes">
<font color="red">前进程，后放V；后进程，前放P"</font>

<h3 id="两个进程互斥用信号量实现"><a href="#两个进程互斥用信号量实现" class="headerlink" title="两个进程互斥用信号量实现"></a>两个进程互斥用信号量实现</h3><p>设 <code>mutex=1</code></p>
<p>Process1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (true)</span><br><span class="line">  &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    critical section;</span><br><span class="line">    V(mutex);</span><br><span class="line">    remainder  section;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Process1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (true)</span><br><span class="line">  &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    critical section;</span><br><span class="line">    V(mutex);</span><br><span class="line">    remainder  section;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生产者-消费者问题用整型信号量实现"><a href="#生产者-消费者问题用整型信号量实现" class="headerlink" title="生产者-消费者问题用整型信号量实现"></a>生产者-消费者问题用整型信号量实现</h3><p>该解决方案使用了三个信号量：</p>
<ul>
<li><p><strong>full</strong>，用来记录充满的缓冲槽数目；</p>
</li>
<li><p><strong>empty</strong>，记录空的缓冲槽总数；</p>
</li>
<li><p><strong>mutex</strong>，用来确保生产者和消费者不会同时访问缓冲区。</p>
</li>
</ul>
<p>full的初值为0，empty的初值为缓冲区中槽的数目，mutex初值为1。</p>
<p>供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区，称作二元信号量。</p>
<p>如果每个进程在进入临界区前都执行一个P操作，并在刚刚退出时执行一个V操作，就能够实现互斥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define N 100  /* 缓冲区中的槽数目 */</span><br><span class="line">typedef int semaphore;/* 信号量是一种特殊的整型数据 */</span><br><span class="line">semaphore mutex=1 /* 控制对临界区的访问 */</span><br><span class="line">semaphore empty=N/* 计数缓冲区的空槽数目 */</span><br><span class="line">semaphore full =0/* 计数缓冲区的满槽数目 */</span><br><span class="line"></span><br><span class="line">void producer(void)</span><br><span class="line">&#123;</span><br><span class="line">    int item;</span><br><span class="line"></span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">           item=produce_item();/* 产生放在缓冲区中的一些数据 */</span><br><span class="line">           p(empty);/* 将空槽数目减1 */</span><br><span class="line">           p(mutex);/* 进入临界区 */</span><br><span class="line">           insert_item(item);/* 将新数据项放到缓冲区中 */</span><br><span class="line">           v(mutex);/* 离开临界区 */</span><br><span class="line">           v(full);/* 将满槽的数目加1 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer(void)</span><br><span class="line">&#123;</span><br><span class="line">    int item;</span><br><span class="line"></span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">           p(full);/* 将满槽数目减1 */</span><br><span class="line">           p(mutex);/* 进入临界区 */</span><br><span class="line">           item=remove_item();/* 从缓冲区中取出数据项 */</span><br><span class="line">           v(mutex);/* 离开临界区 */</span><br><span class="line">           v(empty);/* 将空槽数目加1 */</span><br><span class="line">           consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><p><strong>在整型信号量机制中的**</strong>wait操作，只要是信号量S&lt;=0,就会不断测试。因此，该机制并未遵循“让权等待”准则，而是使进程处于“忙等”状态。记录型信号量机制则是一种不存在“忙等”的进程同步机制。**</p>
<p><strong>但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一个临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量**</strong>value<strong><strong>外，还增加一个进程链表指针</strong></strong>L<strong>**，用于链接上述的所有等待进程。</strong></p>
<p><strong>记录型信号量是由于它采用了记录型的数据结构而得名的。</strong></p>
<h3 id="数据结构及P-V操作"><a href="#数据结构及P-V操作" class="headerlink" title="数据结构及P-V操作"></a>数据结构及P-V操作</h3><h4 id="记录型信号量的数据结构"><a href="#记录型信号量的数据结构" class="headerlink" title="记录型信号量的数据结构"></a>记录型信号量的数据结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type semaphore=record</span><br><span class="line">     value: integer; /*初值为资源信号量的数目。*/</span><br><span class="line">     L: list of process; /*链表L用于链接所有等待的进程。*/</span><br><span class="line">end </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="记录型信号量的P-V操作"><a href="#记录型信号量的P-V操作" class="headerlink" title="记录型信号量的P-V操作"></a>记录型信号量的P-V操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* P操作：申请一个单位资源*/</span><br><span class="line">P(s)</span><br><span class="line">&#123;</span><br><span class="line">     s.value = s.value -1 ;</span><br><span class="line">     if (s.value &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">	    该进程状态置为等待状态</span><br><span class="line">         将该进程的PCB插入相应的等待队列末尾s.queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* V操作：释放一个单位资源*/</span><br><span class="line">V(s)</span><br><span class="line">&#123;</span><br><span class="line">     s.value = s.value +1;</span><br><span class="line">     if (s.value &lt; = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        唤醒相应等待队列s.queue中等待的一个进程</span><br><span class="line">        改变其状态为就绪状态,并将其插入就绪队列</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>S.value&gt;0: 系统中可利用的资源数量</strong></p>
</li>
<li><p><strong>S.value=0:资源恰好分配完毕</strong></p>
</li>
<li><p><strong>S.value&lt;0:其绝对值表示在该信号量链表中已阻塞进程的数目。</strong></p>
</li>
</ul>
<h2 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h2><p>在一些应用场合，是<strong>一个进程需要先获得两个或者更多的共享资源后方能执行其任务。</strong>假定现在有两个进程A和B，他们都要求访问共享数据D和E。当然，共享数据都应该作为临界资源。为此，可为这两个数据分别设置用于互斥的信号量Dmutex和Emutex，并令他们的初值都是1。相应的，在两个进程中都要包含两个对Dmutex和Emutex的操作，即：</p>
<p>​    process A:           process B:</p>
<p>​    P(Dmutex);          P(Emutex);</p>
<p>​    P(Emutex);           P(Dmutex);</p>
<p>若进程A和B处于僵持状态。<strong>在无外力作用下，两者都将无法从僵持状态中解脱出来。</strong>我们称此时的进程A 和B已经进入<strong>死锁状态</strong>。显然，当进程同时要求的共享资源愈多时，发生进程死锁的可能性就越大。</p>
<p>AND同步机制的基本思想是：<strong>将进程在整个运行过程中需要的所有资源，一次性全部的分配给进程，待进程使用完后再一起释放。</strong>只要尚有一个资源未能分配给进程，其它所有有可能为之分配的资源也不分配给它。亦即，对若干个临界资源的分配，采取原子操作方式：要么把它所请求的资源全部分配给进程，要么一个也不分配。这样就可以避免上述死锁情况发生。为此，在P操作中，增加一个“AND”条件，故称为AND同步，或称为同时P操作。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(S1,S2,…,Sn)</span><br><span class="line">     if  S1≥1 and … and Sn≥1 then</span><br><span class="line">         for i:=1 to n do</span><br><span class="line">            Si:=Si-1;</span><br><span class="line">         endfor</span><br><span class="line">     else</span><br><span class="line">           当发现有任何Si&lt;1时，该进程状态置为等待状态</span><br><span class="line">     endif</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">V(S1,S2,…,Sn)</span><br><span class="line">     for i:=1 to n do</span><br><span class="line">          Si:=Si+1;</span><br><span class="line">           将与Si相关的所有等待进程移出到就绪队列</span><br><span class="line">     endfor</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h2><p><strong>一次需要N个某类临界资源时，就要进行</strong>N次P操作——低效又可能死锁。</p>
<p>信号量集是指<strong>同时需要多种资源、每种占用的数目不同，</strong>且<strong>可分配的资源还存在一个临界值时的信号量处理</strong>。</p>
<p>一般信号量集的基本思路是：在AND型信号量的基础上进行扩充，<strong>在一次原语操作中完成所有的资源申请。</strong></p>
<p>进程对信号量Si的测试值为ti（表示信号量的判断条件，要求Si &gt;= ti；即当资源数量低于ti时，便不予分配）</p>
<p>占用值为di（表示资源的申请量，即Si=Si-di）</p>
<p>对应的P、V原语格式为：</p>
<ul>
<li><p>P(S1, t1, d1; …; Sn,tn, dn);</p>
</li>
<li><p>V(S1, d1; …; Sn, dn);</p>
</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(S1,t1,d1,…, Sn,tn,dn)</span><br><span class="line">     if S1≥t1 and … and Sn≥tn then</span><br><span class="line">         for i:=1 to n do</span><br><span class="line">             Si:=Si-di;</span><br><span class="line">         endfor</span><br><span class="line">     else</span><br><span class="line">           当发现有Si&lt;ti时，该进程状态置为等待状态</span><br><span class="line">     endif</span><br><span class="line"></span><br><span class="line">V(S1, d1,…, Sn, dn)</span><br><span class="line">    for i:=1 to n do</span><br><span class="line">         Si:=Si+di;</span><br><span class="line">          将与Si相关的所有等待进程移出	到就绪队列                      </span><br><span class="line">    endfor    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System-存储管理之分区</title>
    <url>/2024/12/14/Operating-System-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>存储管理应具有以下功能:</p>
<ul>
<li><strong>实现内存的分配和回收</strong></li>
<li><strong>地址变换</strong></li>
<li><strong>“扩充”内存容量</strong></li>
<li><strong>进行存储保护</strong></li>
</ul>
<h2 id="存储器的结构层次"><a href="#存储器的结构层次" class="headerlink" title="存储器的结构层次"></a>存储器的结构层次</h2><p>93</p>
<p>硬盘和内存之间的<strong>Cache</strong>就叫做磁盘高速缓存。它是在内存中开辟一块位置，来临时存取硬盘中的数据。</p>
<p>设置在<strong>CPU</strong> 和主存储器之间，完成高速与<strong>CPU</strong>交换信息的<strong>SRAM</strong>（静态存储器），尽量避免<strong>CPU</strong>不必要地多次直接访问相对慢速的主存储器，从而提高计算机系统的运行效率。</p>
<h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h2><p><strong>内存的结构</strong>：由若干存储单元组成，以字节为单位。</p>
<ul>
<li><strong>存储最小单位</strong>:“二进制位”，包含信息为0或1</li>
<li><strong>最小编址单位</strong>:字节，一个字节包含八个二进制位</li>
</ul>
<p><strong>内存地址</strong>：为了便于CPU访问，给每个存储单元一个编号（第一个字节的地址是0，后面依次是1、2、3，等等），也称为物理地址或绝对地址。</p>
<p>物理地址是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。</p>
<p><strong>逻辑地址（程序地址，相对地址，虚地址）</strong><br>​    用户编制的源程序，存在于程序员建立的符号名字空间内，经过汇编或编译后形成若干目标代码，这些目标代码连接后形成可装入程序，这些程序通常采用相对地址的形式，其首地址为0，其余指令中的地址都相对于首地址而编址。</p>
<p> <strong>int a=100;</strong></p>
<p> <strong>-&gt;mov [468000H],EAX</strong></p>
<h1 id="连续分区存储管理方式"><a href="#连续分区存储管理方式" class="headerlink" title="连续分区存储管理方式"></a>连续分区存储管理方式</h1><p><strong>连续/分区分配方式</strong>:指为一个用户程序分配一块连续的内存空间。</p>
<ul>
<li>单一连续分配方式</li>
<li>分区分配方式<ul>
<li>固定分区分配方式</li>
<li>动态分区分配方式</li>
</ul>
</li>
<li>动态重定位分区分配方式</li>
</ul>
<h2 id="单一连续分配方式"><a href="#单一连续分配方式" class="headerlink" title="单一连续分配方式"></a>单一连续分配方式</h2><p><strong>将内存分为系统区（内存低端，分配给OS用）和用户区（内存高端，分配给用户用）。</strong>采用静态分配方式，即作业一旦进入内存，就要等待它运行结束后才能释放内存。</p>
<p><strong>主要特点</strong>：管理简单，只需少量的软件和硬件支持，便于用户了解和使用。但因内存中只装入一道作业运行，内存空间浪费大，各类资源的利用率也不高。</p>
<h2 id="分区分配方式"><a href="#分区分配方式" class="headerlink" title="分区分配方式"></a>分区分配方式</h2><p><strong>分区分配方式是满足多道程序设计需要的一种最简单的存储管理方法。</strong></p>
<p><strong>将内存分成若干个分区（大小相等/不相等），除OS</strong>占用一个分区外，其余的每一个分区容纳一个用户程序。按分区的变化情况，可将分区存储管理进一步分为：</p>
<ul>
<li><strong>固定分区存储管理</strong></li>
<li><strong>动态分区存储管理</strong></li>
</ul>
<h3 id="固定分区分配方式"><a href="#固定分区分配方式" class="headerlink" title="固定分区分配方式"></a>固定分区分配方式</h3><p><strong>内存空间的划分：将内存空间划分为若干个固定大小的分区，除OS占一分区外，其余的每一个分区装入一道程序</strong>。分区的大小可以相等，也可以不等，但事先必须确定，在运行时不能改变。即分区大小及边界在运行时不能改变。</p>
<p> 系统需<strong>建立一张分区说明表或使用表</strong>，以记录分区号、分区大小、分区的起始地址及状态（已分配或未分配）。</p>
<p><strong>内存分配</strong></p>
<p><strong>当某个用户程序要装入内存时，由内存分配程序检索分区说明表，从表中找出一个满足要求的尚未分配的分区分配给该程序，同时修改说明表中相应分区的状态；若找不到大小足够的分区，则拒绝为该程序分配内存。</strong></p>
<p><strong>当程序执行完毕，释放占用的分区，管理程序将修改说明表中相应分区的状态为未分配，实现内存资源的回收。</strong></p>
<p><strong>主要特点</strong>：管理简单，但因作业的大小并不一定与某个分区大小相等，从而使一部分存储空间被浪费。所以主存的利用率不高。</p>
<h3 id="动态分区分配方式"><a href="#动态分区分配方式" class="headerlink" title="动态分区分配方式"></a>动态分区分配方式</h3><p>动态分区分配又称为<strong>可变式</strong>分区分配，是一种动态划分存储器的分区方法。</p>
<p><strong>存储管理方法</strong></p>
<p>   <strong>不事先将内存划分成一块块的分区，而是在作业进入内存时，根据作业的大小动态地建立分区，并使分区的大小正好适应作业的需要。因此系统中分区的大小是可变的，分区的数目也是可变的。</strong> </p>
<p><strong>主要特点</strong></p>
<p>   <strong>管理简单，只需少量的软件和硬件支持，便于用户了解和使用。进程的大小与某个分区大小相等，从而主存的利用率有所提高。</strong></p>
<p><strong>空闲分区链</strong></p>
<p>   <strong>用链头指针将系统中的空闲分区链接起来，构成空闲分区链。每个空闲分区的起始部分存放相应的控制信息（如大小，指向下一空闲分区的指针等）。</strong></p>
<h1 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h1><p><strong>为了将一个作业装入内存，应按照一定的分配算法从空闲分区表（链）中选出一个满足作业需求的分区分配给作业，如果这个空闲分区的容量比作业申请的空间要大，则将该分区一分为二，一部分分配给作业，剩下的部分仍然留在空闲分区表（链）中，同时修改空闲分区表（链）中相应的信息。目前常用分配算法有：</strong></p>
<ul>
<li><strong>首次适应算法 (First Fit)</strong></li>
<li><strong>循环首次适应算法 (Next Fit)</strong></li>
<li><strong>最佳适应算法 (Best Fit)</strong></li>
<li><strong>最坏适应算法 (Worst Fit)</strong></li>
<li><strong>快速适应算法 (Quick Fit)</strong></li>
</ul>
<h2 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h2><p>n<strong>空分区（链）按地址递增的次序排列。</strong></p>
<p>n<strong>在进行内存分配时，从空闲分区表/链首开始顺序查找，直到找到第一个满足其大小要求的空闲分区为止。</strong></p>
<p>n<strong>然后按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍按地址递增的次序保留在空闲分区表（链）中。</strong></p>
<p><strong>首次适应算法的特点</strong></p>
<p>  <strong>优先利用内存低地址部分的空闲分区,从而保留了高地址部分的大空闲区。</strong></p>
<p>  <strong>但由于低地址部分不断被划分，致使低地址端留下许多难以利用的很小的空闲分区(碎片或零头)，而每次查找又都是从低地址部分开始，这增加了查找可用空闲分区的开销。</strong></p>
<h2 id="循环首次适应算法"><a href="#循环首次适应算法" class="headerlink" title="循环首次适应算法"></a>循环首次适应算法</h2><p>   又称为下次适应算法，由首次适应算法演变而来。在为作业分配内存空间时，不再每次从空闲分区表/链首开始查找，而是<strong>从上次找到的空闲分区的<font color=red>下一个空闲分区</font>开始查找，直到找到第一个能满足其大小要求的空闲分区为止。</strong></p>
<p>   然后，再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍按地址递增的次序保留在空闲分区表/链中。</p>
<h2 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h2><p><strong>算法要求</strong>：</p>
<p>   <strong>空闲分区表/链按容量大小递增的次序排列。在进行内存分配时，从空闲分区表/链首开始顺序查找，直到找到第一个满足其大小要求的空闲分区为止。</strong></p>
<p>   <strong>按这种方式为作业分配内存，就能把既满足作业要求又与作业大小最接近的空闲分区分配给作业。如果该空闲分区大于作业的大小，则与首次适应算法相同，将剩余空闲分区仍按容量大小递增的次序保留在空闲分区表/链中。</strong></p>
<p><strong>算法特点</strong></p>
<p>  <strong>若存在与作业大小一致的空闲分区，则它必然被选中，若不存在与作业大小一致的空闲分区，则只划分比作业稍大的空闲分区，从而保留了大的空闲分区，但空闲区一般不可能正好和它申请的内存空间大小一样，因而将其分割成两部分时，往往使剩下的空闲区非常小，从而在存储器中留下许多难以利用的小空闲区（外碎片或外零头）</strong></p>
<h2 id="最坏适应算法-WF"><a href="#最坏适应算法-WF" class="headerlink" title="最坏适应算法(WF)"></a>最坏适应算法(WF)</h2><p>   <strong>空闲分区表/链按容量大小递减的次序排列。在进行内存分配时，从空闲分区表/链首开始顺序查找，找到的第一个能满足作业要求的空闲分区，一定是个最大的空闲区。这样可保证每次分割后的剩下的空闲分区不至于太小（还可被分配使用，以减少“外碎片”），仍把它按从大到小的次序保留在空闲分区表/链中。</strong></p>
<p><strong>算法特点</strong></p>
<p>  <strong>总是挑选满足作业要求的最大的分区分配给作业。这样使分给作业后剩下的空闲分区也较大，可装下其它作业。</strong></p>
<p>  <strong>但由于最大的空闲分区总是因首先分配而划分，当有大作业到来时，其存储空间的申请往往会得不到满足。</strong></p>
<h2 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h2><p><strong>算法要求</strong></p>
<p>   <strong>又叫分类搜索法，将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区（链）表。系统中存在多个空闲分区（链）表，同时在内存中设立一张管理索引表，每个表项对应了一种空闲分区类型，并指向该类型的空闲分区表的表头。空闲分区的分类是根据进程常用的空间大小进行划分的。</strong></p>
<p> <strong>优点：查找效率高，找到该类后，取下第一块分配即可；不会产生碎片；</strong></p>
<p> <strong>缺点：分区归还给系统时算法复杂，系统开销大；内存空间存在一定的浪费。</strong></p>
<h1 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h1><p>   <strong>系统利用某种分配算法，从空闲分区表/链中找到所需大小的分区。</strong></p>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p><strong>分区的切割：</strong></p>
<p>   设请求的分区大小为u.size，空闲分区的大小为m.size,若<strong>m.size-u.size</strong>£<strong>csize</strong>（csize是事先规定的不再切割的剩余分区的大小），说明多余部分太小，可不再切割，将整个分区分配给请求者；否则，从该分区中按请求的大小划分出一块内存空间分配出去，余下的部分仍留在空闲分区表/链中，然后，将分配区的首址返回给调用者。</p>
<p> <strong>分配流程图如下</strong> </p>
<p>3920</p>
<h2 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h2><p>   <strong>当作业执行结束时，释放所占有的内存空间，OS应回收已使用完毕的内存分区。</strong></p>
<p>   <strong>系统根据回收分区的大小及首地址，在空闲分区表中检查是否有邻接的空闲分区，如有，则合成为一个大的空闲分区，然后修改有关的分区状态信息。</strong></p>
<p>   <strong>回收分区与已有空闲分区的相邻情况有以下四种</strong>：</p>
<h3 id="case-0"><a href="#case-0" class="headerlink" title="case 0"></a>case 0</h3><p>回收分区<strong>R</strong>上面邻接一个空闲分区<strong>F1</strong>，合并后首地址为空闲分区<strong>F1</strong>的首地址，大小为<strong>F1</strong>和<strong>R</strong>二者大小之和。</p>
<p> <strong>这种情况下，回收后空闲分区表中表项数不变。</strong></p>
<h3 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h3><p>回收分区<strong>R</strong>下面邻接一个空闲分区<strong>F2</strong>，合并后首地址为回收分区<strong>R</strong>的首地址，大小为<strong>R</strong>和<strong>F2</strong>二者大小之和。</p>
<p> <strong>这种情况下，回收后空闲分区表中表项数不变。</strong></p>
<h3 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h3><p>回收分区<strong>R</strong>上下邻接空闲分区<strong>F1</strong>和<strong>F2</strong>，合并后首地址为上空闲分区<strong>F1</strong>的首地址，大小为<strong>F1</strong>、<strong>R</strong>和<strong>F2</strong>三者大小之和。</p>
<p> <strong>这种情况下，回收后空闲分区表中表项数不但没有增加，反而减少一项。</strong> </p>
<h3 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h3><p>回收分区<strong>R</strong>不邻接空闲分区，这时在空闲分区表中新建一表项，并填写分区首地址、大小等信息。</p>
<p>  <strong>这种情况下，回收后空闲分区表中表项数增加一项。</strong></p>
<h1 id="动态重定位分区分配方式"><a href="#动态重定位分区分配方式" class="headerlink" title="动态重定位分区分配方式"></a>动态重定位分区分配方式</h1><h2 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h2><p><strong>在分区存储管理方式中，必须把作业装入到一片连续的内存空间。如果系统中有若干个小的分区，其总容量大于要装入的作业，但由于它们不相邻接，也将导致作业不能装入内存。</strong></p>
<p><strong>这种内存中无法被利用的存储空间称为“零头”或“碎片”。根据碎片出现的情况分为以下两种：</strong></p>
<h3 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h3><p><strong>指分配给作业的存储空间中未被利用的部分。如固定分区中存在的碎片。</strong></p>
<h3 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h3><p><strong>指系统中无法利用的小的空闲分区。如动态分区中存在的碎片。</strong></p>
<p><strong>对系统中存在碎片，目前主要有两种技术(之一)：</strong></p>
<h2 id="拼接或紧凑或紧缩技术"><a href="#拼接或紧凑或紧缩技术" class="headerlink" title="拼接或紧凑或紧缩技术"></a>拼接或紧凑或紧缩技术</h2><p><strong>将内存中所有作业移到内存一端（作业在内存中的位置发生了变化，这就必须对其地址加以修改或变换即称为重定位），使本来分散的多个小空闲分区连成一个大的空闲区。如图所示。</strong></p>
<p>   这种通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为<strong>拼接或紧凑或紧缩</strong>。</p>
<p>   <strong>拼接时机：分区回收时；当找不到足够大的空闲分区且总空闲分区容量可以满足作业要求时。</strong></p>
<p><strong>可以充分利用存储区中的“零头/碎片”，提高主存的利用率。 但若 “零头/碎片”太多，则拼接频率过高会使系统开销加大。</strong></p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p><strong>覆盖技术主要用在早期的OS中（内存&lt;64KB），可用的存储空间受限，某些大作业不能一次全部装入内存，产生了大作业与小内存的矛盾。</strong></p>
<p><strong>覆盖</strong>：把一个程序划分为一系列功能相对独立的程序段（称为<strong>覆盖</strong>），让执行时并不要求同时装入内存的覆盖组成一组（称为<strong>覆盖段</strong>），共享主存的同一个区域，从而解决在小的存储空间中运行大作业的问题。这种内存扩充技术就是覆盖。</p>
<h2 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h2><p><strong>交换技术也是“扩充”内存容量和提高内存利用率的有效措施。现代OS中广泛采用。</strong></p>
<p>   <strong>最早用在MIT的兼容分时系统CTSS中，任何时刻系统中只有一个完整的用户作业，当运行一段时间后，因时间片用完或等待某事件发生，系统就把它交换到外存上，同时把另一作业调入内存让其运行，这样，可以在内存容量不大的小型机上分时运行，早期的一些分时系统多数采用这种交换技术。</strong></p>
<p><strong>交换技术</strong>：将暂时不用的某个进程及数据（首先是处于阻塞状态优先级最低的）部分（或全部）从内存移到外存（备份区或对换区，采用连续分配的动态存储管理方式）中去，让出内存空间，同时将某个需要的进程调入到内存，让其运行。交换到外存的进程需要时可以被再次交换回（选择换出时间最久的）内存中继续执行。</p>
]]></content>
  </entry>
  <entry>
    <title>Operating System-process scheduling</title>
    <url>/2024/10/20/Operating%20System-process%20scheduling/</url>
    <content><![CDATA[<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p><strong>中断或中断机制是实现多道程序设计与并发执行的基础和必要条件</strong>。如果没有中断，操作系统就无法获得系统的控制权，就不会将处理机（也作为一种资源）分派给不同的进程而实现并发执行。</p>
<h2 id="中断响应的步骤"><a href="#中断响应的步骤" class="headerlink" title="中断响应的步骤"></a>中断响应的步骤</h2><ul>
<li>终止当前程序执行</li>
<li>保存断点信息</li>
<li>转相应中断处理程序</li>
</ul>
<p>在并发环境下，用户程序不需要为添加任何特定代码中断。</p>
<p>为适应中断产生，在指令周期末端要增加一个中断阶段。</p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020144047255.png" class="" alt="image-20241020144047255">
<h2 id="中断处理的类型"><a href="#中断处理的类型" class="headerlink" title="中断处理的类型"></a>中断处理的类型</h2><ul>
<li><p><strong><font color="#eb507e">强迫性中断</font></strong></p>
<ul>
<li><strong>时钟中断</strong>：如硬件实时时钟到时等；</li>
<li><strong>输入输出中断</strong>：设备数据传输结束/设备出错等。 </li>
<li><strong>控制台中断</strong>：系统操作员通过控制台发出命令等。 </li>
<li><strong>硬件故障中断</strong>：如掉电、内存效验错等。 </li>
<li><strong>程序性中断</strong>：如地址越界、数据溢出，除零等。 </li>
</ul>
</li>
<li><p><strong><font color="#eb507e">自愿性中断</font></strong></p>
<p>程序<strong>事先有意识安排的；</strong>通常执行访管指令（系统调用）而引起的，其目的要求系统提供某种服务。</p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020144416576.png" class="" alt="image-20241020144416576">
</li>
</ul>
<h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><p>当中断事件发生时，中断装置根据中断类别自动地将对应的PSW和PC分别送入程序状态字和程序计数器中，如此便转入到对应的中断处理程序，如图6.4所示。</p>
<p>应当说明的是，图6.4所示的中断处理是<strong>比较典型</strong>的形式。对于系统的中断处理，<strong>硬件要保存哪些信息，保存到什么地方，这些随CPU（或系统）而不同</strong>。</p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020145301001.png" class="" alt="image-20241020145301001">
<h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><p>时钟中断是现代操作系统不可或缺的控制手段，所以在此特别强调。时钟中断管理及维护的内容：</p>
<ul>
<li><strong>进程管理</strong>：用于时间片轮转处理机调度算法的系统中，记录进程已占用处理机时间等。</li>
<li><strong>作业记录</strong>：记录作业在输入井中等待的时间等。</li>
<li><strong>资源管理</strong>：动态统计运行进程占有和使用处理机等资源的时间等。</li>
<li><strong>事件处理</strong>：实时系统中定时向被控制的对象发送控制信号。</li>
<li><strong>系统维护</strong>：定时运行死锁检测程序等，定时运行系统记帐程序等。</li>
<li><strong>实现软件时钟</strong>：利用硬件间隔时钟和一个存储单元可以实现软件时钟。例如，假设硬件间隔时钟每隔10ms产生一次中断，某一程序每隔1000ms执行一次，则可以这样确定该程序的执行时刻。</li>
</ul>
<p>中断的应用使得系统的资源利用率得到提高，但即使利用了中断，在<strong>单道</strong>情况下处理机仍有可能未得到充分的利用。例如，如果I/O操作的时间比较长，则大部分时间处理机是空闲的。解决这个问题的方法是允许<strong>多道</strong>用户程序同时处于活动状态。</p>
<p>某程序（进程）等待I/O上，可调度另一程序，这时处理机与外设都在“忙”。</p>
<p>由此，说明多道程序设计是提高系统效率又一重要的技术思想。</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="三个层次的进程调度"><a href="#三个层次的进程调度" class="headerlink" title="三个层次的进程调度"></a>三个层次的进程调度</h2><p>进程调度是把进程指定到一个处理机中执行。在许多系统中，这个调度活动分成三个层次：<strong>高级调度</strong>、<strong>中级调度</strong>和<strong>低级调度</strong>。</p>
<ul>
<li><p><strong>高级调度</strong>：</p>
<p>在创建新进程时，决定是否把进程添加到当前活跃的进程集合中。</p>
</li>
<li><p><strong>中级调度</strong>：</p>
<p>是属于交换功能的一部分，它需要决定（部分）进程是否不再处于活动空间中。</p>
</li>
<li><p><strong>低级调度</strong>：</p>
<p>真正决定下一次执行哪一个就绪进程。图6.6 给出了进程状态转换三个层次的调度。</p>
</li>
</ul>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020145654331.png" class="" alt="image-20241020145654331">
<h2 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h2><p>一个作业的处理可以分若干相对独立的作业步，<strong>每个作业步可能对应一个进程</strong>。例如，一个C语言程序，作为批作业处理大致应当包括如下步骤： </p>
<ul>
<li>运行C语言编译程序对C代码进行编译。 </li>
<li>对所编译产生的浮动程序进行连接装配。</li>
<li>执行所产生的目标代码程序。</li>
</ul>
<p><strong>以上三个步骤运行的是三个不同的程序，因而需要三个进程完成</strong>。</p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020150240103.png" class="" alt="image-20241020150240103">
<h2 id="低级调度-处理机调度"><a href="#低级调度-处理机调度" class="headerlink" title="低级调度/处理机调度"></a>低级调度/处理机调度</h2><p>处理机调度（CPU scheduling）是指CPU在可运行实体之间的分配。如图6.7中虚框的活动空间部分。处理机资源管理需要解决三个问题： </p>
<ul>
<li>依什么原则分配处理机，即确定处理机调度算法。</li>
<li>什么时候分配处理机，即确定处理机调度时机。</li>
<li>如何分配处理机，即给出处理机调度过程。</li>
</ul>
<h2 id="中断和进程状态转换"><a href="#中断和进程状态转换" class="headerlink" title="中断和进程状态转换"></a>中断和进程状态转换</h2><p><strong>中断作为引起进程状态转换的本质</strong>加以阐述。我们仍以<strong>进程的三个基本状态</strong>为例说明四条有向边所表明的状态转移。图6.9给出了由中断引起进程状态转移的形式描述（图中省略了关于中断仲裁或控制部分）。其中，虚线表示事件，或系统产生的操作。</p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020151011923.png" class="" alt="image-20241020151011923">
<h3 id="申请I-O服务："><a href="#申请I-O服务：" class="headerlink" title="申请I/O服务："></a><strong>申请I/O服务</strong>：</h3><p>运行中进程需要在某处执行有关I/O指令以进行数据输入输出。<strong>此时用户利用的指令要么是访管指令，要么是某种系统调用</strong>，<strong>无论那种形式，都属于自愿性中断而进入中断处理</strong>；也可能由于没有所要求空闲I/O设备而进入阻塞状态，进入由于等待某类I/O的阻塞队列。</p>
<h3 id="I-O完成"><a href="#I-O完成" class="headerlink" title="I/O完成"></a>I/O完成</h3><p>I/O外设数据传输完成产生一个I/O完成中断信号而进入I/O中断处理。当前进程状态信息被保存后，系统分析中断原因，检查是否有等待此次I/O完成的在阻塞队列中的进程，如果有，则通过某种算法从阻塞队列中摘出一个相关的进程而进入就绪队列。这就是I/O完成，是<strong>由于I/外设完成中断信号所引起的从阻塞到就绪状态的转移</strong>。 </p>
<h3 id="时间片到-抢占"><a href="#时间片到-抢占" class="headerlink" title="时间片到/抢占"></a>时间片到/抢占</h3><p>这条边表明状态转移就比较明显了，就是由于系统定时间隔时钟中断所引起的当前进程的一个时间片用完而从运行状态转移到就绪状态。需要说明的是，这是分时系统所具有的最常见的状态转移。由于现代通用操作系统大多都具有分时特征，因而时钟在系统中是必不可少的。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>当我们清楚了以上状态转移原因，这条边所表明的状态转移也很容易理解。<strong>这涉及到调度的时机</strong>；如前面正在运行进程由于I/O申请<strong>自愿中断</strong>而进入阻塞状态时，系统就需要<strong>从就绪队列中选择一个就绪态进程投入运行而转换成运行态。</strong>产生调度的因素有很多，但基本都与中断有关。</p>
<p><strong><font color="red">进程状态变迁是由于中断，但中断不一定产生进程切换！</font></strong></p>
<h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><h4 id="非抢占方式"><a href="#非抢占方式" class="headerlink" title="非抢占方式"></a>非抢占方式</h4><p>进程被选中就一直运行下去（不会因为时钟中断而被迫让出CPU），直至完成工作、自愿放弃CPU、或因某事件而被阻塞才把CPU让出给其它进程。</p>
<h4 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h4><p>抢占方式发生的情况可为：</p>
<p><strong>新进程到达</strong>、<strong>出现中断且将阻塞进程转变为就绪进程</strong>、以及<strong>用完规定的时间片</strong>等。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>►系统中处于可运行状态进程的个数通常比处理机的个数要多，特别是在<strong>单处理机系统</strong>中尤为如此。这样就存在从就绪队列中选择哪一个进程，这就是调度算法问题。</p>
<h3 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h3><p>► 调度算法要考虑到公平性和用户的满意程度，即<strong>考虑面向系统和面向用户的两个准则</strong>。</p>
<p>  具体考虑有如下5个指标： </p>
<h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p>CPU利用率就是使CPU尽量处于忙状态，是系统的一个很重要的目标。通常，在一定的I/O等待时间的百分比之下，运行程序的道数越多，CPU空闲时间的百分比越低。 </p>
<h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>吞吐率就是单位时间内所处理的计算任务的数目，也是面向系统的一个重要指标。</p>
<h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>考虑到作业调度，则为作业等待进入内存、进程在就绪队列中等待、进程在CPU上执行和完成有关I/O操作所花费的时间总和。对于个作业 $i$，其<strong>周转时间为</strong>： </p>
<script type="math/tex; mode=display">
T_i=t_{ci}-t_{si}\\
t_{ci}为完成时间\\
t_{si}为到达系统的时间</script><p>系统中 $n$ 个作业平均周转时间为:</p>
<script type="math/tex; mode=display">
\bar{T}=\frac{1}{n}\sum_{i=1}^nT_i</script><p>带权周转时间为:</p>
<script type="math/tex; mode=display">
W=\frac{T}{R}\\
其中 \quad R=\frac{实际服务时间}{运行时间}</script><p>（带权周转时间衡量长短任务的差别），由此可以得到平均带权周转时间为:</p>
<script type="math/tex; mode=display">
\bar{R}&=\frac{1}{n}\sum_{i=1}^n W_i\\
&=\frac{1}{n}\sum_{i=1}^n \frac{T_i}{R_i}</script><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>n响应时间就是从任务就绪到处理开始（也有的称为<strong>等待时间</strong>）。</p>
<p>  <strong>►</strong> 在交互式系统中，<strong>周转时间</strong>不可能是最好的评价准则。因为不断请求与不断输出在同时发生。</p>
<p>  <strong>►</strong> 通常，<strong>响应时间一般用于分时系统性能评价</strong>，指用户通过键盘或终端提出一个请求开始到系统给出相应的响应结果的时间（<strong>与上面有所不同</strong>）。</p>
<h4 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h4><p>系统开销就是系统调度任务的过程中所付出的<strong>时/空代价</strong>。 </p>
<h3 id="几种调度算法"><a href="#几种调度算法" class="headerlink" title="几种调度算法"></a>几种调度算法</h3><h4 id="先来先服务-FCFS-First-come-first-served"><a href="#先来先服务-FCFS-First-come-first-served" class="headerlink" title="先来先服务(FCFS, First come first served)"></a>先来先服务(FCFS, First come first served)</h4><p>  也称为先进先出（FIFO），或严格排队方式。</p>
<ul>
<li><p><strong>对于作业调度</strong>，该算法就是从后备作业队列中（按进入的时间顺序排队）选择队首一个或几个作业，调入内存，创建进程，放入就绪队列。</p>
</li>
<li><p><strong>对于进程调度</strong>，该算法就是从就绪队列中选择一个最先进入队列的进程，将CPU分配于它。</p>
</li>
</ul>
<p>优缺点:</p>
<ul>
<li><p>有利于长作业（进程）而不利于短作业（进程）</p>
</li>
<li><p>有利于CPU繁忙型作业（进程）而不利于I/O繁忙型作业（进程）</p>
</li>
</ul>
<h4 id="短作业优先-SJF-Shortest-job-first"><a href="#短作业优先-SJF-Shortest-job-first" class="headerlink" title="短作业优先(SJF Shortest job first )"></a>短作业优先(SJF Shortest job first )</h4><p>该算法从就绪队列中选出下一个“CPU执行期最短”的进程，将CPU分配于它。</p>
<p>优缺点:</p>
<ul>
<li>对短作业有利，明显的作业E提前接受了服务，并且整体性能也得到了提高；</li>
<li>需要事先知道或至少需要<strong>估计每个作业所需的处理机时间</strong>。</li>
<li>只要不断的有短作业进入系统，就有可能使长作业长期得不到运行而“饿死”。</li>
<li>SJF 偏向短作业，不利于分时系统（由于不可抢占性）。</li>
</ul>
<h4 id="最高响应比（HRP）"><a href="#最高响应比（HRP）" class="headerlink" title="最高响应比（HRP）"></a>最高响应比（HRP）</h4><p>考虑响应比</p>
<script type="math/tex; mode=display">
R=\frac{响应时间+运行时间}{运行时间}</script><p>既考虑了在系统的等待时间，又考虑了作业自身所需的运行时间，综合了FCFS与SJP各自特点。在进行进程调度时，从中<strong>选择响应比高者</strong>的进程投入运行。</p>
<p>从<strong>平均周转时间及其平均带权周转时间</strong>来看，<strong>HRP 刚好介于FCFS与SJP之间</strong>，即好于FCFS，次于SJP。 </p>
<h4 id="最短剩余时（SRT-，Shortest-remaining-time）"><a href="#最短剩余时（SRT-，Shortest-remaining-time）" class="headerlink" title="最短剩余时（SRT ，Shortest remaining time）"></a>最短剩余时（SRT ，Shortest remaining time）</h4><p>►SRT是针对 SJF 增加了<strong>强占机制</strong>的一种调度算法，它总是<strong>选择预期剩余时间最短的进程</strong>。只要<strong>新进程就绪</strong>，且有更短的剩余时间，调度程序就可能抢占当前正在运行的进程。</p>
<p>► SRT不象FCFS偏向长进程，也不象轮转法（下个算法）产生额外的中断，从而<strong>减少了开销</strong>。</p>
<p>► 必须记录过去的服务时间，从而<strong>增加了开销</strong>。</p>
<p>► 从周转时间来看，SRT 比SJF 有更好的性能。</p>
<p><strong>平均周转时间和带权平均周转时间</strong>说明了SRT<strong>好于前面的任何一个算法</strong>（<strong>因为它具有抢占的特点</strong>）。其过程的另一种简单描述：</p>
<h4 id="轮转（RR-Round-Robin）"><a href="#轮转（RR-Round-Robin）" class="headerlink" title="轮转（RR  Round Robin）"></a>轮转（RR  Round Robin）</h4><script type="math/tex; mode=display">
T=q\times n</script><p>参数说明:</p>
<ul>
<li><strong>系统响应时间 $T$</strong>:在进程数目一定时，时间片的长短直接正比于系统响应时间。</li>
<li><strong>就绪队列进程数目 $n$ </strong> :当系统要求的响应时间一定时，时间片反比于就绪队列中进程的数目。</li>
<li><strong>时间片$q$ </strong>:时间片的长短，CPU运行指令的速度；CPU速度快，q可以小一些，反之亦然。 </li>
</ul>
<p>轮转法设计的问题是时间片的长度：</p>
<ul>
<li><p>时间片设得太短会导致过多的进程切换，降低了 CPU效率</p>
</li>
<li><p>而得太长又可能引起对短的交互请求的响应时间变长</p>
</li>
<li><p>将设时间片设为 20ms~50ms 通常是一个比较合理的折中</p>
</li>
</ul>
<h4 id="优先级法-HPF"><a href="#优先级法-HPF" class="headerlink" title="优先级法(HPF)"></a>优先级法(HPF)</h4><p>轮转调度做了一个隐含的假设，即所有的进程同等重要，而拥有和操作多用户计算机系统的人对此常有不同的看法。</p>
<p>例如，在安卓操作系统里，等级顺序由高到低依次为前台进程，可视进程，服务进程，后台进程和空进程。</p>
<p>这就导致了优先级调度。其基本思想很清楚：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。</p>
<p><strong>如何确定进程优先级</strong>。有两种确定的方法：</p>
<ul>
<li><p><strong>静态优先级</strong>：进入系统时赋予一个优先级，在整个生命周期中一直固定不变（可能不公平）。</p>
</li>
<li><p><strong>动态优先级</strong>：创建时赋予一个优先级，可以动态改变。如处于就绪状态时，进程的优先级应随着等待时间的增长而增高。</p>
<ul>
<li><p>优点可使资源利用率得以提高，公平性比较好。</p>
</li>
<li><p>缺点是系统开销大，实现比较复杂。 </p>
</li>
</ul>
</li>
</ul>
<p>可以很方便地<strong>将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。</strong></p>
<p>下图给出了一个有4类优先级的系统，其调度算法如下：</p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020160242976.png" class="" alt="image-20241020160242976">
<p>只要存在优先级为第4类的可运行进程，就按照轮转法为每个进程运行一个时间片，此时不理会较低优先级的进程。若第4类进程为空，则按照轮转法运行第3类进程。若第4类和第3类均为空，则按轮转法运行第2类进程。</p>
<p>如果不偶尔对优先级进行调整，则低优先级进程很可能会产生饥饿现象。 </p>
<h4 id="多级队列-MQ——Multilevel-Queue"><a href="#多级队列-MQ——Multilevel-Queue" class="headerlink" title="多级队列(MQ——Multilevel Queue)"></a>多级队列(MQ——Multilevel Queue)</h4><p>可根据进程某些特性，如优先级，类型等分成几个单独队列；<strong>每个队列可有各自调度算法</strong>。例如，前台利用 RR ，后台利用 FCFS 等。 </p>
<img src="/2024/10/20/Operating%20System-process%20scheduling/image-20241020160323755.png" class="" alt="image-20241020160323755">
<p>►<strong>何时有可能调用到处理机调度程序呢？前提条件是必须进入操作系统，即处于系统态</strong>。</p>
<p>► 处于用户态运行的用户程序不可能直接调用操作系统中的任何模块（系统调用的例行服务程序除外）。</p>
<p>   一般在以下事件发生后要执行进程调度： </p>
<ul>
<li><strong>创建进程</strong>；创建进程时。 </li>
<li><strong>进程终止</strong>；一个进程终止时必须进行调度。如果没有就绪进程，系统通常会启动一个空转进程(休闲进程)等待(硬/软)中断的发生。 </li>
<li><strong>等待事件</strong>；进程由于等待I/O、信号量或其它原因而放弃CPU，这样就必须选择另外一个进程。 </li>
<li><strong>中断发生</strong>；当发生I/O中断，原先等待I/O的进程就从阻塞态转变成就绪态，是否可强占。 </li>
<li><strong>运行到时</strong>；在分时系统中，当前进程用完给定的时间片，时钟中断使该进程让出CPU进入调度。 </li>
</ul>
<h1 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h1><p>实时系统是一种时间起着主导作用的系统。</p>
<ul>
<li><p>实时系统通常可以分为硬实时和软实时，前者的含义是必须满足绝对的截止时间，后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p>
</li>
<li><p>在这两种情形中，实时性能都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前掌握的。这些进程一般寿命较短，并且极快地就运行完成。</p>
</li>
<li><p>在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p>
</li>
</ul>
<p>实时系统的调度算法可以是静态或动态的，前者在系统开始运行之前作出调度决策；后者在运行过程中进行调度决策</p>
<p>只有在可以提前掌握所完成的工作以及必须满足的截止时间等全部信息时，静态调度才能工作。而动态调度算法不需要这些限制。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System-死锁</title>
    <url>/2024/12/13/Operating-System-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><p>指多个进程在运行过程中因争夺资源而造成的一种僵局（deadly-Embrace)，若无外力作用，这些进程都将无法向前推进。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>参与死锁的进程数至少为2</p>
</li>
<li><p>参与死锁的所有进程均等待资源</p>
</li>
<li><p>参与死锁的进程至少有两个占有资源</p>
</li>
<li><p>参与死锁的进程是系统中当前正在运行进程的一部分。</p>
</li>
</ul>
<h1 id="产生死锁的条件和处理"><a href="#产生死锁的条件和处理" class="headerlink" title="产生死锁的条件和处理"></a><strong>产生死锁的条件和处理</strong></h1><h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><p>​     操作系统管理着系统内所有资源，它负责分配不同类型的资源给进程使用，系统中的资源从不同角度可分：</p>
<p> <strong>根据资源本身的性质</strong></p>
<ul>
<li><p>可剥夺资源：如主存、CPU</p>
</li>
<li><p>不可剥夺资源：如驱动器、打印机等</p>
<p><strong>根据资源使用期限</strong></p>
</li>
<li><p>永久性资源：可再次使用，如所有硬件。</p>
</li>
<li><p>临时性资源：消耗性的资源，如消息、信号和数据</p>
</li>
</ul>
<h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><h3 id="竞争非剥夺性资源"><a href="#竞争非剥夺性资源" class="headerlink" title="竞争非剥夺性资源"></a>竞争非剥夺性资源</h3><h3 id="竞争临时性资源"><a href="#竞争临时性资源" class="headerlink" title="竞争临时性资源"></a>竞争临时性资源</h3><h3 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h3><p>422</p>
<p>543</p>
<h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><h4 id="互斥条件（资源独占）"><a href="#互斥条件（资源独占）" class="headerlink" title="互斥条件（资源独占）"></a><strong>互斥条件</strong>（资源独占）</h4><p>一个资源每次只能给一个进程使用</p>
<h4 id="请求和保持条件（部分分配，占有申请）"><a href="#请求和保持条件（部分分配，占有申请）" class="headerlink" title="请求和保持条件（部分分配，占有申请）"></a><strong>请求和保持条件</strong>（部分分配，占有申请）</h4><p>（部分分配，占有申请）</p>
<p>一个进程在申请新的资源的同时保持对原有资源的占有</p>
<p>（只有这样才是动态申请，动态分配）</p>
<h4 id="非剥夺条件（不可强占）"><a href="#非剥夺条件（不可强占）" class="headerlink" title="非剥夺条件（不可强占）"></a><strong>非</strong>剥夺条件（不可强占）</h4><p> 资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放</p>
<h4 id="循环等待条件"><a href="#循环等待条件" class="headerlink" title="循环等待条件"></a><strong>循环</strong>等待条件</h4><p> 存在一个进程等待队列</p>
<p> {P1 , P2 , … , Pn},</p>
<p>  其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路</p>
<h3 id="四种基本处理方法"><a href="#四种基本处理方法" class="headerlink" title="四种基本处理方法"></a>四种基本处理方法</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>指通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>指在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。</p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</p>
<h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来</p>
<h1 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h1><h2 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h2><p>（不可行）</p>
<p>   即允许多个进程同时访问资源。但由于资源本身固有特性限制，有的资源根本不能同时访问，只能互斥访问，所以不可能用破坏互斥条件来预防死锁。</p>
<h2 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a><strong>破坏请求和保持条件</strong></h2><p>​         可采用<strong>预先静态分配方法</strong>，即要求进程在运行之前一次申请它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦运行后，这些资源全归其占有，同时它也不再提出其它资源要求，这样可以保证系统不会发生死锁。</p>
<p>​       此方法虽简单安全，但降低了资源利用率，同时必须预知进程所需要的全部资源。</p>
<h2 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h2><p>   一个已经获得某些资源的进程，若又请求新的资源时不能得到满足，则它必须释放出已获得的所有资源，以后需要资源时再请求。即一个进程已获得的资源在运行过程中可被剥夺。从而破坏了“不剥夺”条件。</p>
<p>   这种方法实现较复杂，会增加系统开销，降低系统吞吐量。</p>
<h2 id="破坏环路条件"><a href="#破坏环路条件" class="headerlink" title="破坏环路条件"></a>破坏环路条件</h2><p>​       可采用<strong>有序资源分配方法</strong>，即将系统中的所有资源都按类型赋予一个编号，要求每一个进程均严格按照编号递增的次序来请求资源，同类资源一次申请完。也就是，只要进程提出请求资源Ri，则在以后的请求中，只能请求Ri后面的资源，这样不会出现几个进程请求资源而形成环路。</p>
<p>​      该方法虽提高了资源的利用率，但编号难，加重进程负担及因使用资源顺序与申请顺序不同而造成资源浪费。</p>
<h1 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>定义:系统运行过程中， 允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。</p>
<h3 id="安全序列和安全状态"><a href="#安全序列和安全状态" class="headerlink" title="安全序列和安全状态"></a>安全序列和安全状态</h3><p>指在某一时刻，系统能按某种<strong>进程顺序</strong>(P1,P2,…，Pn)来为每个进程Pi分配其资源,直到满足每个进程对资源的最大需求,使每个进程都可顺利地完成，称此时的系统状态为安全状态，称序列(P1,P2,…，Pn)为安全序列。</p>
<p>   若某一时刻系统中不存在这样一个安全序列，则称此时的系统状态为不安全状态。</p>
<p>在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可以避免死锁的发生。</p>
<h3 id="死锁和安全-不安全的关系"><a href="#死锁和安全-不安全的关系" class="headerlink" title="死锁和安全/不安全的关系"></a>死锁和安全/不安全的关系</h3><p>在死锁避免的方法中，允许进程动态申请资源，系统在进行资源分配之前，先计算资源分配的安全性，若此次分配不会导致系统进入不安全状态，便将资源分配给进程，否则进程等待。</p>
<ul>
<li><p><strong>如果一个系统在安全状态，就没有死锁</strong></p>
</li>
<li><p><strong>如果一个系统处于不安全状态，就有可能死锁</strong></p>
</li>
<li><p><strong>避免死锁的实质</strong>：确保系统不进入不安全状态</p>
</li>
</ul>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>具有代表性的避免死锁算法，是Dijkstra给出的银行家算法。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>实现银行家算法，须设置若干数据结构。假定系统中有n个进程（P1，P2，…，Pn），m类资源（R1，R2，…，Rm），银行家算法中使用的数据结构如下：</strong></p>
<ul>
<li><p><strong>可利用资源向量：</strong>available[j]=k, 资源Rj类有k个可用**</p>
</li>
<li><p><strong>最大需求矩阵：</strong>Max[i,j]=k,进程Pi最大请求k个Rj类资源</p>
</li>
<li><p><strong>分配矩阵：</strong>Allocation[i,j]=k,进程Pi分配到k个Rj类资源</p>
</li>
<li><p><strong>需求矩阵：</strong>Need[i,j]=k,进程Pi还需要k个Rj类资源**</p>
</li>
<li><strong>请求向量</strong>： Requesti,是进程Pi的请求向量。Requesti [j] =k，表示进程Pi请求分配Rj类资源k个。</li>
</ul>
<p><strong>三个矩阵的关系：</strong></p>
<p><strong>Need [i,j] = Max[i,j]</strong> <strong>–</strong> <strong>Allocation [i,j]</strong></p>
<h3 id="安全性检查"><a href="#安全性检查" class="headerlink" title="安全性检查"></a>安全性检查</h3><p>当进程Pi 发出资源请求后，系统按如下步骤进行检查：</p>
<p>(1)如Requesti[j]≤Need[i,j],转(2);否则出错，因为进程申请资源量超过它声明的最大量。</p>
<p>(2)如Requesti[j] ≤Available[j],转(3);否则表示资源不够，需等待。</p>
<p>(3)系统试分配资源给进程Pi，并作如下修改：</p>
<p>Available[j]:= Available[j]- Requesti[j]</p>
<p>Allocation[i,j]:= Allocation[i,j]+ Requesti[j]</p>
<p>Need[i,j]:= Need[i,j]- Requesti[j]</p>
<p>(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，则正式进行分配，否则恢复原状态，让进程Pi等待。</p>
<p>为了进行安全性检查，需要定义如下数据结构</p>
<ul>
<li><p>int Work[m]  工作变量，记录可用资源。开始时， Work:= Available</p>
</li>
<li><p>boolean Finish[n] 工作变量，记录进程是否执行完。开始时， Finish[i]=false;当有足够资源分配给进程Pi时，令Finish[i]=true。</p>
</li>
</ul>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>3310</p>
<h1 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h1><p>如果在一个系统中，既未采用死锁预防方法，也未采用死锁避免方法，而是直接为进程分配资源，则系统中便有可能发生死锁。一旦死锁发生，系统应能将其找到并加以消除，为此需提供死锁检测和解除的手段。</p>
<h2 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h2><p>   检测死锁的基本思想: 在操作系统中保存资源的请求和分配信息，利用某种算法对这些信息加以检查，以判断是否存在死锁。为此，将进程和资源间的申请和分配关系描述成一个有向图—-资源分配图。</p>
<p>   资源分配图又称进程-资源图，它描述了进程和资源间的申请和分配关系，该图是一个有向图，具有以下定义和限制：</p>
<p>一个结点集合N和边集合E</p>
<p><strong>结点N</strong>被分为两个互斥子集</p>
<ul>
<li><p><strong>进程结点子集</strong> <strong>P = {P1,P2,…,Pn}</strong></p>
</li>
<li><p><strong>资源结点子集 R = {R1,R2 , … ,Rm}</strong></p>
</li>
<li><p><strong>N=PUR={P1,P2,…,Pn}U{R1,R2,…,Rm}</strong></p>
</li>
</ul>
<p>圆圈表示一进程，方框表示一类资源，其数目由方框中的小圆圈数表示</p>
<p><strong>边E</strong> </p>
<ul>
<li><p><strong>请求边：直接 $P_i\to R_j$ 即 $e=(P_i,R_j)$</strong></p>
</li>
<li><p><strong>分配边：$P_i\leftarrow R_j$即$e=(R_j,P_i)$</strong></p>
</li>
</ul>
<p>3975</p>
<p><strong>如果一个图中没有环路（也称回路），则系统中不存在死锁；若有环路，系统可能存在死锁。</strong></p>
<p>即可说，环路是死锁的必要条件，但不是充分条件。</p>
<h2 id="资源分配图的化简"><a href="#资源分配图的化简" class="headerlink" title="资源分配图的化简"></a>资源分配图的化简</h2><p>​       <strong>可以通过对资源分配图进行化简，来判断系统是否处于死锁状态。资源分配图中的约简方法如下：</strong></p>
<p>（1）寻找一个既不阻塞又非孤立的进程结点Pi，若无，则算法结束；</p>
<p> （2）去除Pi的所有分配边和请求边，使Pi成为一个孤立节点；</p>
<p> （3）转步骤（1）。</p>
<p>在进行一系列化简后，若能消去图中所有的边，使所有进程都成为孤立结点，则称该图是可完全简化的；反之，称该图是不可完全简化的。</p>
<p>4386</p>
<h3 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h3><p>S为死锁状态的充分条件是，当且仅当S状态的资源分配图是不可完全简化的，该充分条件称为死锁定理。</p>
<h3 id="化简步骤"><a href="#化简步骤" class="headerlink" title="化简步骤"></a>化简步骤</h3><p>①先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞（“不阻塞”即：系统有足够的空闲资源分配给它）的</p>
<p>②<strong>接着把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来</strong></p>
<p>③<strong>这样，系统剩余的空闲资源便多了起来，接着又去看看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。</strong></p>
<p>④<strong>最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”。</strong></p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>4841</p>
<p><strong>第一步</strong>：分析资源 R1。它有三个向外的箭头，表示已向进程分配了 3 个资源实例，此时 R1 已无可用资源。</p>
<p><strong>第二步</strong>：分析资源 R2。它有一个向外的箭头，表示已分配 1 个资源实例，此时 R2 还剩余 1 个空闲资源。</p>
<p><strong>第三步</strong>：分析进程 P2。P2 正在申请 1 个 R1 资源，但 R1 已全部分配完毕。因此，进程 P2 因资源不足进入阻塞状态，无法被简化为孤立节点。</p>
<p>5201</p>
<p><strong>第四步</strong>：分析进程 P1。P1 申请 1 个 R2 资源，而此时 R2 尚有 1 个可用资源，因此该请求可以被满足。P1 在获得所需资源后即可顺利执行，并在执行完毕后释放其占有的所有资源。在资源分配图中，这意味着可以移除所有与 P1 相连的边，使其成为一个孤立节点，如图 2 所示。</p>
<p>5513</p>
<p><strong>第五步</strong>：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成图3</p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>5882</p>
<h4 id="一、资源状态分析"><a href="#一、资源状态分析" class="headerlink" title="一、资源状态分析"></a>一、资源状态分析</h4><p>首先，分析系统中各类资源的初始分配情况：</p>
<ul>
<li><strong>R1</strong>：共有 1 个实例，且已分配。当前可用数量为 0。</li>
<li><strong>R2</strong>：共有 2 个实例，均已分配。当前可用数量为 0。</li>
<li><strong>R3</strong>：共有 2 个实例，其中 1 个已分配，尚有 1 个可用。</li>
<li><strong>R4</strong>：共有 1 个实例，且已分配。当前可用数量为 0。</li>
</ul>
<p>综上，当前系统中仅有 R3 尚余 1 个可用资源实例。</p>
<h4 id="二、进程请求分析"><a href="#二、进程请求分析" class="headerlink" title="二、进程请求分析"></a>二、进程请求分析</h4><p>接下来，分析各进程的资源请求是否能被满足：</p>
<ul>
<li><strong>进程 P1</strong>：请求资源 R1。由于 R1 已无可用实例，P1 进入阻塞状态。</li>
<li><strong>进程 P2</strong>：请求资源 R4。由于 R4 已无可用实例，P2 进入阻塞状态。</li>
<li><strong>进程 P3</strong>：请求资源 R2 和 R3。尽管 R3 有可用实例，但由于 R2 已全部分配，P3 的请求同样无法被满足，进入阻塞状态。</li>
</ul>
<h4 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h4><p>分析可知，所有进程（P1, P2, P3）均因请求的资源无法得到满足而处于阻塞状态。因此，资源分配图中不存在任何可以首先执行完毕并释放资源的进程，导致该图无法被完全简化。</p>
<p>这表明系统已经产生了<strong>死锁</strong>。</p>
<h1 id="死锁的综合处理策略"><a href="#死锁的综合处理策略" class="headerlink" title="死锁的综合处理策略"></a>死锁的综合处理策略</h1>]]></content>
  </entry>
  <entry>
    <title>Operating-System-存储管理之分页</title>
    <url>/2024/12/15/Operating-System-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>逻辑空间划分</strong>：将进程的逻辑地址空间划分为若干个大小相等的区域，称为 <strong>页 (Page)</strong>，并从 0 开始连续编号。</li>
<li><strong>物理空间划分</strong>：将物理内存空间划分为与页大小相等的区域，称为 <strong>物理块</strong> 或 <strong>页框 (Frame)</strong>，同样从 0 开始连续编号。</li>
</ol>
<p>为了实现从逻辑页到物理块的映射，系统为每个进程建立一张 <strong>页表 (Page Table)</strong>。</p>
<ul>
<li><strong>作用</strong>：记录进程的每个页存放在哪个物理块中。</li>
<li><strong>存储位置</strong>：页表本身通常存放在内存中。</li>
<li><strong>寻址方式</strong>：通过 <strong>页表寄存器 (PTR)</strong> 定位，该寄存器存放页表的基地址和长度。</li>
<li><strong>性能影响</strong>：每次访问逻辑地址都需要 <strong>两次内存访问</strong>（一次访问页表获取块号，一次访问目标数据），导致执行速度显著下降。</li>
</ul>
<h2 id="地址结构与变换"><a href="#地址结构与变换" class="headerlink" title="地址结构与变换"></a>地址结构与变换</h2><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p>逻辑地址通常由 <strong>页号 (P)</strong> 和 <strong>页内偏移 (w)</strong> 两部分组成。</p>
<ul>
<li><strong>示例</strong>：在一个 32 位地址空间、页面大小为 4KB ($2^{12}$B) 的系统中：<ul>
<li><strong>0-11 位</strong>：页内偏移 (w)，共 12 位，决定了页面大小为 4KB。</li>
<li><strong>12-31 位</strong>：页号 (P)，共 20 位，表示逻辑地址空间最多可有 $2^{20}$ (即 1M) 个页面。</li>
</ul>
</li>
</ul>
<p>若给定逻辑地址 A 和页面大小 L，则：</p>
<ul>
<li>页号 <code>P = INT(A / L)</code></li>
<li>页内偏移 <code>w = A MOD L</code></li>
</ul>
<p><strong>例</strong>：页面大小为 1KB (1024B)，逻辑地址 A = 2170。</p>
<ul>
<li>P = INT(2170 / 1024) = 2</li>
<li>w = 2170 MOD 1024 = 122</li>
</ul>
<h4 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p>地址变换机构的任务是将逻辑地址转换为物理地址，其核心是利用页表完成 <strong>页号</strong> 到 <strong>块号</strong> 的转换。</p>
<h2 id="性能问题与快表-TLB"><a href="#性能问题与快表-TLB" class="headerlink" title="性能问题与快表 (TLB)"></a>性能问题与快表 (TLB)</h2><p>分页机制导致每次访存都需要两次内存操作，性能减半。为解决此问题，引入了硬件支持——<strong>快表</strong>。</p>
<h4 id="快表-Translation-Lookaside-Buffer-TLB"><a href="#快表-Translation-Lookaside-Buffer-TLB" class="headerlink" title="快表 (Translation Lookaside Buffer, TLB)"></a>快表 (Translation Lookaside Buffer, TLB)</h4><p>快表是一种基于程序 <strong>局部性原理</strong> 设计的特殊高速缓存，也称 <strong>联想寄存器</strong>。</p>
<ul>
<li><strong>内容</strong>：缓存了页表中的部分常用条目（页号 → 块号）。</li>
<li><strong>工作流程</strong>：<ol>
<li>CPU 产生逻辑地址后，首先在 <strong>快表</strong> 中查找页号。</li>
<li><strong>命中 (Hit)</strong>：若在快表中找到，直接获取对应的物理块号，与页内偏移组合成物理地址。只需一次快表访问和一次内存访问。</li>
<li><strong>未命中 (Miss)</strong>：若未找到，则需访问内存中的 <strong>页表</strong>，找到对应的物理块号，然后将该页表项 <strong>存入快表</strong>（若快表已满，则按替换算法淘汰一项）。此过程需要一次快表访问和两次内存访问。</li>
</ol>
</li>
</ul>
<h4 id="引入快表后的有效访问时间-EAT"><a href="#引入快表后的有效访问时间-EAT" class="headerlink" title="引入快表后的有效访问时间 (EAT)"></a>引入快表后的有效访问时间 (EAT)</h4><p>假设快表命中率为 <code>p</code>，访问快表时间为 <code>t_tlb</code>，访问内存时间为 <code>t_mem</code>，则有效访问时间为：</p>
<p><strong>EAT = p × (t_tlb + t_mem) + (1 - p) × (t_tlb + 2 × t_mem)</strong></p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>对于 32 位系统，若页面为 4KB，页表项为 4B，则一个进程的页表最大需要 <code>2^20 * 4B = 4MB</code> 的连续内存空间，这非常巨大。对于 64 位系统，单级页表的空间开销更是无法接受。</p>
<p>为解决此问题，引入了 <strong>多级页表</strong> 机制。其核心思想是 <strong>对页表本身进行分页</strong>，将外层页表离散地存放在物理块中，并用更高一级的页表来索引它们。</p>
<h4 id="逻辑地址结构（已补充完整）"><a href="#逻辑地址结构（已补充完整）" class="headerlink" title="逻辑地址结构（已补充完整）"></a>逻辑地址结构（已补充完整）</h4><p>在多级页表结构中，原有的页号部分被进一步划分为多个字段，对应不同级别的页表。</p>
<p>以 <strong>两级页表</strong> 为例，逻辑地址结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">外层页号 (P1)</th>
<th style="text-align:center">内层页号 (P2)</th>
<th style="text-align:center">页内偏移 (w)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>地址变换过程</strong>：</p>
<ol>
<li>使用 <strong>外层页号 (P1)</strong> 作为索引，访问顶级页表，找到二级页表的基地址。</li>
<li>使用 <strong>内层页号 (P2)</strong> 作为索引，访问对应的二级页表，找到目标页面所在的 <strong>物理块号</strong>。</li>
<li>将获取的物理块号与 <strong>页内偏移 (w)</strong> 拼接，形成最终的物理地址。</li>
</ol>
<p>这种方式的优点在于，二级页表只有在被需要时才创建和调入内存，极大地节省了内存空间。</p>
<hr>
<h2 id="例题解析"><a href="#例题解析" class="headerlink" title="例题解析"></a>例题解析</h2><p><strong>题目</strong>：一个计算机系统有 32 位虚拟地址空间和 20 位物理地址空间，采用两级页表机制，一级页表域（外层页号）长为 10 位，二级页表域（内层页号）长为 10 位。请问页面容量为多少？有多少个页框？</p>
<p><strong>解答</strong>：</p>
<ol>
<li><p><strong>计算页面容量（页面大小）</strong>：</p>
<ul>
<li>虚拟地址总长度为 32 位。</li>
<li>页号部分由两级构成：外层页号 (10 位) + 内层页号 (10 位) = 20 位。</li>
<li>页内偏移位数 = 总位数 - 页号位数 = 32 - 20 = 12 位。</li>
<li>因此，页面容量为 $2^{12}$ B = <strong>4096 B (即 4KB)</strong>。</li>
</ul>
</li>
<li><p><strong>计算页框数量</strong>：</p>
<ul>
<li>物理地址空间总长度为 20 位，所以物理内存总大小为 $2^{20}$ B。</li>
<li>页框大小与页面大小相等，即 4KB ($2^{12}$ B)。</li>
<li>页框数量 = 物理内存总大小 / 页框大小 = $2^{20} / 2^{12} = 2^8$ = <strong>256 个</strong>。</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Probability Theory and Mathematical Statistics-一维随机变量及其分布</title>
    <url>/2024/09/12/Probability%20Theory%20and%20Mathematical%20Statistics-%E4%B8%80%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<h1 id="Gamma函数及其分布"><a href="#Gamma函数及其分布" class="headerlink" title="Gamma函数及其分布"></a>Gamma函数及其分布</h1><h2 id="Gamma函数及其性质"><a href="#Gamma函数及其性质" class="headerlink" title="Gamma函数及其性质"></a>Gamma函数及其性质</h2><script type="math/tex; mode=display">
\Gamma(\alpha)=\int_0^{+\infty}{x^{\alpha-1}e^{-x}}\mathrm{d}x</script><p>性质如下:</p>
<ul>
<li>$\Gamma(1)=1$    $\Gamma(\dfrac{1}{2})=\sqrt{\pi}$</li>
<li>$\Gamma(\alpha+1)=\alpha\Gamma(\alpha)$    $\Gamma(n+1)=n\Gamma(n)=n!$    when $n$ is in $N$</li>
</ul>
<h2 id="Gamma分布"><a href="#Gamma分布" class="headerlink" title="Gamma分布"></a>Gamma分布</h2><p>若随机变量X的密度函数为:</p>
<script type="math/tex; mode=display">
p(x)=
\left\{
\begin{aligned}
\dfrac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1} \mathrm {e}^{-\lambda x}\mathrm dx ,x\ge0\\
0,x<0
\end{aligned}
\right.</script><p>记作$X\sim Ga(\alpha,\lambda)$</p>
<p>性质</p>
<ul>
<li>数学期望$ E(X)=\dfrac{\alpha}{\lambda} $</li>
<li>方差$Var(X)=\dfrac{\alpha}{\lambda^2} $</li>
</ul>
<h2 id="Gamma分布的两个特例"><a href="#Gamma分布的两个特例" class="headerlink" title="Gamma分布的两个特例"></a>Gamma分布的两个特例</h2><p>当$\alpha=1$的时候，Gamma分布为<strong>指数分布</strong></p>
<script type="math/tex; mode=display">
Ga(1,\lambda)=Exp(\lambda)</script><p>当$\alpha=\dfrac{n}{2},\lambda=\dfrac{1}{2}$的时候，Gamma分布为<strong>自由度为$n$的卡方分布</strong></p>
<script type="math/tex; mode=display">
Ga(\dfrac{n}{2},\dfrac{1}{2})=\chi ^2(n)</script><p>$\chi ^2$分布的密度函数为</p>
<script type="math/tex; mode=display">
p(x) =
\begin{cases}
\dfrac{\mathrm{e}^{-\frac{x}{2}} x^{\frac{n}{2}-1}}{2^{\frac{n}{2}} \Gamma(\frac{n}{2})}, & x > 0; \\
0, & x \leq 0.
\end{cases}</script><p>$n$是$\chi ^2$分布的唯一参数，称之为自由度，它可以取实数。</p>
<ul>
<li><p>$E(X)=n$</p>
</li>
<li><p>$Var(X)=2n$</p>
<h2 id="beta-分布"><a href="#beta-分布" class="headerlink" title="$\beta$分布"></a><strong>$\beta$</strong>分布</h2><script type="math/tex; mode=display">
p(x)=\begin{cases}\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}x^{a-1}(1-x)^{b-1},&0<x<1;\\0,&\text{其他,}\end{cases}</script></li>
</ul>
<h1 id="K阶矩"><a href="#K阶矩" class="headerlink" title="K阶矩"></a>K阶矩</h1><p>  我们称 $\mu^k=E(X^k)$ 为随机变量$X$的 <strong>$k$ 阶原点矩</strong>，称 $\nu^k=E[X-E(X)]^k$ 为随机变量 $X$ 的 <strong>$k$ 阶中心矩</strong>.他们的关系如下:</p>
<script type="math/tex; mode=display">
  \nu_k=E[X-E(X)]^k=E(X-\mu_1)^k=\sum_{i=0}^k\binom{k}{i}\mu_i(-\mu_1)^{k-i}</script><h1 id="变异系数"><a href="#变异系数" class="headerlink" title="变异系数"></a>变异系数</h1><p>  设随笔变量 $X$ 的二阶矩存在，则称比值</p>
<script type="math/tex; mode=display">
  C_v(X)=\dfrac{\sqrt{Var(X)}}{E(X)}=\dfrac{\sigma(X)}{E(X)}</script><p>  为 $X$ 的<strong>变异系数</strong>.</p>
<h1 id="分位数与中位数"><a href="#分位数与中位数" class="headerlink" title="分位数与中位数"></a>分位数与中位数</h1><h2 id="下侧分位数"><a href="#下侧分位数" class="headerlink" title="下侧分位数"></a>下侧分位数</h2><p>  设连续随机变量 $X$ 的分布函数为 $F(x)$，密度函数为 $p(x)$ . 对任意 $p\in (0,1)$ ，称满足条件</p>
<script type="math/tex; mode=display">
F(x_p)=\int _{-\infty}^{x_p}p(x)\mathrm{d}x=p</script><p>的 $x_p$ 为此分布的 <strong>$p$ 分位数</strong>，又称为<strong>下侧 $p$ 分位数</strong>。</p>
<h2 id="上侧分位数"><a href="#上侧分位数" class="headerlink" title="上侧分位数"></a>上侧分位数</h2><p>设连续随机变量 $X$ 的分布函数为 $F(x)$，密度函数为 $p(x)$ . 对任意 $p\in (0,1)$ ，称满足条件</p>
<script type="math/tex; mode=display">
1-F(x'_p)=\int _{x'_p}^{+\infty}p(x)\mathrm{d}x=p</script><p>的 $x_p$ 为此分布的<strong>上侧 $p$ 分位数</strong>。</p>
<p>上侧分位数和下侧分位数的转换关系如下:</p>
<script type="math/tex; mode=display">
x'_p=x_{1-p}\quad,x_p=x'_{1-p}</script><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>设连续随机变量 $X$ 的分布函数为 $F(x)$,密度函数为 $p(x)$.称 $p=0.5$ 时的 $p$ 分位数$x<em>{0.5}$ 为此分布的中位数,即 $x</em>{0.5}$  满足</p>
<script type="math/tex; mode=display">
F(x_{0.5})=\int_{-\infty}^{0.5}p(x)\mathrm{d}x=0.5</script><h1 id="偏度系数和峰度系数"><a href="#偏度系数和峰度系数" class="headerlink" title="偏度系数和峰度系数"></a>偏度系数和峰度系数</h1><h2 id="偏度系数"><a href="#偏度系数" class="headerlink" title="偏度系数"></a>偏度系数</h2><p>设随机变量 $X$ 的三阶矩存在，则称比值</p>
<script type="math/tex; mode=display">
\beta_1=\frac{E[X-E(X)]^3}{[E(X-E(X))^2]^{3/2}}=\frac{\nu_3}{(\nu_2)^{3/2}}</script><p>为<strong>偏度系数</strong>，简称偏度。</p>
<p>偏度系数可以描述分布的形状特征，其取值的正负反映的是</p>
<ul>
<li>当  $\beta_1 &gt; 0$  时，分布为正偏或右偏；</li>
<li>当 $\beta_1= 0$  时，分布关于其均值 $ E(X) $ 对称;</li>
<li>当 $\beta_1 &lt; 0$  时，分布为负偏或左偏.<br>譬如，正态分布 $N(\mu,\sigma ^2) $ 是关于其均值 $E(X)=\mu$   是对称的，所以正态分布的偏度 $\beta_1= 0$</li>
</ul>
<h2 id="峰度系数"><a href="#峰度系数" class="headerlink" title="峰度系数"></a>峰度系数</h2><p>设随机变量 X 的四阶矩存在，则称比值</p>
<script type="math/tex; mode=display">
\beta_2=\frac{E[X-E(X)]^4}{[E(X-E(X))^2]^2}-3=\frac{\nu_4}{(\nu_2)^2}-3</script><p>为<strong>峰度系数</strong>，简称峰度。<br>一个分布的峰度系数 $\beta_2$  反映了以下情况：</p>
<ul>
<li>当 $\beta_2&lt;0$ 时,则标准化后的分布形状比标准正态分布更平坦,称为<strong>低峰度</strong>.</li>
<li>当 $\beta_2=0$ 时,则标准化后的分布形状比标准正态相当0.</li>
<li>当 $\beta_2&gt;0$ 时,则标准化后的分布形状比标准正态分布更尖峭,称为<strong>高峰度</strong>.</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearing-Function/lambda/re</title>
    <url>/2024/07/27/Python%20Relearing-Function%20lambda%20re/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h2><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。</p>
</li>
<li><h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><p><strong>不可变类型</strong>：<strong>变量赋值 </strong>a=5<strong> 后再赋值 </strong>a=10**，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</p>
</li>
<li><p><strong>可变类型</strong>：变量赋值la=[1,2,3,4]后再赋值la[2]=5则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p>
</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><p><strong>不可变类型</strong>：<strong>类似</strong> C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</p>
</li>
<li><p><strong>可变类型</strong>：<strong>类似</strong>C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changeme</span>(<span class="params"> mylist </span>):</span><br><span class="line">   <span class="string">&quot;修改传入的列表&quot;</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;函数内取值: &quot;</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;函数外取值: &quot;</span>, mylist)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数内取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">函数外取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h2 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h2><p>Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span><br><span class="line"> <span class="built_in">print</span>(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure>
<p>以下使用方法是正确的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>以下使用方法会发生错误:</p>
<p><del><code>f(10, b=20, c=30, d=40, e=50, f=60)</code></del>  # b 不能使用关键字参数的形式<br><del><code>f(10, 20, 30, 40, 50, f=60)</code></del>         # e 必须使用关键字参数的形式``</p>
</li>
<li><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="comment"># 函数操作</span></span><br></pre></td></tr></table></figure>
<pre><code>  例如：
</code></pre></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果已经有一个list或者tuple，要调用一个可变参数，可以加上*，</p>
<ul>
<li><p>方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。</p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)  </span><br></pre></td></tr></table></figure>
<h3 id="调用1"><a href="#调用1" class="headerlink" title="调用1"></a>调用1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;person(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用2"><a href="#调用2" class="headerlink" title="调用2"></a>调用2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city=<span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把组装好的字典作为关键字参数传入"><a href="#把组装好的字典作为关键字参数传入" class="headerlink" title="把组装好的字典作为关键字参数传入"></a>把组装好的字典作为关键字参数传入</h3><ul>
<li><p>方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=extra[<span class="string">&#x27;city&#x27;</span>], job=extra[<span class="string">&#x27;job&#x27;</span>])</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>方法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h2><p>在函数定义中使用 <code>*</code> 后的参数，它们必须在调用时以 <code>name=value</code> 的形式显式传递。</p>
</li>
</ul>
<p>限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br></pre></td></tr></table></figure>
<pre><code>    命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
</code></pre><p>调用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>
<pre><code>   命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<h2 id="参数的顺序"><a href="#参数的顺序" class="headerlink" title="参数的顺序"></a>参数的顺序</h2><p>在 Python 中，函数的参数顺序有一个明确的规定，这有助于确保函数调用时参数的正确匹配和解读。函数参数的顺序可以分为以下几种类型：</p>
<h3 id="函数参数的顺序"><a href="#函数参数的顺序" class="headerlink" title="函数参数的顺序"></a>函数参数的顺序</h3><ol>
<li><p><strong>位置参数（Positional Arguments）</strong>：</p>
<ul>
<li><p>这些参数在函数调用时通过位置传递。它们必须按照在函数定义中声明的顺序提供。</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># a=1, b=2, c=3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>默认参数（Default Arguments）</strong>：</p>
<ul>
<li><p>默认参数在函数定义时提供了一个默认值。如果调用时不提供该参数的值，则使用默认值。</p>
</li>
<li><p>默认参数必须在所有非默认参数之后定义。</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">2</span>, c=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)          <span class="comment"># a=1, b=2, c=3</span></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">4</span>)     <span class="comment"># a=1, b=2, c=4</span></span><br><span class="line">func(<span class="number">1</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)  <span class="comment"># a=1, b=5, c=6</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>关键字参数（Keyword Arguments）</strong>：</p>
<ul>
<li><p>这些参数在函数调用时通过指定名称来传递，可以改变参数的顺序。</p>
</li>
<li><p>关键字参数必须在所有位置参数之后提供。</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">func(a=<span class="number">1</span>, c=<span class="number">3</span>, b=<span class="number">2</span>)  <span class="comment"># a=1, b=2, c=3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>可变位置参数（*args）</strong>：</p>
<ul>
<li><p>用于接收任意数量的位置参数，这些参数将被收集到一个元组中。</p>
</li>
<li><p><code>*args</code> 必须在位置参数和默认参数之后定义。</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *args</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, args)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment"># a=1, b=2, args=(3, 4, 5)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>命名关键字参数（*）</strong>：</p>
<ul>
<li><p>用于定义所有后续的参数必须通过关键字传递。</p>
</li>
<li><p><code>*</code> 后面的参数称为命名关键字参数，调用时必须以 <code>name=value</code> 的形式指定。</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *, x=<span class="number">10</span>, y=<span class="number">20</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, x, y)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, x=<span class="number">30</span>, y=<span class="number">40</span>)  <span class="comment"># a=1, b=2, x=30, y=40</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>可变关键字参数（ </strong> kwargs）**：</p>
<ul>
<li><p>用于接收任意数量的关键字参数，这些参数将被收集到一个字典中。</p>
</li>
<li><p><code>**kwargs</code> 必须在所有位置参数、默认参数、<code>*args</code> 和命名关键字参数之后定义。</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, kwargs)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, x=<span class="number">30</span>, y=<span class="number">40</span>)  <span class="comment"># a=1, b=2, kwargs=&#123;&#x27;x&#x27;: 30, &#x27;y&#x27;: 40&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>位置参数</strong>：必须按照定义的顺序提供。</li>
<li><strong>默认参数</strong>：必须在所有位置参数之后定义，并且可以省略。</li>
<li><strong>关键字参数</strong>：可以在调用时以名称指定参数值，顺序可以不同。</li>
<li><strong>可变位置参数 (<code>*args</code>)</strong>：用于接收任意数量的位置参数，定义在位置参数和默认参数之后。</li>
<li><strong>命名关键字参数 (<code>*</code>)</strong>：用于将所有后续的参数设为命名关键字参数。</li>
<li><strong>可变关键字参数 (`</strong>kwargs`)**：用于接收任意数量的关键字参数，定义在所有其他参数之后。</li>
</ul>
<p>函数参数的顺序确保了函数定义和调用的一致性和灵活性。</p>
<p><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数。</strong></p>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>lambda 函数的语法只包含一个语句，如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lambda</code>是 Python 的关键字，用于定义 lambda 函数。</li>
<li><code>arguments</code> 是参数列表，可以包含零个或多个参数，但必须在冒号(<code>:</code>)前指定。</li>
<li><code>expression</code> 是一个表达式，用于计算并返回函数的结果。</li>
</ul>
<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><ul>
<li><p><a href="https://blog.csdn.net/qq_41588285/article/details/130522255">python中的不定长位置参数<em>args和不定长关键字参数</em>kwargs说明_python不定长参数*args-CSDN博客</a></p>
</li>
<li><p><a href="https://www.runoob.com/python3/python3-function.html">Python3 函数 | 菜鸟教程~~~~</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/98f7e34845b5">python的可变参数和关键字参数(<em>args *</em>kw) - 简书</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>函数</tag>
        <tag>lambda</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-Generator and Iterator</title>
    <url>/2024/08/20/Python%20Relearning-Generator%20and%20Iterator/</url>
    <content><![CDATA[<p>在 Python 中，理解和区分生成器（generators）和迭代器（iterators）是非常重要的，因为它们都与迭代（iteration）有关，但它们的工作方式和用途有所不同。</p>
<h3 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h3><p>迭代器是实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。迭代器对象知道如何返回序列中的下一个值，直到没有更多的值可以返回，此时会引发 <code>StopIteration</code> 异常。<br>迭代器的特点：</p>
<ul>
<li><p>可以使用 <code>next()</code> 函数来获取下一个值。</p>
</li>
<li><p>只能向前迭代，不能后退。</p>
</li>
<li><p>只能迭代一次，迭代完成后就无法再次迭代。<br>以下是一个简单的迭代器示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">      <span class="variable language_">self</span>.n = n</span><br><span class="line">      <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.n:</span><br><span class="line">          value = <span class="variable language_">self</span>.current</span><br><span class="line">          <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">raise</span> StopIteration</span><br><span class="line"><span class="comment"># 使用迭代器</span></span><br><span class="line">my_iterator = MyIterator(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_iterator:</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<h3 id="生成器（Generators）"><a href="#生成器（Generators）" class="headerlink" title="生成器（Generators）"></a>生成器（Generators）</h3><p>生成器是一种特殊类型的迭代器，它不需要实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法。生成器使用 <code>yield</code> 关键字来产生值，而不是通过返回一个值来生成值。生成器在每次产生值后会暂停执行，并在下一次调用时从上次暂停的地方继续执行。<br>生成器的特点：</p>
</li>
<li><p>使用 <code>yield</code> 关键字定义，而不是 <code>return</code>。</p>
</li>
<li><p>生成器是懒惰的，它们只在需要时才计算值。</p>
</li>
<li><p>可以使用 <code>next()</code> 函数或 <code>for</code> 循环来迭代。<br>以下是一个简单的生成器函数示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">      <span class="keyword">yield</span> i</span><br><span class="line"><span class="comment"># 使用生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_generator(<span class="number">5</span>):</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器表达式是创建生成器的另一种简洁方式，类似于列表推导，但是使用圆括号 <code>()</code> 而不是方括号 <code>[]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen_exp = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> gen_exp:</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>指的是一个函数，以yeid代替return，返回一个生成器对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li><p><strong>迭代器</strong>：实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象，可以用于迭代。</p>
</li>
<li><p><strong>生成器</strong>：一种特殊的迭代器，使用 <code>yield</code> 关键字定义，可以更高效地处理数据流。<br>生成器特别适合于处理大量数据或需要按需生成数据的场景，因为它们不需要在内存中存储整个数据集。迭代器则是一个更通用的概念，适用于任何可以迭代的对象。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代器，生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-Branches, loops, comprehensions and iterators</title>
    <url>/2024/07/25/Python%20Relearning-Branches,%20loops,%20comprehensions%20and%20iterators/</url>
    <content><![CDATA[<h1 id="match-case语句"><a href="#match-case语句" class="headerlink" title="match-case语句"></a>match-case语句</h1><p>Python 3.10 版本引入的新语法</p>
<p>用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> expression:</span><br><span class="line">    <span class="keyword">case</span> pattern1:</span><br><span class="line">        <span class="comment"># 处理pattern1的逻辑</span></span><br><span class="line">    <span class="keyword">case</span> pattern2:</span><br><span class="line">        <span class="comment"># 处理pattern2并且满足condition的逻辑</span></span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="comment"># 处理其他情况的逻辑</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>case _</code>相当于C语言里面的<code>default</code>。</p>
</li>
<li><p>使用变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_example</span>(<span class="params">item</span>):</span><br><span class="line"> <span class="keyword">match</span> item:</span><br><span class="line"> <span class="keyword">case</span> (x, y) <span class="keyword">if</span> x == y:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">f&quot;匹配到相等的元组: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> (x, y):</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">f&quot;匹配到元组: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> _:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;匹配到其他情况&quot;</span>)</span><br><span class="line"></span><br><span class="line">match_example((<span class="number">1</span>, <span class="number">1</span>)) <span class="comment"># 输出: 匹配到相等的元组: (1, 1)</span></span><br><span class="line">match_example((<span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 输出: 匹配到元组: (1, 2)</span></span><br><span class="line">match_example(<span class="string">&quot;other&quot;</span>) <span class="comment"># 输出: 匹配到其他情况</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型匹配</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        <span class="variable language_">self</span>.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, width, height</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = width</span><br><span class="line">        <span class="variable language_">self</span>.height = height</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">match_shape</span>(<span class="params">shape</span>):</span><br><span class="line">    <span class="keyword">match</span> shape:</span><br><span class="line">        <span class="keyword">case</span> Circle(radius=<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;匹配到半径为1的圆&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Rectangle(width=<span class="number">1</span>, height=<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;匹配到宽度为1，高度为2的矩形&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;匹配到其他形状&quot;</span>)</span><br><span class="line"></span><br><span class="line">match_shape(Circle(radius=<span class="number">1</span>))          <span class="comment"># 输出: 匹配到半径为1的圆</span></span><br><span class="line">match_shape(Rectangle(width=<span class="number">1</span>, height=<span class="number">2</span>)) <span class="comment"># 输出: 匹配到宽度为1，高度为2的矩形</span></span><br><span class="line">match_shape(<span class="string">&quot;other&quot;</span>)                    <span class="comment"># 输出: 匹配到其他形状</span></span><br></pre></td></tr></table></figure>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><ul>
<li><p>Python中没有<code>do-while</code>循环</p>
</li>
<li><p><code>while</code>后面可以跟<code>else:</code></p>
<p>如果<code>while</code>里面的东西，中途执行的时候发生错误，则不会执行<code>else</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line"> <span class="built_in">print</span> (count, <span class="string">&quot; 小于 5&quot;</span>)</span><br><span class="line"> count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> <span class="built_in">print</span> (count, <span class="string">&quot; 大于或等于 5&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>for</code>后面也可以跟<code>else</code>:</p>
<p>如果<code>for</code>里面的东西，中途执行的时候发生错误，则不会执行<code>else</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Finally finished!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Python</code>中<code>break</code>和<code>continue</code>的用法同C语言。</p>
</li>
<li><p><code>pass</code>语句：保持程序结构的完整性，一般用做占位语句</p>
</li>
</ul>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>键后面跟冒号然后是值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="comment"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdict</span><br><span class="line">&#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure>
<p>例程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setnew = &#123;i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setnew</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h2><p>使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure>
<p>例程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<ul>
<li><p><code>next</code>输出迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果遍历了所有的it对象（即输出了1，2，3，4），再使用<code>next(it)</code>，会产生<code>StopIteration</code>报错。</p>
<p>此时可以用下一个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>for</code>循环遍历迭代器对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="把一个类作为一个迭代器"><a href="#把一个类作为一个迭代器" class="headerlink" title="把一个类作为一个迭代器"></a>把一个类作为一个迭代器</h2><p>需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>
<ul>
<li><h3 id="iter-方法"><a href="#iter-方法" class="headerlink" title="__iter__()方法"></a><code>__iter__()</code>方法</h3><p>返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p>
</li>
<li><h3 id="next-方法"><a href="#next-方法" class="headerlink" title="__next__()方法"></a><code>__next__()</code>方法</h3><p>会返回下一个迭代器对象</p>
</li>
<li><h3 id="例程："><a href="#例程：" class="headerlink" title="例程："></a>例程：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = <span class="variable language_">self</span>.a</span><br><span class="line">    <span class="variable language_">self</span>.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))  </span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）。</p>
<p><strong>yield</strong> 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p>
<p>当在生成器函数中使用 <strong>yield</strong> 语句时，函数的执行将会暂停，并将 <strong>yield 后面的表达式作为当前迭代的值返回。</strong></p>
<p>然后，每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>例程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></table></figure>
<p>使用yeid实现斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()  </span><br><span class="line"><span class="comment"># 输出结果 ；0 1 1 2 3 5 8 13 21 34 55</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.runoob.com/python3/python3-loop.html">Python3 循环语句 | 菜鸟教程</a></p>
</li>
<li><p><a href="https://www.runoob.com/python3/python-match-case.html">Python match&#8230;case 语句 | 菜鸟教程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>match-case</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-MultiProcessing</title>
    <url>/2024/08/22/Python%20Relearning-MultiProcessing/</url>
    <content><![CDATA[<h1 id="多进程："><a href="#多进程：" class="headerlink" title="多进程："></a>多进程：</h1><ul>
<li><p>torch.utils.data.DataLoader()中的参数num_works代表进程数，如果为0，代表在主进程中，一般不会有多进程问题。</p>
</li>
<li><p><strong>主程序保护</strong>：在Windows系统中，子进程的创建和启动机制与UNIX系统不同。因此，必须使用<code>if __name__ == &quot;__main__&quot;:</code>来保护代码块，以防止在子进程中执行不必要的代码。Windows中每个进程都从头开始执行脚本，而UNIX系统中则只会创建一个新的子进程。</p>
</li>
<li><p>下面是来自ChatGPT 4o mini的回答:</p>
<blockquote>
<p>在Python中使用多进程来实现并发编程时，你需要注意以下几个方面：</p>
<ol>
<li><p><strong>使用<code>multiprocessing</code>模块</strong>：Python标准库中的<code>multiprocessing</code>模块提供了进程创建和管理的功能。它可以用来创建和管理子进程、交换数据等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker process&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Process(target=worker)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主程序保护</strong>：在Windows系统中，子进程的创建和启动机制与UNIX系统不同。因此，必须使用<code>if __name__ == &quot;__main__&quot;:</code>来保护代码块，以防止在子进程中执行不必要的代码。Windows中每个进程都从头开始执行脚本，而UNIX系统中则只会创建一个新的子进程。</p>
</li>
<li><p><strong>数据共享</strong>：在多进程环境中，进程之间的数据是隔离的。为了在进程之间共享数据，你可以使用<code>multiprocessing</code>模块提供的共享数据结构，如<code>Value</code>、<code>Array</code>或<code>Manager</code>。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_data</span>(<span class="params">num, arr</span>):</span><br><span class="line">    num.value += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        arr[i] *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num = Value(<span class="string">&#x27;i&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    arr = Array(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = Process(target=modify_data, args=(num, arr))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num.value)  <span class="comment"># 输出修改后的值</span></span><br><span class="line">    <span class="built_in">print</span>(arr[:])     <span class="comment"># 输出修改后的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程间通信（IPC）</strong>：如果进程需要通信，可以使用<code>multiprocessing</code>模块中的<code>Queue</code>、<code>Pipe</code>、<code>Event</code>、<code>Lock</code>等机制进行进程间通信和同步。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">q</span>):</span><br><span class="line">    q.put(<span class="string">&quot;Hello from the worker&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=worker, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(q.get())  <span class="comment"># 输出 &quot;Hello from the worker&quot;</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程池</strong>：如果你需要创建和管理大量的进程，可以使用<code>multiprocessing.Pool</code>类，它允许你创建一个进程池，并将任务分配到池中的进程上。<code>Pool</code>类提供了<code>map</code>、<code>apply</code>等方法来简化并发任务的处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">        result = p.<span class="built_in">map</span>(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(result)  <span class="comment"># 输出 [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免死锁和竞争条件</strong>：在多进程编程中，多个进程可能会尝试同时访问共享资源，导致死锁或竞争条件。使用<code>Lock</code>或<code>Semaphore</code>等同步原语来协调对共享资源的访问，避免这些问题。</p>
</li>
<li><p><strong>性能和开销</strong>：多进程比多线程更能利用多核CPU，但进程创建和销毁的开销比线程大。确保你的应用程序确实需要使用多进程，并权衡性能和复杂性。</p>
</li>
<li><p><strong>调试困难</strong>：调试多进程应用程序可能比较困难，因为每个进程都有自己的执行上下文。使用日志记录或其他调试工具来帮助追踪问题。</p>
</li>
</ol>
<p>通过注意这些要点，你可以更有效地利用Python的多进程功能，提高程序的并发性能。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System-线程</title>
    <url>/2024/12/14/Operating-System-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>线程是进程内一个相对独立、可调度的执行单元。</p>
<p>多种线程的定义：</p>
<ul>
<li>进程内的一个执行单元。</li>
<li>进程内的一个可调度实体。</li>
<li>程序（或进程）中相对独立的一个控制流序列。</li>
<li>执行的上下文。</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>线程是进程内一个相对独立的可执行单元（子任务）。</li>
<li>线程是操作系统的基本调度单元，包含调度信息。</li>
<li>一个进程至少有一个线程，进程本身不是基本调度单元。</li>
<li>线程可以创建线程，形成线程族系。</li>
<li>进程是拥有资源的基本单位，多线程共享进程资源。</li>
<li>线程间需要通信和同步机制以解决资源共享带来的矛盾。</li>
<li>线程有其生命周期（从建立到结束，伴随状态变化）。</li>
</ul>
<h2 id="和进程的比较"><a href="#和进程的比较" class="headerlink" title="和进程的比较"></a>和进程的比较</h2><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul>
<li>同一进程内的线程切换不会引起进程切换。</li>
<li>不同进程间的线程切换才会导致进程切换。</li>
</ul>
<h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><ul>
<li>进程之间可以并发执行。</li>
<li>一个进程内的多个线程同样可以并发执行。</li>
</ul>
<h3 id="系统资源"><a href="#系统资源" class="headerlink" title="系统资源"></a>系统资源</h3><ul>
<li>进程是资源分配的基本单位（资源拥有者）。</li>
<li>线程共享其所属进程拥有的全部资源。</li>
</ul>
<h3 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h3><ul>
<li>进程的创建和撤销开销大于线程。</li>
<li>进程切换的开销大于同一进程内的线程切换开销。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>降低了系统开销。</li>
<li>增加了通信的有效性。</li>
<li>方便和简化了用户程序结构。</li>
</ul>
<h2 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h2><ul>
<li>前后台工作分离。</li>
<li>异步处理任务。</li>
<li>需要提高执行速度的场景。</li>
<li>组织结构复杂的工作。</li>
<li>需要同时响应多个用户服务请求的场景。</li>
</ul>
<h1 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h1><p>传统上，线程分为 <strong>内核级线程</strong> 和 <strong>用户级线程</strong>。</p>
<h2 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h2><p>早期的线程均为用户级。为了管理用户级线程，操作系统提供一个在用户空间执行的 <strong>线程库</strong>。该库是一组供应用程序共享的软件包，负责在 <strong>用户态</strong> 完成线程的创建、调度和撤销。对于操作系统内核而言，进程中的线程是 <strong>透明的</strong>，内核只对进程进行管理。</p>
<p>当一个线程被派生时，线程库为其生成线程控制块（TCB）等数据结构。其处理过程与进程创建类似，但有以下不同：</p>
<ul>
<li>用户级线程的调度只进行 <strong>线程上下文切换</strong>，不涉及处理器状态的改变。</li>
<li>由于用户级线程的上下文切换与内核无关，当一个进程因 I/O 中断等原因被阻塞时，其内部的其他线程也随之被阻塞。</li>
</ul>
<h3 id="线程的三个状态"><a href="#线程的三个状态" class="headerlink" title="线程的三个状态"></a>线程的三个状态</h3><ul>
<li><strong>就绪状态</strong>：线程已具备运行条件，等待分配 CPU。</li>
<li><strong>运行状态</strong>：线程正在 CPU 上运行。</li>
<li><strong>等待状态（阻塞状态）</strong>：线程正在等待某一事件发生。</li>
</ul>
<p><strong>补充说明</strong>：</p>
<ul>
<li>用户级线程通常没有挂起状态，因为它们共享进程的内存空间。</li>
<li>理论上，一个线程阻塞不应影响其他线程，但在纯用户级模型中，若阻塞发生在内核层面（如系统调用），则整个进程都会被阻塞。</li>
</ul>
<h3 id="用户级线程优点"><a href="#用户级线程优点" class="headerlink" title="用户级线程优点"></a>用户级线程优点</h3><ul>
<li><strong>开销小</strong>：进程内线程切换无需从 <strong>用户模式 → 内核模式</strong>、再由 <strong>内核模式 → 用户模式</strong> 的转换，减少了系统开销。</li>
<li><strong>调度灵活</strong>：线程切换算法可由应用程序自行定义（如简单轮转或优先级算法），且不会干扰内核的进程调度。</li>
<li><strong>通用性强</strong>：用户级线程可以在任何操作系统上运行，无需内核支持。</li>
</ul>
<h2 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h2><p><strong>核心级线程</strong>（或称内核级线程）由操作系统内核直接管理，其线程控制块（TCB）存放在 <strong>操作系统空间</strong> 内。线程的创建、调度和状态转换均由操作系统通过 <strong>系统调用</strong> 完成。</p>
<p>与用户级线程不同，核心级线程既可以在一个处理器上 <strong>并发</strong> 执行，也可以被调度到不同处理器上 <strong>并行</strong> 执行。操作系统内核统一负责进程和线程的调度，因此不会出现整个进程因单个线程的阻塞而停滞的情况。</p>
<p>核心级线程的上下文切换开销大于用户级线程。</p>
<p><strong>用户级线程的两个主要缺点也正是核心级线程的优点：</strong></p>
<ol>
<li>当一个线程执行阻塞型系统调用时，内核可以调度该进程内的其他线程继续执行，而不是阻塞整个进程。</li>
<li>在多处理器系统上，内核可以将同一进程的多个线程分配到不同的处理器上，真正实现并行计算，充分利用多处理技术。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>操作系统的进程和线程设计，可以归结为三点：</p>
<ol>
<li>以 <strong>多进程</strong> 形式，允许多个任务同时运行。</li>
<li>以 <strong>多线程</strong> 形式，允许单个任务分成不同的部分并发运行。</li>
<li>提供 <strong>协调机制</strong>，一方面防止进程和线程之间产生冲突，另一方面允许它们共享资源。</li>
</ol>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>操作系统会随机调度线程，程序员无法预知线程的执行顺序。在以下两种情况下，线程间需要同步：</p>
<ul>
<li>多个线程访问共享资源时，为防止数据损坏，需要保证访问的排他性（<strong>互斥</strong>）。</li>
<li>一个线程需要将任务完成情况通知其他一个或多个线程时，需要协调执行顺序（<strong>同步</strong>）。</li>
</ul>
<p>Windows 提供的线程同步方法主要有 <strong>临界区、互斥量、事件、信号量</strong>。</p>
<h2 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 (Critical Section)"></a>临界区 (Critical Section)</h2><ul>
<li><strong>定义</strong>：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</li>
<li><strong>机制</strong>：确保在某一时刻只有一个线程能进入临界区。当一个线程进入后，其他任何试图进入的线程都将被挂起，直到该线程离开。临界区被释放后，其他线程可继续争抢。</li>
<li><strong>原则</strong>：<ul>
<li>一次最多只能有一个线程停留在临界区内。</li>
<li>线程不能无限地停留在临界区内，以免其他线程饿死。</li>
</ul>
</li>
</ul>
<h2 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量 (Mutex)"></a>互斥量 (Mutex)</h2><ul>
<li><strong>定义</strong>：与临界区类似，但更为强大。只有拥有互斥对象的线程才能访问特定资源。</li>
<li><strong>机制</strong>：互斥对象是唯一的，确保了任何时候只有一个线程能访问资源。任务完成后，线程必须释放互斥对象，以便其他线程获取。线程结束时，其拥有的互斥量会自动释放。</li>
<li><strong>应用</strong>：互斥量不仅可以在同一进程的不同线程间使用，还可以在 <strong>不同进程的线程之间</strong> 实现资源安全共享，这是它与临界区的主要区别。常用于保护共享内存块。</li>
</ul>
<h2 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 (Event)"></a>事件 (Event)</h2><ul>
<li><strong>定义</strong>：通过通知操作的方式来保持线程同步。一个线程可以等待一个事件被触发，而另一个线程则可以在适当的时候触发该事件。</li>
<li><strong>机制</strong>：事件对象有两种状态：受信（signaled）和未受信（non-signaled）。线程可以等待一个事件变为受信状态再继续执行。</li>
<li><strong>应用</strong>：主要用于标志某个事件的发生，并以此协调线程的执行顺序，可以方便地实现一对多或多对多的线程通信。</li>
</ul>
<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 (Semaphore)"></a>信号量 (Semaphore)</h2><ul>
<li><strong>定义</strong>：允许多个线程同时访问同一共享资源，但会限制同时访问的线程最大数量。</li>
<li><strong>机制</strong>：信号量维护一个计数器。当线程要访问资源时，计数器减一；当线程释放资源时，计数器加一。若计数器为零，则后续请求资源的线程将被阻塞，直到有其他线程释放资源。这与操作系统中的PV操作原理相同。</li>
<li><strong>应用</strong>：适用于需要限制并发访问数量的场景，例如数据库连接池。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Python Relearning-List/Tuple/Dict/Set</title>
    <url>/2024/07/24/Python%20Relearning-ListTupleDictSet/</url>
    <content><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li><h2 id="list-append"><a href="#list-append" class="headerlink" title="list.append()"></a>list.append()</h2></li>
<li><h2 id="del-list-3"><a href="#del-list-3" class="headerlink" title="del list[3]"></a>del list[3]</h2></li>
<li><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p><code>a=[[1,2],3]</code></p>
</li>
<li><h2 id="遍历多个序列（zip-函数"><a href="#遍历多个序列（zip-函数" class="headerlink" title="遍历多个序列（zip())函数"></a>遍历多个序列（zip())函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line">answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;? It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What <span class="keyword">is</span> your name? It <span class="keyword">is</span> lancelot.</span><br><span class="line">What <span class="keyword">is</span> your quest? It <span class="keyword">is</span> the holy grail.</span><br><span class="line">What <span class="keyword">is</span> your favorite color? It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="列表的一些函数"><a href="#列表的一些函数" class="headerlink" title="列表的一些函数"></a>列表的一些函数</h2><p>| 函数                                    | 功能                                                   | 示例  |<br>|:——————————————————-:| —————————————————————————— | —- |<br>| <code>list.append()</code>                       | 在列表末尾添加新的元素                                          |     |<br>| <code>list.extend()</code>                       | 在列表末尾一次性追加另一个序列中的多个值，<strong>可以添加列表、元组、集合</strong>                |     |<br>| <code>list.count()</code>                        | 统计某个元素在列表中出现的次数                                      |     |<br>| <code>list.index(x[, start[, end]])</code>       | 用于从列表中找出某个值第一个匹配项的索引位置                               |     |<br>| <code>list.insert(index, obj)</code>             | 用于将指定对象插入列表的指定位置                                     |     |<br>| <code>list.pop([index=-1])</code>                | 移除列表中的一个元素（默认最后一个元素），并且<strong>返回该元素的值</strong>                   |     |<br>| <code>list.remove(obj)</code>                    | 移除列表中某个值的第一个匹配项                                      |     |<br>| <code>list.reverse()</code>                      | 会对列表的元素进行反向排序,该方法没有返回值                               |     |<br>| <code>list.sort( key=None, reverse=False)</code> | 用于对原列表进行排序，reverse = True 降序， reverse = False 升序（默认） |     |<br>| <code>list.clear()</code>                        | 清空列表                                                 |     |<br>| <code>list.copy()</code>                         | 用于复制列表，类似于 a[:]。返回复制后的新列表。                           |     |<br>| <code>len(list)</code>                           | 返回列表元素个数                                             |     |<br>| <code>max(list)</code>                           | 返回列表元素最大值                                            |     |<br>| <code>min(list)</code>                           | 返回列表元素最小值                                            |     |<br>| <code>list(seq)</code>                           | 将元组转换为列表                                             |     |</p>
</li>
</ul>
<h1 id="Operator模块"><a href="#Operator模块" class="headerlink" title="Operator模块"></a>Operator模块</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">operator.lt(a, b)  <span class="comment">#  &lt;</span></span><br><span class="line">operator.le(a, b)  <span class="comment">#  &lt;=</span></span><br><span class="line">operator.eq(a, b)  <span class="comment">#  =</span></span><br><span class="line">operator.ne(a, b)  <span class="comment">#  !=</span></span><br><span class="line">operator.ge(a, b)  <span class="comment">#  &gt;=</span></span><br><span class="line">operator.gt(a, b)  <span class="comment">#  &gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul>
<li><p>Python 的元组与列表类似，不同之处在于元组的元素<strong>不能修改</strong>,但是可以<strong>重新赋值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1)</span><br><span class="line"></span><br><span class="line">tup1 = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1)  <span class="comment">#输出(3,4,5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元组使用小括号<code>( )</code>，列表使用方括号<code>[ ]</code>。</p>
</li>
<li><p>元组中<strong>只包含一个元素</strong>时，需要在元素后面添加逗号 , 否则括号会被当作运算符使用，如<code>tup1 = (50)</code>表示的是一个<code>int</code>类型的数据，<code>tup1 = (50,)</code>是一个长度为1的元组。</p>
</li>
<li><p>元组可以使用下标索引来访问元组中的值，如<code>tup1[0]</code></p>
</li>
<li><p>可以对元组进行<strong>连接组合</strong>，如下实例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span> (tup3)</span><br></pre></td></tr></table></figure>
<p>  输出:</p>
<p>  <code>(12, 34.56, &#39;abc&#39;, &#39;xyz&#39;)</code></p>
<p>  类似，也可以用<code>+=、 in、*</code>、进行处理。</p>
</li>
<li><p><strong>删除元组：</strong></p>
<p>元组中的元素值是不允许删除的，但我们可以使用<strong>del语句来删除整个元组</strong>：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1) </span><br><span class="line"><span class="keyword">del</span> tup1    <span class="comment"># 删除整个元组</span></span><br><span class="line"><span class="built_in">print</span>(tup1) <span class="comment">#会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>元组的括号</p>
<p>元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples may be nested:</span></span><br><span class="line"><span class="meta">... </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内置函数</strong></p>
<p>| 方法                | 功能           |                                                                 |<br>|:————————-:| —————— | ———————————————————————————————- |<br>| <code>len(tuple)</code>      | 计算元组元素个数。    |                                                                 |<br>| <code>max(tuple)</code>      | 返回元组中元素最大值。  |                                                                 |<br>| <code>min(tuple)</code>      | 返回元组中元素最小值。  |                                                                 |<br>| <code>tuple(iterable)</code> | 将可迭代系列转换为元组。 | <code>list1=&#39;Google&#39;,&#39;Taobao&#39;,&#39;Runoob&#39;,&#39;Baidu&#39;] tuple1=tuple(list1)</code> |</p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>理解字典的最佳方式是把它看做<strong>无序的键=&gt;值对集合</strong></p>
<p>字典的每个键值 <code>key=&gt;value</code> 对用冒号 : 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p>
<p><code>d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</code></p>
<pre><code>  **键必须是唯一的，但值则不必。**

  值可以取任何数据类型，但键必须是不可变的，如字符串，数字。

  `tinydict1 = &#123; &#39;abc&#39;: 456 &#125;`

  `tinydict2 = &#123; &#39;abc&#39;: 123, 98.6: 37 &#125;`
</code></pre></li>
<li><p>从<strong>键值对元组列表</strong>构建字典：</p>
<p>构造函数 dict() 直接从键值对元组列表中构建字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;sape&#x27;</span>, <span class="number">4139</span>), (<span class="string">&#x27;guido&#x27;</span>, <span class="number">4127</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h2><ul>
<li><p>使用大括号<code>&#123;&#125;</code></p>
<p><code>emptyDict=&#123;&#125;</code></p>
</li>
<li><p>使用内置函数<code>dict</code></p>
<p><code>emptyDict=dict()</code></p>
</li>
</ul>
</li>
<li><h2 id="访问值"><a href="#访问值" class="headerlink" title="访问值"></a>访问值</h2><p>把相应的键放入到方括号中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;key_1&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;key_2&#x27;</span>: B, <span class="string">&#x27;key_3&#x27;</span>: <span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;key_1&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;key_1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;key_2&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;key_2&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h2><p>事先定义:<code>tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;</code></p>
<ul>
<li><h3 id="删除单一的元素"><a href="#删除单一的元素" class="headerlink" title="删除单一的元素"></a>删除单一的元素</h3><p><code>del tinydict[&#39;Name&#39;] # 删除键 &#39;Name&#39;</code></p>
</li>
<li><h3 id="删除整个字典"><a href="#删除整个字典" class="headerlink" title="删除整个字典"></a>删除整个字典</h3><p><code>del tinydict</code></p>
</li>
<li><h3 id="清空字典"><a href="#清空字典" class="headerlink" title="清空字典"></a>清空字典</h3><p><code>tinydict.clear() # 清空字典</code></p>
</li>
</ul>
</li>
<li><h2 id="键的特性"><a href="#键的特性" class="headerlink" title="键的特性"></a>键的特性</h2><ul>
<li><h3 id="键不允许重复"><a href="#键不允许重复" class="headerlink" title="键不允许重复"></a>键不允许重复</h3><p>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tinydict)</span><br><span class="line"><span class="comment"># 输出&#123;&#x27;Name&#x27;: &#x27;小菜鸟&#x27;, &#x27;Age&#x27;: 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="comment"># 输出:tinydict[&#x27;Name&#x27;]:  小菜鸟</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="键必须是不可变的"><a href="#键必须是不可变的" class="headerlink" title="键必须是不可变的"></a>键必须是不可变的</h3><p>可以用<strong>数字，字符串或元组</strong>充当，而用<strong>列表就不行</strong></p>
<p><del><code>tinydict=&#123;[1,2]:3,&#39;sd&#39;:5&#125;</code></del></p>
<p>会报错</p>
</li>
</ul>
</li>
<li><h2 id="关于字典的函数-方法"><a href="#关于字典的函数-方法" class="headerlink" title="关于字典的函数/方法:"></a>关于字典的函数/方法:</h2><ul>
<li><h4 id="dict-fromkeys-seq-value"><a href="#dict-fromkeys-seq-value" class="headerlink" title="dict.fromkeys(seq[, value])"></a><code>dict.fromkeys(seq[, value])</code></h4><p>用于创建一个新字典，以序列 seq 中元素做字典的键，value （某人为none)为字典所有键对应的初始值。</p>
</li>
<li></li>
</ul>
<p>| 函数                                   | 功能                                                                                       | 说明/示例                                    |<br>| —————————————————— | ———————————————————————————————————————————— | ———————————————————— |<br>| <code>len(dict)</code>                          | 计算字典元素个数，即键的总数。                                                                          |                                          |<br>| <code>str(dict)</code>                          | 输出字典，可以打印的字符串表示。                                                                         | <code>str(&#123;&quot;A&quot;:1,&quot;B&quot;:2&#125;)</code>会返回<code>&quot;&#123;&quot;A&quot;:1,&quot;B&quot;:2&#125;&quot;</code> |<br>| <code>dict.copy()</code>                        | 返回一个字典的浅复制。                                                                              |                                          |<br>| <code>dict.fromkeys(seq[, value])</code>        | 创建一个新字典，以序列 seq 中元素做字典的键,value默认为none                                                    |                                          |<br>| <code>dict.get(key[, value])</code>             | 返回指定键的值，如果键不在字典中返回默认值，如果不指定默认值，则返回 None。                                                 |                                          |<br>| <code>dict.setdefault(key, default=None)</code> | 和 dict.get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。                                             |                                          |<br>| <code>dict.items()</code>                       | 返回一个视图对象。视图对象不是列表，不支持索引，可以使用 list() 来转换为列表。 不能对视图对象进行任何的修改，因为字典的视图对象都是只读的。字典改变，视图也会跟着变化。 |                                          |<br>| <code>dict.keys()</code>                        | 返回一个视图对象。                                                                                |                                          |<br>| <code>dict.values()</code>                      | 返回一个视图对象。                                                                                |                                          |<br>|                                      |                                                                                          |                                          |<br>| <code>dict.pop(key[,default])</code>            | 删除字典 key（键）所对应的值，返回被删除的值。key 不存在时返回default                                               |                                          |<br>| <code>dict.popitem()</code>                     | 随机返回并删除字典中的最后一对键和值。                                                                      |                                          |<br>| <code>dict.update(dict2)</code>                 | 函数把字典参数 dict2 的 key/value(键/值) 对更新到字典 dict 里。                                            |                                          |</p>
</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 { } 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 set() 函数创建集合。</p>
<ul>
<li><h2 id="创建空集合"><a href="#创建空集合" class="headerlink" title="创建空集合"></a>创建空集合</h2><p>创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
</li>
<li><h2 id="集合内置方法"><a href="#集合内置方法" class="headerlink" title="集合内置方法"></a>集合内置方法</h2><p>| 函数                                          | 功能                                                       | 说明                         |<br>|:—————————————————————-:|:————————————————————————————:|:—————————————:|<br>| <code>x.add(elmnt)</code>                              | 给集合添加元素                                                  | 如果添加的元素在集合中已存在，则不执行任何操作    |<br>| <code>x.update(set)</code>                             | 可以添加新的元素或集合到当前集合中                                        | 参数set不能是一个元素，必须是一个可迭代对象    |<br>| <code>x.clear()</code>                                 | 移除集合中的所有元素                                               | 无返回值，如果打印原来的set，会输出一个set() |<br>| <code>x.copy()</code>                                  | 用于拷贝一个集合                                                 |                            |<br>| <code>x.difference(y)</code>                           | 返回集合的差集,元素包含在集合 x ，但不在集合 y                               |                            |<br>| <code>x.difference_update(y)</code>                    | 用于移除两个集合中都存在的元素                                          | 直接在原来的集合x中移除元素，没有返回值       |<br>| <code>x.remove(item)</code>                            | 移除集合中的指定元素                                               | 移除一个不存在的元素时会发生错误           |<br>| <code>x.discard(value)</code>                          | 移除指定的集合元素                                                | 移除一个不存在的元素时不会发生错误          |<br>| <code>x.intersection(set1, set2 ... etc)</code>        | 返回两个或更多集合中都包含的元素，即交集                                     | set1 — 必需，其余可选。返回一个新的集合   |<br>| <code>x.intersection_update(set1, set2 ... etc)</code> | 在原始的集合上移除不重叠的元素，即返回x与set1、set2······的交集                  | 在原始的集合上移除不重叠的元素            |<br>| <code>x.isdisjoint(set)</code>                         | 判断两个集合是否包含相同的元素,交集为空返回True，反之返回False                     |                            |<br>| <code>x.issubset(y)</code>                             | 判断x是否是y的子集，是的话返回True,否则返回False                           |                            |<br>| <code>x.issuperset(y)</code>                           | 判断y是否是x的子集，是的话返回True,否则返回False                           |                            |<br>| <code>x.pop()</code>                                   | 移除并返回集合中的一个随机元素                                          |                            |<br>| <code>x.symmetric_difference(y)</code>                 | 返回两个集合的对称差，即两个集合中不重复的元素集合                                |                            |<br>| <code>x.symmetric_difference_update(y)</code>          | 将x更新为对称差(移除当前集合中在另外一个指定集合相同的元素,并将另外一个指定集合中不同的元素插入到当前集合中) |                            |<br>| <code>x.union(set1, set2...)</code>                    | 返回多个集合的并集                                                |                            |<br>| <code>len( s )</code>                                  | 返回对象的长度或元素个数                                             |                            |</p>
</li>
</ul>
<h1 id="直接赋值、浅拷贝、深拷贝"><a href="#直接赋值、浅拷贝、深拷贝" class="headerlink" title="直接赋值、浅拷贝、深拷贝"></a>直接赋值、浅拷贝、深拷贝</h1><ul>
<li><h2 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h2><p>其实就是对象的引用（别名）。</p>
<p>当原来的对象(列表等~~)被改变的时候，赋值后的对象<strong>会跟着改变</strong>。</p>
</li>
<li><h2 id="浅拷贝-copy"><a href="#浅拷贝-copy" class="headerlink" title="浅拷贝(copy)"></a>浅拷贝(copy)</h2><p>拷贝父对象，不会拷贝对象的内部的子对象。</p>
<p>当原来的对象(列表等~~)被改变的时候，如果子对象改变了， 赋值后的对象<strong>不会跟着改变</strong>。 </p>
</li>
<li><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。不管父对象如何改变，子对象都不改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]] <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)            <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;a = &#x27;</span>, a )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;b = &#x27;</span>, b )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;c = &#x27;</span>, c )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;d = &#x27;</span>, d )</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;a = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;b = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;c = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]])</span><br><span class="line">(<span class="string">&#x27;d = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
        <tag>字典</tag>
        <tag>元组</tag>
        <tag>集合</tag>
        <tag>zip函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-String</title>
    <url>/2024/07/23/Python%20Relearning-String/</url>
    <content><![CDATA[<h1 id="琐碎的语法"><a href="#琐碎的语法" class="headerlink" title="琐碎的语法"></a>琐碎的语法</h1><ul>
<li><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p><code>//</code>向下取整，靠近负无穷</p>
</li>
<li><p>海象运算符<code>(a:=3)&gt;2</code>，先赋值再操作，不能单独作为赋值语句。</p>
</li>
<li><p>位运算符</p>
<ul>
<li><p><code>&amp;</code>按位与</p>
</li>
<li><p><code>|</code>按位或</p>
</li>
<li><p><code>^</code>按位异或</p>
</li>
<li><p><code>~</code>按位取反</p>
</li>
<li><p><code>&lt;&lt;、&gt;&gt;</code>左移、右移</p>
</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li><p><code>and</code> 布尔与</p>
</li>
<li><p><code>or</code>布尔或</p>
</li>
<li><p><code>not</code>布尔非</p>
</li>
</ul>
</li>
<li><p>成员运算符</p>
<p><code>in</code> 和<code>not in</code></p>
</li>
<li><p>身份运算符</p>
<p><code>is</code>和<code>not is</code></p>
<p><strong>is</strong> 用于判断两个变量引用对象是否为同一个， <strong>==</strong> 用于判断引用变量的值是否相等。</p>
<p><code>a is b</code> 相当于 <code>id(a)==id(b)</code>，<code>id()</code>能够获取对象的内存地址。</p>
<p>如果 <code>a=10;b=a;</code> 则此时<code>a</code> 和 <code>b</code> 的内存地址一样的;</p>
<p>但当 a=[1,2,3<code>]</code>; 另 <code>b=a[:]</code> 时，虽然<code>a</code> 和 <code>b</code> 的值一样，但内存地址不一样。</p>
</li>
</ul>
</li>
<li><h2 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h2><p><code>a = b = c = 1</code></p>
</li>
<li><h2 id="支持复数"><a href="#支持复数" class="headerlink" title="支持复数"></a>支持复数</h2><p><code>a=3+4j</code></p>
<p><code>a=complex(3,4)</code></p>
</li>
<li><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><ul>
<li><p>bool是int的子集，可以使用 <code>bool()</code> 函数将其他类型的值转换为布尔值。以下值在转换为布尔值时为 <code>False</code>：<code>None</code>、<code>False</code>、零 (<code>0</code>、<code>0.0</code>、<code>0j</code>)、空序列（如 <code>&#39;&#39;</code>、<code>()</code>、<code>[]</code>）和空映射（如 <code>&#123;&#125;</code>）。其他所有值转换为布尔值时均为 <code>True</code>。</p>
</li>
<li><p>布尔类型也可以被转换成其他数据类型</p>
</li>
<li><p>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。</p>
</li>
</ul>
</li>
<li><h2 id="只有一个元素的元组"><a href="#只有一个元素的元组" class="headerlink" title="只有一个元素的元组"></a>只有一个元素的元组</h2><p>需要注意在元素后面添加一个逗号，以区分它是一个元组而不是一个普通的值</p>
<p><code>not_a_tuple = (42)</code></p>
<p><code>tuple=(42,)</code></p>
</li>
<li><h2 id="bytes类型"><a href="#bytes类型" class="headerlink" title="bytes类型"></a><code>bytes</code>类型</h2><p><code>bytes</code>类型表示的是不可变的二进制序列，与字符串类型不同的是，<code>bytes</code>类型中的元素是整数值（0 到 255 之间的整数），而不是 Unicode 字符。</p>
<p>创建byte类型：</p>
<ul>
<li><h3 id="使用b前缀"><a href="#使用b前缀" class="headerlink" title="使用b前缀"></a>使用b前缀</h3><p><code>x=b&quot;Hello&quot;</code></p>
</li>
<li><h3 id="bytes-函数将其他类型的对象转换为byte类型"><a href="#bytes-函数将其他类型的对象转换为byte类型" class="headerlink" title="bytes()函数将其他类型的对象转换为byte类型"></a><code>bytes()</code>函数将其他类型的对象转换为byte类型</h3><p><code>x = bytes(&quot;hello&quot;, encoding=&quot;utf-8&quot;) #默认为utf-8，可以省略</code></p>
</li>
</ul>
</li>
<li><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><p><code>int()、float()、str()</code></p>
</li>
<li><p><code>complex(x[,y])</code> ,返回复数，y默认是0</p>
</li>
<li><p><code>repr(object)</code>，将参数<code>object</code>转化为字符串形式，如果里面有转义字符，会转化为其相应的转义字符。repr()函数主要 用于调试，如果没有等价的语法，则会发生SyntaxError 异常。</p>
</li>
<li><p><code>eval()</code>函数，作用是用来计算在字符串中的有效Python表达式,并返回一个对象。通俗来说就是把传入的字符串的引号去掉，返回引号去掉的值。<code>eval(&quot;[21,4+4]&quot;)</code>返回<code>[21,8]</code></p>
<p>同时<code>eval</code>还有两个可选参数，<code>globals()</code>和<code>locals()</code>，eval会现在局部命名空间<code>locals()</code>中找参数，然后再全局命名空间<code>globals()</code>中找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;linux&#x27;,&#x27;age&#x27;:age&#125;&quot;</span>,&#123;<span class="string">&quot;age&quot;</span>:<span class="number">1822</span>&#125;,&#123;<span class="string">&quot;age&quot;</span>:<span class="number">1823</span>&#125;))</span><br><span class="line"><span class="comment">#输出结果：&#123;&#x27;name&#x27;: &#x27;linux&#x27;, &#x27;age&#x27;: 1823&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tuple()、list() 、set() 、frozenset()、dict()</code>函数分别转换为<strong>不可变元组、列表、可变集合、不可变集合、字典。</strong></p>
</li>
<li><p><code>chr() 、ord()</code>实现<strong>字符和整数</strong>之间的转换。</p>
</li>
<li><p><code>bin()、oct()、hex()</code>分别将一个整数转换为<strong>二进制、八进制、十六进制</strong>字符串</p>
</li>
</ul>
</li>
</ul>
<h1 id="math库数学函数"><a href="#math库数学函数" class="headerlink" title="math库数学函数"></a>math库数学函数</h1><ul>
<li><p>常数</p>
<ul>
<li><p><code>math.e</code></p>
</li>
<li><p><code>math.pi</code></p>
</li>
<li><p><code>math.tau</code>  $\pi$的二倍，6.28……</p>
</li>
<li><p><code>math.nan</code></p>
</li>
<li><p><code>math.inf</code></p>
</li>
</ul>
</li>
<li><p><code>math.abs()</code>,返回绝对值</p>
</li>
<li><p><code>math.abs()</code>,返回绝对值</p>
</li>
<li><p><code>math.ceil()</code>,向<strong>上</strong>取整</p>
</li>
<li><p><code>math.floor(x)</code>,向<strong>下</strong>取整</p>
</li>
<li><p><code>math.exp(x)</code>，返回<strong>指数函数</strong></p>
</li>
<li><p><code>math.fabs()</code>，浮点数形式返回数字的绝对值</p>
</li>
<li><p><code>math.log(x)</code>返回自然对数</p>
</li>
<li><p><code>math.log10(x)</code>返回以10为底的对数</p>
</li>
<li><p><code>math.modf()</code> 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p>
</li>
<li><p><code>math.sqrt()</code>返回平方根</p>
</li>
<li><p><code>round(x[,n)</code>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></p>
</li>
<li></li>
</ul>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><ul>
<li><p><code>\a</code> 响铃</p>
</li>
<li><p><code>\b</code>退一个字符</p>
</li>
<li><p><code>\000</code> 空</p>
</li>
<li><p><code>\v</code>纵向制表符</p>
</li>
<li><p><code>\t</code>横向制表符</p>
</li>
<li><p><code>\r</code> 回车，将 <code>\r</code> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将<code>\r</code>后面的内容完全替换完成。</p>
</li>
<li><p><code>\f</code>换页</p>
</li>
<li><p><code>\yyy</code> 输出八进制数<code>yyy</code>代表的字符 ，y 代表 0~7 的字符，例如：<code>\012</code>代表换行。</p>
</li>
<li><p><code>\xyy</code> 十六进制数，以 <code>\x</code> 开头，<code>y</code> 代表的字符，例如：<code>\x0a</code> 代表换行</p>
</li>
<li><p><code>r+字符串</code> 表示原始字符，比如<code>r&quot;slk\nsd&quot;</code></p>
</li>
</ul>
<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p>参考链接<a href="https://www.runoob.com/python3/python3-string.html">Python3 字符串 | 菜鸟教程</a></p>
<ul>
<li><h2 id="格式化符"><a href="#格式化符" class="headerlink" title="格式化符"></a>格式化符</h2></li>
</ul>

<ul>
<li><h2 id="格式化操作符辅助指令"><a href="#格式化操作符辅助指令" class="headerlink" title="格式化操作符辅助指令:"></a>格式化操作符辅助指令:</h2></li>
</ul>

<ul>
<li><h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出:<code>x+1=2</code></p>
</li>
</ul>
<h1 id="字符串内建函数"><a href="#字符串内建函数" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h1><ul>
<li><h2 id="大小写-格式"><a href="#大小写-格式" class="headerlink" title="大小写/格式"></a>大小写/格式</h2><ul>
<li><p><code>str.capitalize()</code></p>
<p>将字符串的第一个字母变成大写，其他字母变小写。</p>
</li>
<li><p><code>str.lower()</code></p>
<p>转换字符串中所有大写字符为小写.</p>
</li>
<li><p><code>str.upper()</code></p>
<p>转换字符串中的小写字母为大写</p>
</li>
<li><p><code>str.title()</code></p>
<p>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写</p>
</li>
<li><p><code>str.center(width[, fillchar])</code></p>
<p>返回一个指定的宽度 width 居中的字符串，如果 width 小于字符串宽度直接返回字符串，否则使用 fillchar 去填充。</p>
</li>
<li><p><code>str.islower()</code></p>
<p>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</p>
</li>
<li><p><code>str.isupper()</code></p>
<p>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</p>
</li>
<li><p><code>str.istitle()</code></p>
<p>如果字符串是标题化的(所有单词都是以大写开始，其余字母均为小写)则返回 True，否则返回 False</p>
</li>
<li><p><code>str.isspace()</code></p>
<p>如果字符串中只包含空白，则返回 True，否则返回 False.</p>
</li>
<li><p><code>str.swapcase()</code></p>
<p>用于对字符串的大小写字母进行转换，<strong>即将大写字母转换为小写字母，小写字母会转换为大写字母</strong>。</p>
</li>
</ul>
</li>
<li><h2 id="字符-数字-检测"><a href="#字符-数字-检测" class="headerlink" title="字符/数字/检测"></a>字符/数字/检测</h2><ul>
<li><p><code>str.isalnum()</code></p>
<p>检查字符串是否由字母和数字组成，即字符串中的所有字符都是字母或数字。</p>
<p>如果字符串为空（长度为0），则返回 <code>False</code>，因为空字符串不包含任何字母或数字。</p>
<p><strong>特殊字符（如标点符号、空格、特殊符号等）不被认为是字母或数字。</strong></p>
<p><strong>汉字被认为是字母。</strong></p>
</li>
<li><p><code>str.isalpha()</code></p>
<p>当字符串里面<strong>所有字符</strong>都是字母(包含汉字)的时候，返回True，否则返回False。</p>
<p>空字符返回False.</p>
</li>
<li><p><code>str.isdigit()</code></p>
<p>如果字符串<strong>只包含数字</strong>则返回 True 否则返回 False..</p>
</li>
<li><p>str.numeric()</p>
<p>isnumeric() 方法检测字符串是否只由数字组成，数字可以是： Unicode 数字，全角数字（双字节），罗马数字，汉字数字。</p>
<p>指数类似 ² 与分数类似 ½ 也属于数字。</p>
</li>
</ul>
</li>
<li><h2 id="检测特定位置的字符"><a href="#检测特定位置的字符" class="headerlink" title="检测特定位置的字符"></a>检测特定位置的字符</h2><ul>
<li></li>
</ul>
</li>
<li><h2 id="分割-移除-替换"><a href="#分割-移除-替换" class="headerlink" title="分割/移除/替换"></a>分割/移除/替换</h2><ul>
<li><p><code>str.strip([chars]);</code></p>
<p>用于移除字符串<strong>头尾</strong>指定的字符（默认为空格）或字符序列</p>
</li>
<li><p><code>str.lstrip([chars])</code></p>
<p>截掉字符串<strong>左边</strong>的空格或指定字符。</p>
</li>
<li><p><code>str.rstrip([chars])</code></p>
<p>截掉字符串<strong>右边</strong>的空格或指定字符。</p>
</li>
<li><p><code>str.split(str=&quot;&quot;, num=string.count(str))</code></p>
<p>通过指定分隔符对字符串进行切片，该方法将字符串分割成子字符串并返回一个由这些子字符串组成的列表。</p>
<p>如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。</p>
</li>
<li><p><code>str.replace(old, new [, max])</code></p>
<p>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</p>
</li>
<li><p><code>str.splitlines([keepends])</code></p>
<p>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。默认为 False</p>
</li>
<li><p>翻译函数<code>str.maketrans()</code>和<code>str.translate(table)</code></p>
<ul>
<li><p><code>string.maketrans(x[, y[, z]])</code></p>
<p>用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</p>
<p>x — 必需，字符串中要替代的字符组成的字符串。</p>
<p>y — 可选，相应的映射字符的字符串。</p>
<p>z — 可选，要删除的字符。</p>
</li>
<li><p><code>str.translate(table)</code></p>
<p>返回翻译后的字符串,若给出了 delete 参数，则将原来的bytes中的属于delete的字符删除，剩下的字符要按照table中给出的映射来进行映射 。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">intab = <span class="string">&quot;aeiou&quot;</span></span><br><span class="line">outtab = <span class="string">&quot;12345&quot;</span></span><br><span class="line">trantab = <span class="built_in">str</span>.maketrans(intab, outtab)   <span class="comment"># 制作翻译表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;this is string example....wow!!!&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.translate(trantab))</span><br></pre></td></tr></table></figure>
<p>输出结果如下:</p>
<p><code>th3s 3s str3ng 2x1mpl2....w4w!!!</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><ul>
<li><p><code>len(string)</code></p>
<p>返回字符串长度</p>
</li>
<li><p><code>str.count(sub, start= 0,end=len(string))</code></p>
<p>统计字符串里某个字符或子字符串出现的次数。可选参数为在字符串搜索的开始与结束位置。</p>
</li>
</ul>
</li>
<li><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p><code>str.find(str, beg=0, end=len(string))</code></p>
<p>`方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，<strong>返回</strong>的是索引值在字符串中的<strong>起始位置</strong>。如果不包含索引值，返回-1。</p>
</li>
<li><p><code>str.rfind(str, beg=0, end=len(string))</code></p>
<p><code>rfind()</code>返回字符串最后一次出现的位置，如果没有匹配项则返回-1。</p>
</li>
<li><p><code>str.index(str, beg=0, end=len(string))</code></p>
<p>该方法与 <code>str.find()</code>方法一样，只不过如果str不在 string中会报一个异常。</p>
</li>
<li><p><code>rindex( str, beg=0, end=len(string))</code></p>
<p>类似于 index()，不过是从右边开始.</p>
</li>
<li><p><code>str.startswith(substr, beg=0,end=len(string));</code></p>
<p>用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查。不包括end本身</p>
</li>
<li><p><code>str.endswith(suffix[, start[, end]])</code></p>
<p>endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回 True，否则返回 False。可选参数 “start” 与 “end” 为检索字符串的开始与结束位置。不包括end本身</p>
</li>
</ul>
</li>
<li><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p><code>max(str)</code></p>
<p>返回字符串中最大的字母。</p>
</li>
<li><p><code>min(str)</code></p>
<p>返回字符串中最小的字母。</p>
</li>
<li><p><code>str.zfill(width)</code></p>
<p>返回指定长度的字符串，原字符串右对齐，前面填充0。</p>
</li>
<li><p><code>str.ljust(width[, fillchar])</code></p>
<p>返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。</p>
</li>
<li><p><code>str.rjust(width[, fillchar])</code></p>
<p>返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。</p>
</li>
<li><p><code>str.join()方法</code></p>
<p>用于将序列中的元素以指定的字符连接生成一个新的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;-&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;&quot;</span></span><br><span class="line">seq = (<span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;b&quot;</span>) <span class="comment"># 字符串序列</span></span><br><span class="line"><span class="built_in">print</span> (s1.join( seq ))</span><br><span class="line"><span class="built_in">print</span> (s2.join( seq ))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.runoob.com/python3/python3-string.html">Python3 字符串 | 菜鸟教程</a></p>
</li>
<li><p><a href="https://www.w3ccoo.com/python/python_strings.html">Python 字符串</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>转义字符</tag>
        <tag>字符串格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-decorators zip name main</title>
    <url>/2024/07/31/Python%20Relearning-decorators%20zip%20name%20main/</url>
    <content><![CDATA[<ul>
<li><p>sticky是<code>sticky</code> 值越大，顶置的文章越靠前</p>
</li>
<li><p>thumbnail: “IMAGE_LINK”</p>
<p>redefine对首页文章添加缩略图</p>
</li>
<li><p>摘要</p>
<p>excerpt: “这是文章摘要 This is the excerpt of the post”或者直接设置为false</p>
</li>
<li><p>massage: 文章的密码的提示，但是似乎没有什么用，总是显示Hey,password is required here.</p>
</li>
</ul>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p> 装饰器（decorators）是 Python 中的一种高级功能，它允许你动态地修改函数或类的行为。</p>
<p>装饰器是一种函数，它<strong>接受一个函数作为参数</strong>，并返回一个新的函数或修改原来的函数。</p>
<p>装饰器的语法使用 <strong>@decorator_name</strong>来应用在函数或方法上。</p>
<ul>
<li><h2 id="装饰器函数1，无返回值"><a href="#装饰器函数1，无返回值" class="headerlink" title="装饰器函数1，无返回值"></a>装饰器函数1，无返回值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数1，无返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate_fun2</span>(<span class="params">original_fun</span>):</span><br><span class="line">    <span class="comment"># 传入函数original_fun作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_print</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="comment"># 使用不定长参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在调用原始函数【前】添加的新功能&quot;</span>)</span><br><span class="line">        original_fun(*args,**kwargs)</span><br><span class="line">        <span class="comment">#调用原来的函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在调用原始函数【后】添加的新功能&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> add_print</span><br><span class="line"><span class="comment"># 装饰器通过 @ 符号应用在函数定义之前</span></span><br><span class="line"><span class="meta">@decorate_fun2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_msg</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a的值：&quot;</span>,a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b的值：&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">print_msg(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="装饰器函数2-带有返回值"><a href="#装饰器函数2-带有返回值" class="headerlink" title="装饰器函数2,带有返回值"></a>装饰器函数2,带有返回值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数2,带有返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate_fun2</span>(<span class="params">original_fun</span>):</span><br><span class="line">    <span class="comment"># 传入函数original_fun作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_print</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="comment"># 使用不定长参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在调用原始函数【前】添加的新功能&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用原来的函数.有返回值</span></span><br><span class="line">        result=original_fun(*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在调用原始函数【后】添加的新功能&quot;</span>)</span><br><span class="line">        <span class="comment"># 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> add_print</span><br><span class="line"><span class="comment"># 装饰器通过 @ 符号应用在函数定义之前</span></span><br><span class="line"><span class="meta">@decorate_fun2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a的值：&quot;</span>,a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b的值：&quot;</span>,b)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">add_return_value=add(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 输出带有装饰器的函数的返回值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;带有返回值的装饰器函数返回值：&#x27;</span>,add_return_value)</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="装饰器函数3-修改返回值"><a href="#装饰器函数3-修改返回值" class="headerlink" title="装饰器函数3,修改返回值"></a>装饰器函数3,修改返回值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数3,修改返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate_fun3</span>(<span class="params">original_fun</span>):</span><br><span class="line">    <span class="comment"># 传入函数original_fun作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_print</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="comment"># 使用不定长参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在调用原始函数【前】添加的新功能&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用原来的函数.有返回值</span></span><br><span class="line">        result=original_fun(*args,**kwargs)*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在调用原始函数【后】添加的新功能&quot;</span>)</span><br><span class="line">        <span class="comment"># 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> add_print</span><br><span class="line"><span class="comment"># 装饰器通过 @ 符号应用在函数定义之前</span></span><br><span class="line"><span class="meta">@decorate_fun3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mutil</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a的值：&quot;</span>,a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b的值：&quot;</span>,b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;原来函数的返回值应该是:<span class="subst">&#123;a*b&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"></span><br><span class="line">add_return_value=mutil(<span class="number">5</span>,<span class="number">6</span>)  <span class="comment"># 输出带有装饰器的函数的返回值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;带有修改后的乘法装饰器函数返回值：&#x27;</span>,add_return_value)</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="装饰器函数4-带参数的装饰器"><a href="#装饰器函数4-带参数的装饰器" class="headerlink" title="装饰器函数4,带参数的装饰器"></a>装饰器函数4,带参数的装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate_fun4</span>(<span class="params">original_fun</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add_print</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># _表示丢弃参数，不关心参数的取值</span></span><br><span class="line">                <span class="comment"># 调用原来的函数</span></span><br><span class="line">                original_fun(*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> add_print</span><br><span class="line">    <span class="keyword">return</span> decorate_fun4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复三次</span></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_msg</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原始函数打印的信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_msg() <span class="comment"># 调用装饰器函数，会重复三次</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h1><p>列表里面的.pop()和.append()实现了栈的功能。</p>
<p><strong>栈</strong>是一种<strong>后进先出</strong>（<strong>LIFO,</strong> Last-In-First-Out）数据结构，意味着最后添加的元素最先被移除。列表提供了一些方法，使其非常适合用于栈操作，特别是 <strong>append()</strong> 和 <strong>pop()</strong> 方法。</p>
<p><strong>队列</strong>是一种<strong>先进先出</strong>(<strong>FIFO</strong>, First-In-First-Out)的数据结构，意味着最早添加的元素最先被移除。</p>
<p>使用列表时，如果频繁地在列表的开头插入或删除元素，性能会受到影响，因为这些操作的时间复杂度是 O(n)。为了解决这个问题，可以使用Python 提供了 collections.deque实现队列操作或者坚持使用列表来实现队列。</p>
<ul>
<li><h2 id="collections-deque实现队列"><a href="#collections-deque实现队列" class="headerlink" title="collections.deque实现队列"></a>collections.deque实现队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空队列</span></span><br><span class="line">queue = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向队尾添加元素</span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队首移除元素</span></span><br><span class="line">first_element = queue.popleft()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: deque([&#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看队首元素（不移除）</span></span><br><span class="line">front_element = queue[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查队列是否为空</span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取队列大小</span></span><br><span class="line">size = <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="使用list-pop-0-实现队列"><a href="#使用list-pop-0-实现队列" class="headerlink" title="使用list.pop(0)实现队列"></a>使用list.pop(0)实现队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 创建队列</span></span><br><span class="line">queue = []</span><br><span class="line"><span class="comment"># 2. 向队尾添加元素</span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment"># 3.使用 pop(0) 方法从队首移除元素：</span></span><br><span class="line">first_element = queue.pop(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">front_element = queue[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h1><p><strong>zip()</strong> 函数用于将<strong>可迭代的对象</strong>(<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>、<code>str</code>)作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p>
<p>在 Python 3.x 中为了减少内存，<strong>zip() 返回的是一个对象</strong>。如需展示列表，需手动 list() 转换。</p>
<p>同时注意：zip()函数和unzip()返回的是一个对象,这个对象只能迭代一次，也就是说，一旦用list转化后，这个对象就被消耗掉了，而list函数转化为列表后会得到一个元组构成的列表。</p>
<ul>
<li><h2 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接调用zip函数返回的是一个zip对象</span></span><br><span class="line">zipped1 = <span class="built_in">zip</span>(a, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zipped1的类型是:&quot;</span>, <span class="built_in">type</span>(zipped1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zipped1&quot;</span>, zipped1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用zip函数接受的列表如果不等长，元素个数与最短的列表一致</span></span><br><span class="line">zipped2 = <span class="built_in">zip</span>(a, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zipped2转换为列表后的长度：&quot;</span>, <span class="built_in">len</span>(<span class="built_in">list</span>(zipped2)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用list()函数转换后，返回一个由元组组成的列表</span></span><br><span class="line">zipped1_to_list = <span class="built_in">list</span>(zipped1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zipped1_to_list的类型是:&quot;</span>, <span class="built_in">type</span>(zipped1_to_list))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zipped1_to_list:&quot;</span>, zipped1_to_list)</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="unzip解压缩"><a href="#unzip解压缩" class="headerlink" title="unzip解压缩"></a>unzip解压缩</h2><ul>
<li><h3 id="正确解压缩"><a href="#正确解压缩" class="headerlink" title="正确解压缩"></a>正确解压缩</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 直接调用zip函数返回的是一个zip对象</span></span><br><span class="line">zipped1 = <span class="built_in">zip</span>(a, b)  <span class="comment"># 返回zip对象,只能迭代一次</span></span><br><span class="line">unzip=<span class="built_in">zip</span>(*zipped1)   <span class="comment"># 解压缩以后立即赋值给unzip,防止被消耗掉</span></span><br><span class="line">unzip_to_list=<span class="built_in">list</span>(unzip)   <span class="comment"># 转换为列表后立即赋值，防止被消耗掉，此时得到一个元组列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(unzip_to_list) <span class="comment"># 输出[(1, 2, 3), (4, 5, 6)]</span></span><br><span class="line">ori_a,ori_b=unzip_to_list <span class="comment"># 只有两个元素，直接赋值给ori_a,ori_b</span></span><br><span class="line"><span class="built_in">print</span>(ori_a,ori_b)   <span class="comment"># 输出(1, 2, 3) (4, 5, 6)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="错误的方式"><a href="#错误的方式" class="headerlink" title="错误的方式"></a>错误的方式</h3><ul>
<li><p><strong>zip和unzip返回的是一个zip对象，而不是一个元组列表！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误方法1</span></span><br><span class="line">ori_a, ori_b = <span class="built_in">zip</span>(*zipped1)</span><br><span class="line"><span class="comment"># 实际上，zip(*zipped1)会返回由a,b构成的元组列表的zip格式，即[(1, 2, 3), (4, 5, 6)]对应的zip格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ori_a:&#x27;</span>, ori_a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ori_b:&#x27;</span>, ori_b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>zip对象只能迭代一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误方法2</span></span><br><span class="line">unzip=<span class="built_in">zip</span>(*<span class="built_in">list</span>(zipped1))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(unzip) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(unzip))  <span class="comment"># 用了list方法，unzip就被消耗掉了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">list</span>(unzip))) <span class="comment">#返回0</span></span><br><span class="line">unzip=<span class="built_in">list</span>(unzip)</span><br><span class="line">ori_a, ori_b =unzip[<span class="number">0</span>],unzip[<span class="number">1</span>] <span class="comment">#报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ori_a:&#x27;</span>, ori_a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ori_b:&#x27;</span>, ori_b)</span><br><span class="line"><span class="comment"># unzip是一个zip对象，它只能被迭代一次。一旦它被转换为列表，unzip对象就被消耗了，再次调用list(unzip)将会返回一个空列表</span></span><br></pre></td></tr></table></figure>
<p>ori_b)</p>
<p>unzip是一个zip对象，它只能被迭代一次。一旦它被转换为列表，unzip对象就被消耗了，再次调用list(unzip)不起作用。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>``</p>
<h1 id="Python中的-name-和-main"><a href="#Python中的-name-和-main" class="headerlink" title="Python中的__name__和__main__"></a>Python中的<code>__name__</code>和<code>__main__</code></h1><p>当 Python 解释器读取一个 Python 文件时，它首先设置一些特殊变量，然后执行文件中的代码。</p>
<p>其中一个变量叫作 <code>__name__</code>。</p>
<p>规则如下：</p>
<ul>
<li><p>现在执行的文件，其<code>__name__</code>的值被设置为<code>main</code></p>
</li>
<li><p>如果代码是从另一个模块导入模块，则 <code>__name__</code> 变量将被设置为该模块的名称。</p>
</li>
<li><p>如果<em>A.py</em>导入了模块<em>B.py</em>，<em>A.py</em>会执行导入的所有部分</p>
</li>
<li><p>如果导入模块的某些变量和执行的程序的某些变量有冲突，比如导入的模块<code>module.py</code>中定义<code>a=1</code>,但是执行文件中定义<code>a=2,</code>在用<code>from mudule import *</code>之后，就会产生冲突，</p>
<p>此时看<code>from mudule import *</code>和<code>a=2</code>的<strong>顺序</strong>，以最后一个为准，谁在后谁是最终的<code>a</code>的值。</p>
</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><ul>
<li><a href="https://www.runoob.com/python3/python-decorators.html">Python 装饰器 | 菜鸟教程</a></li>
<li><a href="https://www.cnblogs.com/guolongnv/articles/15844242.html">Python 中的 if <strong>name</strong> == <strong>main</strong> - guolongnv - 博客园</a></li>
<li><a href="https://www.freecodecamp.org/chinese/news/if-name-main-python-example/">https://www.freecodecamp.org/chinese/news/if-name-main-python-example/</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
        <tag>丢弃变量_</tag>
        <tag>zip与unzip</tag>
        <tag>__name__</tag>
        <tag>__main__</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-object oriented</title>
    <url>/2024/07/26/Python%20Relearning-object%20oriented/</url>
    <content><![CDATA[<h1 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h1><ul>
<li>1、通常我们约定，两个下划线(__)开头的属性是私有的（private）。其他为公共的（public）；</li>
<li>2、类内部可以访问私有属性（方法）；</li>
<li>3、类外部不能直接访问私有属性（方法）；</li>
<li>4、类外部可以通过 ”<em>类名_</em>私有属性（方法）名“ 访问私有属性（方法）</li>
</ul>
<p>例程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line">    __price = <span class="number">25.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, u_name, u_age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.uname = u_name</span><br><span class="line">        <span class="variable language_">self</span>.__uage = u_age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是私有方法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用共有属性：&quot;</span>, <span class="variable language_">self</span>.uname)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用私有属性：&quot;</span>, <span class="variable language_">self</span>.__uage)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用私有类属性：&quot;</span>, <span class="variable language_">self</span>.__price)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是公有方法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用共有属性：&quot;</span>, <span class="variable language_">self</span>.uname)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用私有属性：&quot;</span>, <span class="variable language_">self</span>.__uage)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用私有类属性：&quot;</span>, <span class="variable language_">self</span>.__price)  </span><br><span class="line">d = Demo(<span class="string">&quot;Liu&quot;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用共有方法</span></span><br><span class="line">d.name</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是公有方法</span></span><br><span class="line"><span class="string">调用共有属性： Tom</span></span><br><span class="line"><span class="string">调用私有属性： 18</span></span><br><span class="line"><span class="string">调用私有类属性： 25.8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用私有方法（错误示范）</span></span><br><span class="line">d.__age()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/Local/PycharmProjects/private_obj/demo.py&quot;, line 32, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    d.__age()</span></span><br><span class="line"><span class="string">AttributeError: &#x27;Demo&#x27; object has no attribute &#x27;__age&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用私有方法（正确示例）</span></span><br><span class="line">d._Demo__age()</span><br><span class="line">d._Demo__</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是私有方法</span></span><br><span class="line"><span class="string">调用共有属性： Tom</span></span><br><span class="line"><span class="string">调用私有属性： 18</span></span><br><span class="line"><span class="string">调用私有类属性： 25.8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用私有属性</span></span><br><span class="line"><span class="built_in">print</span>(Demo._Demo__price) <span class="comment"># 25.8</span></span><br><span class="line"><span class="built_in">print</span>(d._Demo__uage) <span class="comment"># 18</span></span><br></pre></td></tr></table></figure>
<p>方法本质上也是属性！只不过是可以通过（）执行而已。</p>
<p>因此私有方法的调用和私有属性的调用基本一样。</p>
<h1 id="单继承和多继承"><a href="#单继承和多继承" class="headerlink" title="单继承和多继承"></a>单继承和多继承</h1><h2 id="用不用super-init-方法："><a href="#用不用super-init-方法：" class="headerlink" title="用不用super.__init__()方法："></a>用不用<code>super.__init__()</code>方法：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base_class</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line">        <span class="variable language_">self</span>.feature_A=A</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类的构造函数&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;属性A:&#x27;</span>,<span class="variable language_">self</span>.feature_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son_class1</span>(<span class="title class_ inherited__">base_class</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line">        base_class.__init__(<span class="variable language_">self</span>,A)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son_class2</span>(<span class="title class_ inherited__">base_class</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(A)</span><br><span class="line"></span><br><span class="line">son1=son_class1(<span class="number">1</span>)</span><br><span class="line">son2=son_class2(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这两个继承的案例中，一个用了super().<strong>init</strong>，一个没用，效果相同，请问有什么区别?</p>
<p>下面是质谱清言的回答：</p>
<blockquote>
<p>在Python中，<code>super()</code> 函数是用来调用父类（超类或基类）的一个方法的。在您的例子中，<code>son_class1</code> 和 <code>son_class2</code> 都正确地调用了 <code>base_class</code> 的构造函数，但是它们使用的方法略有不同：</p>
<ol>
<li><code>son_class1</code> 使用了直接父类名称来调用构造函数：<code>base_class.__init__(self, A)</code>。这种方法是明确的，它直接指明了要调用的基类。这在单继承的情况下工作得很好，但如果涉及到多继承，这种方法可能会导致一些问题，因为它不会考虑方法解析顺序（MRO），可能会导致一些父类的方法没有被正确调用。</li>
<li><code>son_class2</code> 使用了 <code>super()</code> 函数：<code>super().__init__(A)</code>。<code>super()</code> 在这里会自动找到 <code>son_class2</code> 在MRO中的下一个类，并调用它的 <code>__init__</code> 方法。这种方法在单继承和多继承中都能正确地工作，因为它自动遵循MRO。<code>super()</code> 的使用也是Python风格指南推荐的。<br>以下是两种方法的主要区别：</li>
</ol>
<ul>
<li><strong>多继承中的兼容性</strong>：<code>super()</code> 在多继承中可以正确地处理方法调用顺序，遵循MRO，确保每个父类的方法只会被调用一次。而直接使用父类名称的方法在多继承中可能会导致某个父类的方法被多次调用或者完全不被调用。</li>
<li><strong>代码的可维护性</strong>：使用 <code>super()</code> 可以让代码更加简洁，并且在未来如果类的继承关系发生变化时，使用 <code>super()</code> 的代码通常不需要修改。</li>
<li><strong>参数传递</strong>：在使用 <code>super()</code> 时，不需要显式地传递 <code>self</code> 参数，因为 <code>super()</code> 在当前类的上下文中工作，自动处理了 <code>self</code>。<br>在实践中，推荐使用 <code>super()</code>，因为它更符合Python的设计哲学，且在复杂继承结构中更加可靠。在单继承的情况下，两种方法都可以正常工作，但在多继承的情况下，使用 <code>super()</code> 会是更好的选择。</li>
</ul>
</blockquote>
<ul>
<li><p>推荐使用<code>super()</code>方法，<strong>该方法不需要传递self!</strong></p>
</li>
<li><p>super()方法还可以继承其他的函数，都是一样的，并非只有构造函数。</p>
</li>
<li><p>例程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base_class1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line">        <span class="variable language_">self</span>.feature_A=A</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类1的构造函数被调用&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;父类1的属性A:&#x27;</span>,<span class="variable language_">self</span>.feature_A)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类1的函数被调用&quot;</span>)</span><br><span class="line"><span class="comment"># 父类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base_class2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line">        <span class="variable language_">self</span>.feature_A=A</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类2的构造函数被调用&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;父类2的属性A:&#x27;</span>,<span class="variable language_">self</span>.feature_A)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类2的函数被调用&quot;</span>)</span><br><span class="line"><span class="comment"># 子类1，继承自父类1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son_class1</span>(<span class="title class_ inherited__">base_class1</span>):</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line"> base_class1.__init__(<span class="variable language_">self</span>,A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类2，继承自父类1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son_class2</span>(<span class="title class_ inherited__">base_class1</span>):</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line"> <span class="built_in">super</span>().__init__(A)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------单继承（直接父类名称）------------&quot;</span>)</span><br><span class="line"> son1=son_class1(<span class="number">1</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;----------单继承(使用super() 函数)------------&quot;</span>)</span><br><span class="line"> son2=son_class2(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多继承</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------多继承(使用super() 函数)------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类3，继承自父类1和父类2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son_class3</span>(base_class2,base_class1):</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,A</span>):</span><br><span class="line"> <span class="built_in">super</span>().__init__(A) <span class="comment"># super方法不需要传递self参数</span></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">self</span>):</span><br><span class="line"> <span class="built_in">super</span>().fun()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;构造函数的继承：&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> son3 = son_class3(<span class="number">3</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;其他函数的继承：&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> son3.fun()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="其他的知识："><a href="#其他的知识：" class="headerlink" title="其他的知识："></a>其他的知识：</h1><h2 id="init方法和-new方法"><a href="#init方法和-new方法" class="headerlink" title="init方法和 new方法"></a><strong>init</strong>方法和 <strong>new</strong>方法</h2><p>他们会在类实例化的时候自动调用，并先调用new方法，再调用Init方法。</p>
<h2 id="dir函数"><a href="#dir函数" class="headerlink" title="dir函数"></a>dir函数</h2><ul>
<li><p><code>dir()</code> 是一个内置函数，用于列出对象的所有属性及方法。在 Python 中，一切皆对象</p>
</li>
<li><p>如果 <code>dir()</code> 没有参数，则返回当前作用域中的名称列表</p>
</li>
</ul>
<h2 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance()函数"></a>isinstance()函数</h2><p>内置方法 <code>isinstance(obj, class)</code> 用来判断一个对象是否是某个类的实例。</p>
<h2 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h2><p> object 是所有类的基类（Base Class，也被称为超类（Super Class）或父类），如果一个类在定义中没有明确定义继承的基类，那么默认就会继承 object。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.cnblogs.com/desireyang/p/12738649.html">关于Python中的私有属性和私有方法 - DesireYang - 博客园</a></p>
</li>
<li><p><a href="https://www.runoob.com/python3/python3-class.html">Python3 面向对象 | 菜鸟教程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-file try Error</title>
    <url>/2024/07/31/Python%20Relearning-file%20try%20Error/</url>
    <content><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p><strong>异常</strong>：程序正常执行过程中出现的不正常的情况，该情况影响了程序的正常执行。</p>
<p><strong>异常程序</strong>：是指程序执行的非法指令，比如常见的非法操作码，地址越界，算术溢出等，异常程序的出现一般有两种情况：</p>
<p>Python提供了两个非常重要的功能来处理程序在运行中出现的异常和错误。经常使用的是try…except语句，拓展一下就是<strong>try-except-else-finally</strong>，另一个是断言.</p>
<h2 id="各个语句的功能："><a href="#各个语句的功能：" class="headerlink" title="各个语句的功能："></a>各个语句的功能：</h2><ul>
<li><p><strong>try</strong>：正常执行的程序，如果执行过程中出现异常，则中断当前的程序执行，跳转到对应的异常处理模块中；</p>
</li>
<li><p><strong>except</strong>：<strong>可选</strong> ,如果异常与<code>A/B</code>相匹配，则跳转到对应的<code>except A/B</code>中执行；如果<code>A、B</code>中没有相对应的异常，则跳转到except中执行。（这个<code>except</code>块是可选的，如果没有提供，则执行python默认的异常处理程序，即：中断执行，打印提示信息）</p>
<p>为异常类型，可指定可不指定</p>
</li>
<li><p><strong>else</strong>：<strong>可选</strong>,如果<code>try</code>中的程序执行过程中<strong>没有发生错误且无返回值</strong>，则会继续执行<code>else</code>中的程序；</p>
</li>
<li><p><strong>finally</strong>：<strong>可选</strong>,无论是否发生异常，只要提供了<code>finally</code>程序，就在执行所有步骤之后执行<code>finally</code>中的程序。</p>
<p> 正常执行的程序在<code>try</code>下面执行，在执行中如果发生了异常，则中断当前执行然后执行<code>except</code>中的部分，如果没有异常即不执行<code>except</code>的情况下，则会执行<code>else</code>中的语句，<code>finally</code>语句是最后无论是否有异常都要执行的代码。</p>
</li>
</ul>
<h2 id="顺序和执行规则"><a href="#顺序和执行规则" class="headerlink" title="顺序和执行规则"></a>顺序和执行规则</h2><ul>
<li><ol>
<li>完整的格式顺序是：<code>try —&gt; except X —&gt; except —&gt; else—&gt; finally</code></li>
<li>如果 <code>else</code>和<code>finally</code>都存在的话，<code>else</code>必须在<code>finally</code> 之前，<code>finally</code>必须在整个程序的最后。</li>
<li><code>else</code>的存在是以<code>except</code>或<code>except X</code> 的存在为前提，如果没有 <code>except</code>，而在<code>try</code>中使用<code>else</code> 的话，会出现语法错误。</li>
<li>如果程序没有错误，且try无返回值，会跳过<code>except</code>或 <code>except X</code>,执行<code>else</code></li>
</ol>
</li>
<li><h3 id="执行顺序和返回值分析"><a href="#执行顺序和返回值分析" class="headerlink" title="执行顺序和返回值分析"></a>执行顺序和返回值分析</h3><p><strong>首先，finally的优先级最高，如果有finally语句，那么它的语句一定会被执行（不管前面的语句有无返回值），如果finally有返回值，那么finally的返回值就是最终的返回值。</strong></p>
<p><strong>其次，如果没有finally语句，要观察有没有返回值。</strong></p>
<p><strong>如果是按照A—&gt;B—&gt;C的顺序执行，那么依次观察A、B、C的内部有无返回值，如果遇到了返回值，那么立即中断执行，后续语句不会执行。例如：</strong></p>
<ul>
<li><p><strong>无错误的情况下，语句按照try—&gt;else的顺序，但是如果try有返回值，那么程序立即返回到了try的返回值，else语句不会被执行，最终的返回值也是try的返回值。</strong></p>
</li>
<li><p><strong>同理，有错误的情况下，语句直接执行except，此时返回值就是except的返回值。如果是按照A—&gt;B—&gt;C的顺序执行，那么依次观察A、B、C的内部有无返回值，如果遇到了返回值，那么立即中断执行，后续语句不会执行。</strong></p>
</li>
</ul>
<p><strong>如果有finally语句，前面语句的执行顺序不变，执行完之后执行finally语句，如果finally有返回值，那么finally的返回值就是最终的返回值。如果finally无返回值，那么finally前面语句的返回值就是最终的返回值。</strong></p>
<p><strong>例程1（无返回值）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,<span class="string">&#x27;【无返回值】的时候&#x27;</span>.center(<span class="number">60</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;【无finally】的时候&quot;</span>.center(<span class="number">40</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=<span class="number">3</span>/x</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;try被执行——&gt;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;expect被执行——&gt;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;else被执行——&gt;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># finally:</span></span><br><span class="line">    <span class="comment">#     return &#x27;finally的返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有错误的时候</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;【无错误】的时候&quot;</span>.center(<span class="number">20</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">fun(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有错误的时候</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;【有错误】的时候&quot;</span>.center(<span class="number">20</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">fun(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;【有】finally的时候&quot;</span>.center(<span class="number">40</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=<span class="number">3</span>/x</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;try被执行——&gt;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;expect被执行——&gt;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;else被执行——&gt;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally被执行&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有错误的时候</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;【无错误】的时候&quot;</span>.center(<span class="number">20</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">fun(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有错误的时候</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;【有错误】的时候&quot;</span>.center(<span class="number">20</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">fun(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>例程2（有返回值）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>断言语句用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。</p>
<p>一个复杂的程序，如果存在潜在的错误，<strong>与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃</strong>，这有利于我们对程序排错，提高程序的健壮性。</p>
<ul>
<li><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> expression:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式==<span class="literal">True</span>:</span><br><span class="line">    程序继续执行</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    程序报 AssertionError 错误</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从键盘读取时间</span></span><br><span class="line">hour=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入现在的钟点:\n&quot;</span>))</span><br><span class="line"><span class="comment"># 断言时间是0~24之间</span></span><br><span class="line"><span class="keyword">assert</span> hour <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">25</span>)</span><br><span class="line"><span class="comment"># 如果时间是0~24之间，打印输出，否则抛出AssertionError错误</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;现在是<span class="subst">&#123;hour&#125;</span>时&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果输入正确，会执行print(f”现在是{hour}时”)语句</p>
<p>如果输入错误，比如输如25，会抛出错误：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:\codes\Python\python_relearning\file&amp;error.py&quot;</span>, line <span class="number">140</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">assert</span> hour <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">25</span>)</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="常见的断言函数"><a href="#常见的断言函数" class="headerlink" title="常见的断言函数"></a>常见的断言函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">assertEqual(a, b)     a == b      </span><br><span class="line">assertNotEqual(a, b)     a != b      </span><br><span class="line">assertTrue(x)     <span class="built_in">bool</span>(x) <span class="keyword">is</span> <span class="literal">True</span>      </span><br><span class="line">assertFalse(x)     <span class="built_in">bool</span>(x) <span class="keyword">is</span> <span class="literal">False</span>      </span><br><span class="line">assertIs(a, b)     a <span class="keyword">is</span> b     <span class="number">2.7</span></span><br><span class="line">assertIsNot(a, b)     a <span class="keyword">is</span> <span class="keyword">not</span> b     <span class="number">2.7</span></span><br><span class="line">assertIsNone(x)     x <span class="keyword">is</span> <span class="literal">None</span>     <span class="number">2.7</span></span><br><span class="line">assertIsNotNone(x)     x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>     <span class="number">2.7</span></span><br><span class="line">assertIn(a, b)     a <span class="keyword">in</span> b     <span class="number">2.7</span></span><br><span class="line">assertNotIn(a, b)     a <span class="keyword">not</span> <span class="keyword">in</span> b     <span class="number">2.7</span></span><br><span class="line">assertIsInstance(a, b)     <span class="built_in">isinstance</span>(a, b)     <span class="number">2.7</span></span><br><span class="line">assertNotIsInstance(a, b)     <span class="keyword">not</span> <span class="built_in">isinstance</span>(a, b)     <span class="number">2.7</span></span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="其他的断言函数"><a href="#其他的断言函数" class="headerlink" title="其他的断言函数"></a>其他的断言函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">assertAlmostEqual(a, b)     <span class="built_in">round</span>(a-b, <span class="number">7</span>) == <span class="number">0</span>      </span><br><span class="line">assertNotAlmostEqual(a, b)     <span class="built_in">round</span>(a-b, <span class="number">7</span>) != <span class="number">0</span>      </span><br><span class="line">assertGreater(a, b)     a &gt; b     <span class="number">2.7</span></span><br><span class="line">assertGreaterEqual(a, b)     a &gt;= b     <span class="number">2.7</span></span><br><span class="line">assertLess(a, b)     a &lt; b     <span class="number">2.7</span></span><br><span class="line">assertLessEqual(a, b)     a &lt;= b     <span class="number">2.7</span></span><br><span class="line">assertRegexpMatches(s, re)     regex.search(s)     <span class="number">2.7</span></span><br><span class="line">assertNotRegexpMatches(s, re)     <span class="keyword">not</span> regex.search(s)     <span class="number">2.7</span></span><br><span class="line">assertItemsEqual(a, b)     <span class="built_in">sorted</span>(a) == <span class="built_in">sorted</span>(b) <span class="keyword">and</span> works <span class="keyword">with</span> unhashable objs     <span class="number">2.7</span></span><br><span class="line">assertDictContainsSubset(a, b)     <span class="built_in">all</span> the key/value pairs <span class="keyword">in</span> a exist <span class="keyword">in</span> b     <span class="number">2.7</span></span><br><span class="line">assertMultiLineEqual(a, b)     strings     <span class="number">2.7</span></span><br><span class="line">assertSequenceEqual(a, b)     sequences     <span class="number">2.7</span></span><br><span class="line">assertListEqual(a, b)     lists     <span class="number">2.7</span></span><br><span class="line">assertTupleEqual(a, b)     tuples     <span class="number">2.7</span></span><br><span class="line">assertSetEqual(a, b)     sets <span class="keyword">or</span> frozensets     <span class="number">2.7</span></span><br><span class="line">assertDictEqual(a, b)     dicts     <span class="number">2.7</span></span><br><span class="line">assertMultiLineEqual(a, b)     strings     <span class="number">2.7</span></span><br><span class="line">assertSequenceEqual(a, b)     sequences     <span class="number">2.7</span></span><br><span class="line">assertListEqual(a, b)     lists     <span class="number">2.7</span></span><br><span class="line">assertTupleEqual(a, b)     tuples     <span class="number">2.7</span></span><br><span class="line">assertSetEqual(a, b)     sets <span class="keyword">or</span> frozensets     <span class="number">2.7</span>assertDictEqual(a, b)     dicts     <span class="number">2.7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="open-和with-open"><a href="#open-和with-open" class="headerlink" title="open 和with open"></a>open 和with open</h2><p>open是Python的一个内置函数，一般用于本地文件的读写操作。with open不是一个整体，是使用了with语句的open函数。with open可以说是open的优化用法或高级用法，相比open更加简洁、安全。open函数必须搭配.close()方法使用，先用open打开文件，然后进行读写操作，最后用.close()释放文件。with open则无需.close()语句，所以说简洁。</p>
<p>如果文件不存在，会自动在路径下创建一个文件</p>
<p><strong>完整的语法格式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li><p>file: 必需，文件路径（相对或者绝对路径）。</p>
</li>
<li><p>mode: 可选，文件打开模式</p>
</li>
<li><p>buffering: 设置缓冲</p>
</li>
<li><p>encoding: 一般使用utf8</p>
</li>
<li><p>errors: 报错级别</p>
</li>
<li><p>newline: 区分换行符</p>
</li>
<li><p>closefd: 传入的file参数类型</p>
</li>
<li><p>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</p>
</li>
<li><p>例程</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">filepath1=<span class="string">&#x27;file1.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filepath1,<span class="string">&#x27;w&#x27;</span>)<span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        file.write(<span class="string">f&quot;这是第<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>行\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件已写入！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line">filepath2=<span class="string">&#x27;file2.txt&#x27;</span></span><br><span class="line">file=<span class="built_in">open</span>(filepath2, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        file.write(<span class="string">f&quot;这是第<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>行\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件已写入！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure>
<h3 id="参数mode的类型"><a href="#参数mode的类型" class="headerlink" title="参数mode的类型"></a>参数mode的类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td>x</td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式。</td>
</tr>
<tr>
<td>+</td>
<td>打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td>U</td>
<td>通用换行模式（<strong>Python 3 不支持</strong>）。</td>
</tr>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="file-对象的属性"><a href="#file-对象的属性" class="headerlink" title="file 对象的属性"></a>file 对象的属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file.closed</td>
<td>如果文件已被关闭，返回true，否则返回false</td>
</tr>
<tr>
<td>file.mode</td>
<td>返回被打开文件的访问模式</td>
</tr>
<tr>
<td>file.name</td>
<td>返回文件的名称</td>
</tr>
</tbody>
</table>
</div>
<h2 id="file对象的方法"><a href="#file对象的方法" class="headerlink" title="file对象的方法"></a>file对象的方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong><a href="https://www.runoob.com/python/file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong><a href="https://www.runoob.com/python/file-flush.html">file.flush()</a> 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待文件关闭后自动刷新缓冲区。</strong></td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/python/file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/python/file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.runoob.com/python/file-next.html">file.next()</a>返回文件下一行。</td>
</tr>
<tr>
<td>6</td>
<td><strong><a href="https://www.runoob.com/python/python-file-read.html">file.read([size])</a>读取整个文件，返回的是一个字符串，字符串包括文件中的所有内容从文件读取指定的字节数，如果未给定或为负则读取所有。默认为 -1，表示读取整个文件。返回的是一个字符串，字符串包括文件中的所有内容。速度最快</strong></td>
</tr>
<tr>
<td>7</td>
<td><strong><a href="https://www.runoob.com/python/file-readline.html">file.readline([size])</a>每次读取下一行文件，包括 “\n” 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “\n” 字符。当内存不足时，使用readline()可以每次读取一行数据，只需要很少的内存</strong></td>
</tr>
<tr>
<td>8</td>
<td><strong><a href="https://www.runoob.com/python/file-readlines.html">file.readlines([sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力.</strong></td>
</tr>
<tr>
<td>9</td>
<td>**<a href="https://www.runoob.com/python/file-seek.html">file.seek(offset[, whence])</a>设置文件当前位置，<br>offset: 将光标向前移动n个位置,n可以是负数 <br/>whence: 参考位置，一般参数为0,1,2</td>
</tr>
<tr>
<td><br/>0 ：将开头作为参考位置</td>
<td></td>
</tr>
<tr>
<td><br/>1 ：将当前作为参考位置</td>
<td></td>
</tr>
<tr>
<td><br/>2 ：将末尾作为参考位置**</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td><strong><a href="https://www.runoob.com/python/file-tell.html">file.tell()</a>返回文件当前位置。即文件指针当前位置</strong></td>
</tr>
<tr>
<td>11</td>
<td><strong><a href="https://www.runoob.com/python/file-truncate.html">file.truncate([size])</a>截取文件，截取的字节通过size指定，默认为当前文件位置。返回截断的字节长度。参数size是从当前位置开始保留的字符长度，超过size的就截断丢弃，汉字GBK编码，一个汉字长度为2，字母是1</strong></td>
</tr>
<tr>
<td>12</td>
<td><strong><a href="https://www.runoob.com/python/python-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</strong></td>
</tr>
<tr>
<td>13</td>
<td><strong><a href="https://www.runoob.com/python/file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列(如字符串列表），如果需要换行则要自己加入每行的换行符。</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><h3 id="打开文件，读取内容"><a href="#打开文件，读取内容" class="headerlink" title="打开文件，读取内容"></a>打开文件，读取内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件并读取内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<h3 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;Hello, World!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="追加内容到文件"><a href="#追加内容到文件" class="headerlink" title="追加内容到文件"></a>追加内容到文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 追加内容到文件</span><br><span class="line">with open(&#x27;example.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    file.write(&#x27;</span><br><span class="line">New line&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="读取文件的某一行"><a href="#读取文件的某一行" class="headerlink" title="读取文件的某一行"></a>读取文件的某一行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取文件的某一行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    line = file.readlines()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>
<h3 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逐行读取文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(line.strip())</span><br></pre></td></tr></table></figure>
<h3 id="使用fileinput模块修改文件内容"><a href="#使用fileinput模块修改文件内容" class="headerlink" title="使用fileinput模块修改文件内容"></a>使用fileinput模块修改文件内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fileinput模块修改文件内容</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.<span class="built_in">input</span>(<span class="string">&#x27;example.txt&#x27;</span>, inplace=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(line.replace(<span class="string">&#x27;old_text&#x27;</span>, <span class="string">&#x27;new_text&#x27;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> source, <span class="built_in">open</span>(<span class="string">&#x27;copy.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> destination:</span><br><span class="line">    destination.write(source.read())</span><br></pre></td></tr></table></figure>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;moved_example.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.remove(<span class="string">&#x27;example.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;renamed_example.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.mkdir(<span class="string">&#x27;new_folder&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除文件夹</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rmdir(<span class="string">&#x27;new_folder&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="遍历文件夹下的所有文件"><a href="#遍历文件夹下的所有文件" class="headerlink" title="遍历文件夹下的所有文件"></a>遍历文件夹下的所有文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历文件夹中的所有文件</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(file)</span><br></pre></td></tr></table></figure>
<h3 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取文件大小</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file_size = os.path.getsize(<span class="string">&#x27;example.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(file_size)</span><br></pre></td></tr></table></figure>
<h3 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a>检查文件是否存在</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;example.txt&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件不存在&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="读取文件并按行分割"><a href="#读取文件并按行分割" class="headerlink" title="读取文件并按行分割"></a>读取文件并按行分割</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取文件并按行分割</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.read().splitlines()</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br></pre></td></tr></table></figure>
<h3 id="读取文件并统计行数"><a href="#读取文件并统计行数" class="headerlink" title="读取文件并统计行数"></a>读取文件并统计行数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取文件并统计行数</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    line_count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> line <span class="keyword">in</span> file)</span><br><span class="line"><span class="built_in">print</span>(line_count)</span><br></pre></td></tr></table></figure>
<h3 id="读取文件并查找特定文本"><a href="#读取文件并查找特定文本" class="headerlink" title="读取文件并查找特定文本"></a>读取文件并查找特定文本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取文件并查找特定文本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;target_text&#x27;</span> <span class="keyword">in</span> file.read():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到目标文本&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未找到目标文本&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="将文件内容转换为列表"><a href="#将文件内容转换为列表" class="headerlink" title="将文件内容转换为列表"></a>将文件内容转换为列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件内容转换为列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content_list = file.read().split()</span><br><span class="line"><span class="built_in">print</span>(content_list)</span><br></pre></td></tr></table></figure>
<h3 id="将文件内容转换为字典"><a href="#将文件内容转换为字典" class="headerlink" title="将文件内容转换为字典"></a>将文件内容转换为字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件内容转换为字典</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content_dict = <span class="built_in">dict</span>(line.split() <span class="keyword">for</span> line <span class="keyword">in</span> file)</span><br><span class="line"><span class="built_in">print</span>(content_dict)</span><br></pre></td></tr></table></figure>
<h3 id="写入多行内容到文件"><a href="#写入多行内容到文件" class="headerlink" title="写入多行内容到文件"></a>写入多行内容到文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入多行内容到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;Line 1</span></span><br><span class="line"><span class="string">Line 2</span></span><br><span class="line"><span class="string">Line 3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用pathlib模块复制文件"><a href="#使用pathlib模块复制文件" class="headerlink" title="使用pathlib模块复制文件"></a>使用pathlib模块复制文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用pathlib模块复制文件</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">source = Path(<span class="string">&#x27;example.txt&#x27;</span>)</span><br><span class="line">destination = Path(<span class="string">&#x27;copy.txt&#x27;</span>)</span><br><span class="line">source.replace(destination)</span><br></pre></td></tr></table></figure>
<h3 id="使用pathlib模块创建和删除文件夹"><a href="#使用pathlib模块创建和删除文件夹" class="headerlink" title="使用pathlib模块创建和删除文件夹"></a>使用pathlib模块创建和删除文件夹</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用pathlib模块创建和删除文件夹</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">new_folder = Path(<span class="string">&#x27;new_folder&#x27;</span>)</span><br><span class="line">new_folder.mkdir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件夹</span></span><br><span class="line">new_folder.rmdir()</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/360807803"># 基础 | 彻底搞懂Python异常处理：try-except-else-finally</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/sunshine-blog/p/12886667.html">python中try/except/else/finally的用法 - 小嘉欣 - 博客园</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/-wenli/p/13398130.html">Python断言及常用断言函数总结 - -零 - 博客园</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/464283737">Python open和with open的区别</a></p>
</li>
<li><p><a href="https://www.runoob.com/python3/python3-file-methods.html">https://www.runoob.com/python3/python3-file-methods.html</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/YsPbZHd-g5oAkwVaFj57DA">https://mp.weixin.qq.com/s/YsPbZHd-g5oAkwVaFj57DA</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件处理</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-Namespaces Scope</title>
    <url>/2024/08/03/Python%20Relearning-Namespaces%20Scope/</url>
    <content><![CDATA[<h1 id="命名空间-Namespace"><a href="#命名空间-Namespace" class="headerlink" title="命名空间(Namespace)"></a>命名空间(Namespace)</h1><p>命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p>
<p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一般有三种命名空间：</p>
<ul>
<li><strong>内置名称（built-in names</strong>）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li>
<li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li>
<li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li>
</ul>
<h2 id="查找顺序"><a href="#查找顺序" class="headerlink" title="查找顺序:"></a>查找顺序:</h2><p>假设我们要使用变量 runoob，则 Python 的查找顺序为：<strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p>
<p>如果找不到变量，它将放弃查找并引发一个 NameError 异常:</p>
<h2 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h2><p>命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所有函数外部，变量var的值是：\n&#x27;</span>,var)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">out_fun</span>():</span><br><span class="line">    <span class="comment"># 在out_fun内部，in_fun外部定义变量</span></span><br><span class="line">    var=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;out_fun内部，in_fun外部,变量var的值是：\n&quot;</span>,var)</span><br><span class="line">    <span class="comment"># 内部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_fun</span>():</span><br><span class="line">        var=<span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in_fun内部,变量var的值是：\n&quot;</span>, var)</span><br><span class="line">    <span class="comment"># 内部函数实现</span></span><br><span class="line">    in_fun()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(var)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外部函数实现</span></span><br><span class="line">out_fun()</span><br><span class="line"><span class="comment"># 依次输出0,1和 2</span></span><br></pre></td></tr></table></figure>
<h1 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h1><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p>
<p>在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</p>
<p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p>
<h2 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h2><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是：</p>
<p>有四种作用域：</p>
<ul>
<li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li>
<li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li>
<li><strong>B（Built-in）</strong>： 包含了内建的变量/关键字等，最后被搜索。</li>
</ul>
<p>规则顺序： <strong>L –&gt; E –&gt; G –&gt; B</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g_count = <span class="number">0</span>  <span class="comment"># 全局作用域</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    o_count = <span class="number">1</span>  <span class="comment"># 闭包函数外的函数中</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        i_count = <span class="number">2</span>  <span class="comment"># 局部作用域</span></span><br></pre></td></tr></table></figure>
<p>Python 中只有模块（<code>module</code>），类（<code>class</code>）以及函数（<code>def</code>、<code>lambda</code>）才会引入新的作用域，其它的代码块（如<code>if/elif/else</code>、<code>try/except</code>、<code>for/while</code>等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span> msg = <span class="string">&#x27;I am from Runoob&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">&#x27;I am from Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。</p>
<p>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>    msg_inner = <span class="string">&#x27;I am from Runoob&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;msg_inner&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p>
<h3 id="global和nonlocal关键字"><a href="#global和nonlocal关键字" class="headerlink" title="global和nonlocal关键字"></a>global和nonlocal关键字</h3><h4 id="为什么要用global和nonlocal关键字"><a href="#为什么要用global和nonlocal关键字" class="headerlink" title="为什么要用global和nonlocal关键字"></a>为什么要用global和nonlocal关键字</h4><p>当内部作用域想修改外部作用域的变量时，会出现下面的报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义出错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">out_fun</span>():</span><br><span class="line">    <span class="comment"># 在out_fun内部，in_fun外部定义变量</span></span><br><span class="line">    var=<span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内部函数执行【前】,变量var的值是：\n&quot;</span>,var)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 内部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_fun</span>():</span><br><span class="line">        var+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in_fun内部,变量var的值是：\n&quot;</span>, var)</span><br><span class="line">    <span class="comment"># 内部函数实现</span></span><br><span class="line">    in_fun()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内部函数执行【后】,变量var的值是：\n&quot;</span>,var)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外部函数实现</span></span><br><span class="line">out_fun()</span><br><span class="line"><span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure>
<p>报错信息如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UnboundLocalError: cannot access local variable <span class="string">&#x27;var&#x27;</span> where it <span class="keyword">is</span> <span class="keyword">not</span> associated <span class="keyword">with</span> a value</span><br><span class="line">内部函数执行【前】,变量var的值是：</span><br><span class="line"> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>出错信息在<code>var+=1</code>这个语句中。</p>
<p>在Python 3中，如果在内部函数中赋值给一个变量，Python默认这个变量是局部变量，除非你明确地声明它是非局部变量（<code>nonlocal</code>）或者全局变量（<code>global</code>）。因此，当你在 <code>in_fun</code> 中执行 <code>var += 1</code> 时，<strong>Python会认为你是在尝试定义一个局部变量 <code>var</code></strong>，但是你又没有在 <code>in_fun</code> 的函数体中为其赋初值，只是尝试增加它的值，这就导致了错误。</p>
<p>这不同于直接定义<code>var=2</code>，因为<code>var=2</code>是直接重新定义，Python会认为<code>var</code>是一个新的、<code>in_fun</code>内部的局部变量。但是如果写成<code>var+=1</code>，Python会寻找<code>var</code>等于几，但是找不到，因为没有声明过。</p>
<p>为了解决这个问题，可以用<code>nonlocal</code>关键字。</p>
<h4 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nonlocal</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">out_fun</span>():</span><br><span class="line">    <span class="comment"># 在out_fun内部，in_fun外部定义变量</span></span><br><span class="line">    var=<span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内部函数执行【前】,变量var的值是：\n&quot;</span>,var)</span><br><span class="line">    <span class="comment"># 内部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_fun</span>():</span><br><span class="line">        <span class="comment">#  告诉Python var是外部函数的局部变量</span></span><br><span class="line">        <span class="keyword">nonlocal</span> var</span><br><span class="line">        var+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;使用了nonlocal关键字声明后，in_fun内部,变量var的值是：\n&quot;</span>, var)</span><br><span class="line">        <span class="comment"># 输出1</span></span><br><span class="line">    <span class="comment"># 内部函数实现</span></span><br><span class="line">    in_fun()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内部函数执行【后】,变量var的值是：\n&quot;</span>,var)  <span class="comment"># var此时为1，因为内部函数修改过了</span></span><br><span class="line">    <span class="comment"># 输出0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 外部函数实现</span></span><br><span class="line">out_fun()</span><br><span class="line"><span class="comment"># 依次输出0，1，1</span></span><br></pre></td></tr></table></figure>
<p>但是，在out_fun()外部使用下列语句会出错:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面的print语句会报错</span></span><br><span class="line"><span class="built_in">print</span>(var)</span><br></pre></td></tr></table></figure>
<p>因为<code>var</code>是定义在<code>out_fun</code>内的局部变量，虽然在<code>in_fun</code>中声明，但是并不能在外部访问。</p>
<h4 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h4><p>  除此之外，我们还可以用global关键字，实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># global关键字</span></span><br><span class="line">var_a=<span class="number">1</span></span><br><span class="line">var_b=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">out_fun</span>():</span><br><span class="line">    <span class="comment"># 访问全局变量需要声明</span></span><br><span class="line">    <span class="keyword">global</span> var_a</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;外部函数访问全局变量var_a,结果是：&quot;</span>,var_a)</span><br><span class="line">    var_a+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;外部函数修改全局变量var_a,结果是：&quot;</span>,var_a)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_fun</span>():</span><br><span class="line">        <span class="comment"># 访问全局变量需要声明</span></span><br><span class="line">        <span class="keyword">global</span> var_b</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内部函数访问全局变量var_b,结果是：&quot;</span>, var_b)</span><br><span class="line">        var_b += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内部函数修改全局变量var_b,结果是：&quot;</span>, var_b)</span><br><span class="line"></span><br><span class="line">    in_fun()</span><br><span class="line"></span><br><span class="line">out_fun()</span><br><span class="line"><span class="comment"># 依次输出1,2,2,3</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果我们直接在<code>out_fun</code> 内部，<code>in_fun</code>外部定义了<code>var_b</code>（而不是在<code>out_fun</code>函数外部），此时在<code>in_fun()</code>函数里面声明<code>global var_b</code>，会出错，因为<mark><code>global</code>声明的变量类型必须是在函数外面的全局变量。</mark></p>
<p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">out_fun</span>():</span><br><span class="line">    var_b = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 访问全局变量需要声明</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_fun</span>():</span><br><span class="line">        <span class="comment"># 访问全局变量需要声明</span></span><br><span class="line">        <span class="keyword">global</span> var_b</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内部函数访问全局变量var_b,结果是：&quot;</span>, var_b)</span><br><span class="line">        var_b += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内部函数修改全局变量var_b,结果是：&quot;</span>, var_b)</span><br><span class="line"></span><br><span class="line">    in_fun()</span><br><span class="line"></span><br><span class="line">out_fun()</span><br><span class="line"><span class="comment"># 依次输出1,2,2,3</span></span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  File <span class="string">&quot;E:\codes\Python\python_relearning\namespace.py&quot;</span>, line <span class="number">84</span>, <span class="keyword">in</span> in_fun</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内部函数访问全局变量var_b,结果是：&quot;</span>, var_b)</span><br><span class="line">                                  ^^^^^</span><br><span class="line">NameError: name <span class="string">&#x27;var_b&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined. Did you mean: <span class="string">&#x27;vars&#x27;</span>?</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://www.runoob.com/python3/python3-namespace-scope.html">Python3 命名空间和作用域 | 菜鸟教程</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>namespace</tag>
        <tag>Scope</tag>
        <tag>命名空间</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-Numpy</title>
    <url>/2024/08/10/Python%20Relearning-Numpy/</url>
    <content><![CDATA[<h1 id="列表转化为numpy数组"><a href="#列表转化为numpy数组" class="headerlink" title="列表转化为numpy数组"></a>列表转化为numpy数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np1=np.array(lst)</span><br></pre></td></tr></table></figure>
<h1 id="获取数组的shape、dim、dtype等信息"><a href="#获取数组的shape、dim、dtype等信息" class="headerlink" title="获取数组的shape、dim、dtype等信息"></a>获取数组的shape、dim、dtype等信息</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np1.shape)</span><br><span class="line"><span class="built_in">print</span>(np1.ndim)</span><br><span class="line"><span class="built_in">print</span>(np1.dtype)</span><br></pre></td></tr></table></figure>
<h1 id="创建全为0的数组"><a href="#创建全为0的数组" class="headerlink" title="创建全为0的数组"></a>创建全为0的数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np2=np.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))       <span class="comment"># 传入元组</span></span><br><span class="line">np3=np.zeros_like([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])     <span class="comment"># 传入同样形状的数组</span></span><br></pre></td></tr></table></figure>
<h1 id="创建全为1的数组"><a href="#创建全为1的数组" class="headerlink" title="创建全为1的数组"></a>创建全为1的数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np4=np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))       <span class="comment"># 传入元组</span></span><br><span class="line">np5=np.ones_like([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])     <span class="comment"># 传入同样形状的数组</span></span><br></pre></td></tr></table></figure>
<h1 id="创建新的数组"><a href="#创建新的数组" class="headerlink" title="创建新的数组"></a>创建新的数组</h1><p>返回的都是一些未初始化的垃圾值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np6=np.((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))       <span class="comment"># 传入元组</span></span><br><span class="line">np7=np.ones_like([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])     <span class="comment"># 传入同样形状的数组</span></span><br></pre></td></tr></table></figure>
<h1 id="用指定数字填充一个数组"><a href="#用指定数字填充一个数组" class="headerlink" title="用指定数字填充一个数组"></a>用指定数字填充一个数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np8=np.full((<span class="number">2</span>,<span class="number">3</span>),np.inf)</span><br><span class="line">np9=np.full((<span class="number">2</span>,<span class="number">3</span>),<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h1 id="创建对角矩阵"><a href="#创建对角矩阵" class="headerlink" title="创建对角矩阵"></a>创建对角矩阵</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np10=np.eye(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>numpy.eye(N, M=None, k=0, dtype=<class 'float'>, order=’C’, *, like=None)</p>
<p>参数：</p>
<ul>
<li><p>N:行数</p>
</li>
<li><p>M：列数，默认为N</p>
</li>
<li><p>k:对角线的索引，0为主对角线，正数为高对角线，负数为低对角线</p>
</li>
</ul>
<h1 id="数组和标量的运算"><a href="#数组和标量的运算" class="headerlink" title="数组和标量的运算"></a>数组和标量的运算</h1><blockquote>
<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 下列运算都会传播到各个元素</span></span><br><span class="line">arr1=<span class="number">1</span>/arr</span><br><span class="line">arr2=arr*<span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<h1 id="大小相等数组的运算"><a href="#大小相等数组的运算" class="headerlink" title="大小相等数组的运算"></a>大小相等数组的运算</h1><blockquote>
<p>大小相等的数组之间的<strong>任何</strong>算术运算都会将运算应用到元素级</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 下列运算都会传播到各个元素</span></span><br><span class="line">arr1=arr*arr</span><br><span class="line">arr2=arr+arr</span><br></pre></td></tr></table></figure>
<h1 id="大小相同的数组之间的比较会生成布尔值数组"><a href="#大小相同的数组之间的比较会生成布尔值数组" class="headerlink" title="大小相同的数组之间的比较会生成布尔值数组"></a>大小相同的数组之间的比较会生成布尔值数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1=np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">arr2=np.zeros_like(arr1)</span><br><span class="line"><span class="comment"># arr3的元素都是True</span></span><br><span class="line">arr3=arr1&gt;arr2</span><br></pre></td></tr></table></figure>
<h1 id="数组的索引和切片"><a href="#数组的索引和切片" class="headerlink" title="数组的索引和切片"></a>数组的索引和切片</h1><p>与列表索引无异。</p>
<p>但是跟列表最重要的区别在于，数组切片是原始数组的视图。这意味<br>着**数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<h2 id="1xN-的数组"><a href="#1xN-的数组" class="headerlink" title="1xN 的数组"></a>1xN 的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 索引</span></span><br><span class="line">t = arr[<span class="number">5</span>]</span><br><span class="line">arr1=arr[<span class="number">3</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h2 id="NxN的数组"><a href="#NxN的数组" class="headerlink" title="NxN的数组"></a>NxN的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引1</span></span><br><span class="line">arr1=arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 索引2(与索引1等价)</span></span><br><span class="line">arr1=arr[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 切片一(注意看，消失了一个轴)</span></span><br><span class="line">arr2=arr[<span class="number">1</span>,:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片赋值</span></span><br><span class="line">arr[:,:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[[1. 2. 2. 1.]</span></span><br><span class="line"><span class="string">  [1. 2. 2. 1.]</span></span><br><span class="line"><span class="string">  [1. 1. 1. 1.]]  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[1. 2. 2. 1.]</span></span><br><span class="line"><span class="string">  [1. 2. 2. 1.]</span></span><br><span class="line"><span class="string">  [1. 1. 1. 1.]]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr = np.array([<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;A&quot;</span>])</span><br><span class="line">&gt;&gt;&gt;arr==<span class="string">&quot;A&quot;</span></span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>
<p>布尔型索引可以应用到其他数组中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;data=np.random.randn(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;data[arr==<span class="string">&quot;A&quot;</span>]</span><br><span class="line">array([[ <span class="number">0.56404125</span>,  <span class="number">0.16307987</span>, -<span class="number">0.58351001</span>],</span><br><span class="line">       [ <span class="number">1.21981151</span>, -<span class="number">2.82375807</span>,  <span class="number">0.95452604</span>]])  </span><br><span class="line">&gt;&gt;&gt;data[arr==<span class="string">&quot;A&quot;</span>,<span class="number">2</span>]</span><br><span class="line">array([-<span class="number">0.58351001</span>,  <span class="number">0.95452604</span>])</span><br><span class="line">&gt;&gt;&gt;data[arr!=<span class="string">&quot;A&quot;</span>]</span><br><span class="line">array([[-<span class="number">0.48488901</span>, -<span class="number">0.03173889</span>,  <span class="number">1.36615544</span>],</span><br><span class="line">       [-<span class="number">0.1890298</span> , -<span class="number">1.5357594</span> , -<span class="number">1.28240933</span>],</span><br><span class="line">       [-<span class="number">1.05119813</span>,  <span class="number">0.1259434</span> , -<span class="number">0.56340036</span>]])  </span><br><span class="line">&gt;&gt;&gt;data[~(arr==<span class="string">&quot;A&quot;</span>)]</span><br><span class="line">array([[-<span class="number">0.48488901</span>, -<span class="number">0.03173889</span>,  <span class="number">1.36615544</span>],</span><br><span class="line">       [-<span class="number">0.1890298</span> , -<span class="number">1.5357594</span> , -<span class="number">1.28240933</span>],</span><br><span class="line">       [-<span class="number">1.05119813</span>,  <span class="number">0.1259434</span> , -<span class="number">0.56340036</span>]])</span><br></pre></td></tr></table></figure>
<p>此外，还有大于小于，多个布尔型索引可以用与或非等操作，此处不列举。</p>
<h2 id="花式索引-特定顺序切片"><a href="#花式索引-特定顺序切片" class="headerlink" title="(花式索引)特定顺序切片"></a>(花式索引)特定顺序切片</h2><p>索引传入的时候只需要指定一个列表或者numpy数组就可以了。</p>
<p>使用<strong>负数索引</strong>将会从末尾开始选取行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr=np.empty((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    arr[i]=i  </span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;arr[[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>]]   <span class="comment"># 只需要传入一个列表或者np数组</span></span><br><span class="line">array([[<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<p>一次传入多个数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line">&gt;&gt;&gt;arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">array([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p>牢记两点</p>
<blockquote>
<ul>
<li><p>不管传入几个数组，花式索引<strong>最后一定返回一维数组</strong></p>
</li>
<li><p>多个数组传入的时候，如上例，选取的是arr[1,0]=4,arr[5,3]=23,arr[7,1]=29,arr[2,2]=10作为一维数组的元素。</p>
</li>
</ul>
</blockquote>
<h2 id="浅拷贝机制"><a href="#浅拷贝机制" class="headerlink" title="浅拷贝机制"></a>浅拷贝机制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1=np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">arr2=arr1[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">arr2=<span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(arr1) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr3=arr1[<span class="number">1</span>,:<span class="number">2</span>]</span><br><span class="line">arr3[<span class="number">1</span>]=<span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(arr1) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">会显示</span></span><br><span class="line"><span class="string">[[1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 9. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="重塑和转置"><a href="#重塑和转置" class="headerlink" title="重塑和转置"></a>重塑和转置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x=np.arange(<span class="number">24</span>).reshape(<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;x</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">       [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]])  </span><br><span class="line">&gt;&gt;&gt;x.T</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">7</span>, <span class="number">13</span>, <span class="number">19</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">8</span>, <span class="number">14</span>, <span class="number">20</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">9</span>, <span class="number">15</span>, <span class="number">21</span>],</span><br><span class="line">       [ <span class="number">4</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">23</span>]])</span><br></pre></td></tr></table></figure>
<h1 id="transpose-方法和swapaxes方法"><a href="#transpose-方法和swapaxes方法" class="headerlink" title="transpose()方法和swapaxes方法"></a>transpose()方法和swapaxes方法</h1><p>用于交换轴  ，详见</p>
<p><a href="https://blog.csdn.net/u012762410/article/details/78912667">Python numpy.transpose 详解_numpy transpose-CSDN博客</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h1><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。</p>
<h2 id="单个数组"><a href="#单个数组" class="headerlink" title="单个数组"></a>单个数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x=np.arange(<span class="number">12</span>)</span><br><span class="line">&gt;&gt;&gt;x.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">&gt;&gt;&gt;np.exp(x)</span><br><span class="line">array([<span class="number">1.00000000e+00</span>, <span class="number">2.71828183e+00</span>, <span class="number">7.38905610e+00</span>, <span class="number">2.00855369e+01</span>,</span><br><span class="line">       <span class="number">5.45981500e+01</span>, <span class="number">1.48413159e+02</span>, <span class="number">4.03428793e+02</span>, <span class="number">1.09663316e+03</span>,</span><br><span class="line">       <span class="number">2.98095799e+03</span>, <span class="number">8.10308393e+03</span>, <span class="number">2.20264658e+04</span>, <span class="number">5.98741417e+04</span>])</span><br><span class="line">&gt;&gt;&gt;np.sqrt(x)</span><br><span class="line">array([<span class="number">0.</span>        , <span class="number">1.</span>        , <span class="number">1.41421356</span>, <span class="number">1.73205081</span>, <span class="number">2.</span>        ,</span><br><span class="line">       <span class="number">2.23606798</span>, <span class="number">2.44948974</span>, <span class="number">2.64575131</span>, <span class="number">2.82842712</span>, <span class="number">3.</span>        ,</span><br><span class="line">       <span class="number">3.16227766</span>, <span class="number">3.31662479</span>])</span><br><span class="line">&gt;&gt;&gt;np.square(x)</span><br><span class="line">array([  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">4</span>,   <span class="number">9</span>,  <span class="number">16</span>,  <span class="number">25</span>,  <span class="number">36</span>,  <span class="number">49</span>,  <span class="number">64</span>,  <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>])</span><br></pre></td></tr></table></figure>
<h2 id="多个数组"><a href="#多个数组" class="headerlink" title="多个数组"></a>多个数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x=np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;y=np.arange(<span class="number">6</span>,<span class="number">0</span>,-<span class="number">1</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;np.maximum(x,y)  <span class="comment"># 两个数组对应元素的最大值</span></span><br><span class="line">array([[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">&gt;&gt;&gt;np.minimum(x,y) <span class="comment"># 两个数组对应元素的最小值</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">&gt;&gt;&gt;np.add(x,y)  <span class="comment"># 两个数组对应元素相加</span></span><br><span class="line">array([[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="返回多个数组"><a href="#返回多个数组" class="headerlink" title="返回多个数组"></a>返回多个数组</h2><p>modf是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x=np.random.randn(<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&gt;&gt;&gt;x</span><br><span class="line">array([[-<span class="number">2.3970355</span> ,  <span class="number">0.77791357</span>, -<span class="number">0.77376582</span>],</span><br><span class="line">       [ <span class="number">0.42437037</span>,  <span class="number">1.79161465</span>, -<span class="number">0.20365944</span>]])</span><br><span class="line">&gt;&gt;&gt;remainder, whole_part = np.modf(x)</span><br><span class="line">&gt;&gt;&gt;remainder</span><br><span class="line">array([[-<span class="number">0.3970355</span> ,  <span class="number">0.77791357</span>, -<span class="number">0.77376582</span>],</span><br><span class="line">       [ <span class="number">0.42437037</span>,  <span class="number">0.79161465</span>, -<span class="number">0.20365944</span>]])</span><br><span class="line">&gt;&gt;&gt;whole_part</span><br><span class="line">array([[-<span class="number">2.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>, -<span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<p>一元和二元ufunf列表</p>


<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="矢量化方法——网格处理"><a href="#矢量化方法——网格处理" class="headerlink" title="矢量化方法——网格处理"></a>矢量化方法——网格处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运用向量化方法创建网格</span></span><br><span class="line">points=np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">xs, ys = np.meshgrid(points, points)</span><br><span class="line">z=np.sqrt(xs**<span class="number">2</span>+ys**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line">plt.title(<span class="string">&quot;Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">如</span><br></pre></td></tr></table></figure>
<p>如下图所示</p>

<h1 id="矢量化方法——np-where"><a href="#矢量化方法——np-where" class="headerlink" title="矢量化方法——np.where"></a>矢量化方法——np.where</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line">&gt;&gt;&gt;yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line">&gt;&gt;&gt;cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则取yarr的值。列表推导式的写法应该如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y) <span class="keyword">for</span> x, y, c <span class="keyword">in</span> <span class="built_in">zip</span>(xarr, yarr, cond)]</span><br></pre></td></tr></table></figure>
<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = np.where(cond, xarr, yarr)</span><br></pre></td></tr></table></figure>
<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, -<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>又例:用常数2替换arr中所有正的值,负值和0不变。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr)</span><br></pre></td></tr></table></figure>
<p>传递给where的数组大小可以不相等，<strong>甚至可以是标量值</strong>。</p>
<h1 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h1><h2 id="均值、按轴的均值"><a href="#均值、按轴的均值" class="headerlink" title="均值、按轴的均值"></a>均值、按轴的均值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">&gt;&gt;&gt;arr=np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([[-<span class="number">0.58020959</span>, -<span class="number">0.39792925</span>,  <span class="number">0.81460853</span>,  <span class="number">1.82152127</span>],</span><br><span class="line">       [-<span class="number">0.46293236</span>,  <span class="number">0.78065611</span>, -<span class="number">0.81467171</span>, -<span class="number">1.09035582</span>],</span><br><span class="line">       [ <span class="number">1.06016137</span>,  <span class="number">0.24888008</span>, -<span class="number">0.04443127</span>,  <span class="number">0.13277996</span>]])</span><br><span class="line">&gt;&gt;&gt;arr.mean()</span><br><span class="line">np.float64(<span class="number">0.12233977548552276</span>)</span><br><span class="line">&gt;&gt;&gt;np.mean(arr)</span><br><span class="line">np.float64(<span class="number">0.12233977548552276</span>)</span><br><span class="line">&gt;&gt;&gt;arr.mean(axis=<span class="number">1</span>)</span><br><span class="line">array([ <span class="number">0.41449774</span>, -<span class="number">0.39682595</span>,  <span class="number">0.34934753</span>])  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="求和、按轴的求和"><a href="#求和、按轴的求和" class="headerlink" title="求和、按轴的求和"></a>求和、按轴的求和</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr=np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([[-<span class="number">0.58020959</span>, -<span class="number">0.39792925</span>,  <span class="number">0.81460853</span>,  <span class="number">1.82152127</span>],</span><br><span class="line">       [-<span class="number">0.46293236</span>,  <span class="number">0.78065611</span>, -<span class="number">0.81467171</span>, -<span class="number">1.09035582</span>],</span><br><span class="line">       [ <span class="number">1.06016137</span>,  <span class="number">0.24888008</span>, -<span class="number">0.04443127</span>,  <span class="number">0.13277996</span>]])</span><br><span class="line">&gt;&gt;&gt;np.<span class="built_in">sum</span>(arr)</span><br><span class="line">np.float64(<span class="number">1.468077305826273</span>)</span><br><span class="line">&gt;&gt;&gt;arr.<span class="built_in">sum</span>()</span><br><span class="line">np.float64(<span class="number">1.468077305826273</span>)</span><br><span class="line">&gt;&gt;&gt;arr.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">array([ <span class="number">1.65799095</span>, -<span class="number">1.58730378</span>,  <span class="number">1.39739014</span>])</span><br></pre></td></tr></table></figure>
<h2 id="累加函数-cumsum"><a href="#累加函数-cumsum" class="headerlink" title="累加函数(cumsum)"></a>累加函数(cumsum)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr=np.arange(<span class="number">10</span>)</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">&gt;&gt;&gt;arr.cumsum()</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>])  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照不同的轴累加</span></span><br><span class="line">&gt;&gt;&gt;arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">&gt;&gt;&gt;arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]])</span><br><span class="line">&gt;&gt;&gt;arr.cumsum(axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">6</span>, <span class="number">13</span>, <span class="number">21</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h1><p> 在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔数组中的true值计数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;(arr &gt; <span class="number">0</span>).<span class="built_in">sum</span>()</span><br><span class="line">np.int64(<span class="number">45</span>)</span><br></pre></td></tr></table></figure>
<p>any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line">&gt;&gt;&gt;bools.<span class="built_in">any</span>()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;bools.<span class="built_in">all</span>()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>用sort方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([-<span class="number">0.51546731</span>, -<span class="number">0.69672017</span>, -<span class="number">0.07422335</span>, -<span class="number">0.37264409</span>,  <span class="number">1.24829952</span>,</span><br><span class="line">       -<span class="number">0.16309924</span>])</span><br><span class="line">&gt;&gt;&gt;arr.sort()</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([-<span class="number">0.69672017</span>, -<span class="number">0.51546731</span>, -<span class="number">0.37264409</span>, -<span class="number">0.16309924</span>, -<span class="number">0.07422335</span>,</span><br><span class="line">        <span class="number">1.24829952</span>])</span><br></pre></td></tr></table></figure>
<h2 id="指定轴的排序"><a href="#指定轴的排序" class="headerlink" title="指定轴的排序"></a>指定轴的排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr=np.random.randn(<span class="number">12</span>).reshape((<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([[-<span class="number">0.25665726</span>,  <span class="number">0.53730452</span>, -<span class="number">1.08962298</span>,  <span class="number">0.39218402</span>,  <span class="number">0.24570309</span>,</span><br><span class="line">         <span class="number">1.3190456</span> ],</span><br><span class="line">       [ <span class="number">0.19662659</span>,  <span class="number">0.02097503</span>,  <span class="number">0.29628246</span>,  <span class="number">0.4907919</span> ,  <span class="number">1.78748713</span>,</span><br><span class="line">         <span class="number">0.43255797</span>]])</span><br><span class="line">&gt;&gt;&gt;arr.sort(axis=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;arr</span><br><span class="line">array([[-<span class="number">0.25665726</span>,  <span class="number">0.02097503</span>, -<span class="number">1.08962298</span>,  <span class="number">0.39218402</span>,  <span class="number">0.24570309</span>,</span><br><span class="line">         <span class="number">0.43255797</span>],</span><br><span class="line">       [ <span class="number">0.19662659</span>,  <span class="number">0.53730452</span>,  <span class="number">0.29628246</span>,  <span class="number">0.4907919</span> ,  <span class="number">1.78748713</span>,</span><br><span class="line">         <span class="number">1.3190456</span> ]])</span><br></pre></td></tr></table></figure>
<h1 id="集合逻辑"><a href="#集合逻辑" class="headerlink" title="集合逻辑"></a>集合逻辑</h1><h2 id="将一维数组转化为集合并且排序"><a href="#将一维数组转化为集合并且排序" class="headerlink" title="将一维数组转化为集合并且排序"></a>将一维数组转化为集合并且排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line">&gt;&gt;&gt;np.unique(names)</span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>], dtype=<span class="string">&#x27;&lt;U4)  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt;arr=np.array([1,3,2,6,4,7,0,1,4])</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;np.sort(arr)</span></span><br><span class="line"><span class="string">array([0, 1, 1, 2, 3, 4, 4, 6, 7])</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;np.unique(arr)</span></span><br><span class="line"><span class="string">array([0, 1, 2, 3, 4, 6, 7])</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h1 id="数组文件格式-npy"><a href="#数组文件格式-npy" class="headerlink" title="数组文件格式(.npy)"></a>数组文件格式(.npy)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.random.randn(<span class="number">144</span>).reshape((<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arr:&#x27;</span>,arr)</span><br><span class="line">np.save(<span class="string">&quot;12x12_ndarry&quot;</span>,arr)  <span class="comment"># 如果不加.npy，也可以</span></span><br><span class="line"></span><br><span class="line">arr1=np.load(<span class="string">&#x27;12x12_ndarry.npy&#x27;</span>)   <span class="comment"># 必须加.npy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arr1:&#x27;</span>,arr1)</span><br></pre></td></tr></table></figure>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="矩阵点乘"><a href="#矩阵点乘" class="headerlink" title="矩阵点乘"></a>矩阵点乘</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr1=np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>,<span class="number">3</span>))</span><br><span class="line">&gt;&gt;&gt;arr2=np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&gt;&gt;&gt;arr3=arr1.dot(arr2)</span><br><span class="line">&gt;&gt;&gt;arr3</span><br><span class="line">array([[ <span class="number">20</span>,  <span class="number">23</span>,  <span class="number">26</span>,  <span class="number">29</span>],</span><br><span class="line">       [ <span class="number">56</span>,  <span class="number">68</span>,  <span class="number">80</span>,  <span class="number">92</span>],</span><br><span class="line">       [ <span class="number">92</span>, <span class="number">113</span>, <span class="number">134</span>, <span class="number">155</span>],</span><br><span class="line">       [<span class="number">128</span>, <span class="number">158</span>, <span class="number">188</span>, <span class="number">218</span>]])</span><br><span class="line">&gt;&gt;&gt;arr4=np.dot(arr1,arr2)</span><br><span class="line">&gt;&gt;&gt;arr4</span><br><span class="line">array([[ <span class="number">20</span>,  <span class="number">23</span>,  <span class="number">26</span>,  <span class="number">29</span>],</span><br><span class="line">       [ <span class="number">56</span>,  <span class="number">68</span>,  <span class="number">80</span>,  <span class="number">92</span>],</span><br><span class="line">       [ <span class="number">92</span>, <span class="number">113</span>, <span class="number">134</span>, <span class="number">155</span>],</span><br><span class="line">       [<span class="number">128</span>, <span class="number">158</span>, <span class="number">188</span>, <span class="number">218</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="矩阵求逆和QR值分解"><a href="#矩阵求逆和QR值分解" class="headerlink" title="矩阵求逆和QR值分解"></a>矩阵求逆和QR值分解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line">&gt;&gt;&gt;a=np.random.randn(<span class="number">16</span>).reshape((<span class="number">4</span>,<span class="number">4</span>))  </span><br><span class="line">&gt;&gt;&gt;mat=np.dot(a,a.T)</span><br><span class="line">&gt;&gt;&gt;inv(mat)</span><br><span class="line">array([[ <span class="number">1.31306504</span>,  <span class="number">0.45533194</span>, -<span class="number">1.06419011</span>, -<span class="number">0.9930272</span> ],</span><br><span class="line">       [ <span class="number">0.45533194</span>,  <span class="number">0.8722488</span> , -<span class="number">1.18740211</span>, -<span class="number">0.78019301</span>],</span><br><span class="line">       [-<span class="number">1.06419011</span>, -<span class="number">1.18740211</span>,  <span class="number">1.9869764</span> ,  <span class="number">1.32427395</span>],</span><br><span class="line">       [-<span class="number">0.9930272</span> , -<span class="number">0.78019301</span>,  <span class="number">1.32427395</span>,  <span class="number">1.22621826</span>]])  </span><br><span class="line">&gt;&gt;&gt;q, r = qr(mat)</span><br><span class="line">&gt;&gt;&gt;qr(mat)</span><br><span class="line">QRResult(Q=array([[-<span class="number">0.56344147</span>,  <span class="number">0.52661645</span>, -<span class="number">0.44941887</span>, -<span class="number">0.45081205</span>],</span><br><span class="line">       [-<span class="number">0.59497181</span>, -<span class="number">0.60717158</span>,  <span class="number">0.38974426</span>, -<span class="number">0.35419011</span>],</span><br><span class="line">       [-<span class="number">0.36011218</span>, -<span class="number">0.38380937</span>, -<span class="number">0.60131472</span>,  <span class="number">0.60119064</span>],</span><br><span class="line">       [-<span class="number">0.44593886</span>,  <span class="number">0.45465168</span>,  <span class="number">0.53342544</span>,  <span class="number">0.55667556</span>]]), R=array([[ -<span class="number">5.41454513</span>, -<span class="number">10.66799837</span>,  -<span class="number">6.30814318</span>,  -<span class="number">4.72356165</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,  -<span class="number">5.29662706</span>,  -<span class="number">4.8512473</span> ,   <span class="number">2.23992805</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,   <span class="number">0.</span>        ,  -<span class="number">2.1145548</span> ,   <span class="number">2.71866387</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,   <span class="number">0.</span>        ,   <span class="number">0.</span>        ,   <span class="number">0.45397755</span>]]))</span><br></pre></td></tr></table></figure>

<h1 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h1><h2 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">&gt;&gt;&gt;samples</span><br><span class="line">array([[-<span class="number">0.57442398</span>, -<span class="number">0.850833</span>  , -<span class="number">0.21796463</span>, -<span class="number">1.56780153</span>],</span><br><span class="line">       [ <span class="number">1.60345098</span>,  <span class="number">0.11634615</span>, -<span class="number">0.85471129</span>, -<span class="number">1.45385702</span>],</span><br><span class="line">       [-<span class="number">0.66995946</span>, -<span class="number">0.2998366</span> , -<span class="number">1.94560696</span>,  <span class="number">0.19645426</span>],</span><br><span class="line">       [-<span class="number">1.01776318</span>, -<span class="number">0.37687205</span>,  <span class="number">1.54454201</span>,  <span class="number">0.69070131</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="设置种子产生随机数"><a href="#设置种子产生随机数" class="headerlink" title="设置种子产生随机数"></a>设置种子产生随机数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;种子为0，random产生的随机数:&#x27;</span>,random.random())</span><br><span class="line"><span class="comment"># 0.8444218515250481</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;种子为0，np产生的随机数:&#x27;</span>,np.random.rand())</span><br><span class="line"><span class="comment"># 0.5488135039273248</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;种子为0，np产生的随机数:&#x27;</span>,np.random.rand())</span><br><span class="line"><span class="comment"># 0.5488135039273248</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;种子为1000，np产生的随机数:&#x27;</span>,np.random.rand())</span><br><span class="line"><span class="comment"># 0.6535895854646095</span></span><br></pre></td></tr></table></figure>


<h1 id="随机漫步"><a href="#随机漫步" class="headerlink" title="随机漫步"></a>随机漫步</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">position = <span class="number">0</span></span><br><span class="line">walk = [position]</span><br><span class="line">steps = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">    step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    position += step</span><br><span class="line">    walk.append(position)</span><br><span class="line"></span><br><span class="line">plt.plot(walk[:<span class="number">1000</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
 
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Relearning-datetime</title>
    <url>/2024/08/03/Python%20Relearning-datetime/</url>
    <content><![CDATA[<h1 id="日期和时间的格式化符号"><a href="#日期和时间的格式化符号" class="headerlink" title="日期和时间的格式化符号"></a>日期和时间的格式化符号</h1><p>如下表：</p>


<p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a>, <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 对象都支持 <code>strftime(format)</code> 方法，可用来创建由一个显式格式字符串所控制的表示时间的字符串。</p>
<p>相反地，<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime.strptime" title="datetime.datetime.strptime"><code>datetime.strptime()</code></a> 类会根据表示日期和时间的字符串和相应的格式字符串来创建一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a> 对象。</p>
<h1 id="strftime-与-strptime-的高层级比较："><a href="#strftime-与-strptime-的高层级比较：" class="headerlink" title="strftime()与 strptime() 的高层级比较："></a>strftime()与 strptime() 的高层级比较：</h1><p>下表提供了 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime.strftime" title="datetime.datetime.strftime"><code>strftime()</code></a> 与 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime.strptime" title="datetime.datetime.strptime"><code>strptime()</code></a> 的高层级比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>strftime</code></th>
<th><code>strptime</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>用法</td>
<td>根据给定的格式将对象转换为字符串</td>
<td>将字符串解析为给定相应格式的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a> 对象</td>
</tr>
<tr>
<td>方法类型</td>
<td>实例方法</td>
<td>类方法</td>
</tr>
<tr>
<td>方法</td>
<td><a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a>; <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a>; <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a></td>
<td><a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a></td>
</tr>
<tr>
<td>签名</td>
<td><code>strftime(format)</code></td>
<td><code>strptime(date_string, format)</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="datetime-timedelta对象"><a href="#datetime-timedelta对象" class="headerlink" title="datetime.timedelta对象"></a>datetime.timedelta对象</h1><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code>timedelta</code></a> 对象表示一段持续的时间，即两个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a> 实例之间的差值。</p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p><code>mydelta=datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</code></p>
<p>所有参数都是可选的并且默认为 0。 这些参数可以是整数或者浮点数，并可以为正值或者负值。</p>
<p>只有 <em>days</em>, <em>seconds</em> 和 <em>microseconds</em> 会存储在内部。 参数单位的换算规则如下</p>
<ul>
<li><p>1毫秒会转换成1000微秒。</p>
</li>
<li><p>1分钟会转换成60秒。</p>
</li>
<li><p>1小时会转换成3600秒。</p>
</li>
<li><p>1星期会转换成7天。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">delta = datetime.timedelta(</span><br><span class="line">    days=<span class="number">50</span>,</span><br><span class="line">    seconds=<span class="number">27</span>,</span><br><span class="line">    microseconds=<span class="number">10</span>,</span><br><span class="line">    milliseconds=<span class="number">29000</span>,</span><br><span class="line">    minutes=<span class="number">5</span>,</span><br><span class="line">    hours=<span class="number">8</span>,</span><br><span class="line">    weeks=<span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;持续时间为:&#x27;</span>,delta)</span><br><span class="line"><span class="comment"># 输出64 days, 8:05:56.000010</span></span><br></pre></td></tr></table></figure>
<p>在有任何参数为浮点型并且 microseconds 值为小数的情况下，从所有参数中余下的微秒数将被合并，并使用四舍五入偶不入奇的规则将总计值舍入到最接近的整数微秒值。 如果没有任何参数为浮点型的情况下，则转换和标准化过程将是完全精确的（不会丢失信息）。</p>
<p>如果标准化后的 days 数值超过了指定范围，将会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> 异常。</p>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><ul>
<li><p><code>datetime.timedelta.min</code></p>
<p>最小的时间间隔， -999999999 days, 0:0</p>
</li>
<li><p><code>datetime.timedelta.max</code></p>
<p>最大的时间间隔， 999999999 days, 23:59:59.999999</p>
</li>
<li><p><code>datetime.timedelta.resolution</code></p>
<p>两个不相等的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code>timedelta</code></a> 类对象最小的间隔为 <code>timedelta(microseconds=1)</code>。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mindelta=datetime.timedelta.<span class="built_in">min</span></span><br><span class="line">maxdelta=datetime.timedelta.<span class="built_in">max</span></span><br><span class="line">resolution=datetime.timedelta.resolution</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mindelta is:&#x27;</span>,mindelta)      <span class="comment"># -999999999 days, 0:00:00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;maxdelta is:&#x27;</span>,maxdelta)      <span class="comment"># 999999999 days, 23:59:59.999999</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;resolution is:&#x27;</span>,resolution)      <span class="comment"># 0:00:00.000001</span></span><br></pre></td></tr></table></figure>
<h2 id="支持数学算术运算"><a href="#支持数学算术运算" class="headerlink" title="支持数学算术运算"></a>支持数学算术运算</h2><div class="table-container">
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>t1 = t2 + t3</code></td>
<td><code>t2</code> 和 <code>t3</code> 之和。 运算后 <code>t1 - t2 == t3</code> 且 <code>t1 - t3 == t2</code> 为真值。 (1)</td>
</tr>
<tr>
<td><code>t1 = t2 - t3</code></td>
<td><code>t2</code> 和 <code>t3</code> 之差。 运算后 <code>t1 == t2 - t3</code> 且 <code>t2 == t1 + t3</code> 为真值。 (1)(6)</td>
</tr>
<tr>
<td><code>t1 = t2 * i or t1 = i * t2</code></td>
<td>时差乘以一个整数。 运算后如果 <code>i != 0</code> 则 <code>t1 // i == t2</code> 为真值。</td>
</tr>
<tr>
<td></td>
<td>通常情况下，<code>t1  * i == t1 * (i-1) + t1</code> 为真值。 (1)</td>
</tr>
<tr>
<td><code>t1 = t2 * f or t1 = f * t2</code></td>
<td>乘以一个浮点数，结果会被舍入到 timedelta 最接近的整数倍。 精度使用四舍五偶入奇不入规则。</td>
</tr>
<tr>
<td><code>f = t2 / t3</code></td>
<td>总时长 <code>t2</code> 除以间隔单位 <code>t3</code> (3)。 返回一个 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code>float</code></a> 对象。</td>
</tr>
<tr>
<td><code>t1 = t2 / f or t1 = t2 / i</code></td>
<td>除以一个浮点数或整数。 结果会被舍入到 timedelta 最接近的整数倍。 精度使用四舍五偶入奇不入规则。</td>
</tr>
<tr>
<td><code>t1 = t2 // i</code> or <code>t1 = t2 // t3</code></td>
<td>计算底数，其余部分（如果有）将被丢弃。在第二种情况下，将返回整数。 （3）</td>
</tr>
<tr>
<td><code>t1 = t2 % t3</code></td>
<td>余数为一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code>timedelta</code></a> 对象。(3)</td>
</tr>
<tr>
<td><code>q, r = divmod(t1, t2)</code></td>
<td>通过 : <code>q = t1 // t2</code> (3) and <code>r = t1 % t2</code> 计算出商和余数。q是一个整数，r是一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code>timedelta</code></a> 对象。</td>
</tr>
<tr>
<td><code>+t1</code></td>
<td>返回一个相同数值的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code>timedelta</code></a> 对象。</td>
</tr>
<tr>
<td><code>-t1</code></td>
<td>等于 <code>timedelta(-t1.days, -t1.seconds*, -t1.microseconds)</code>，以及 <code>t1 * -1</code>。 (1)(4)</td>
</tr>
<tr>
<td><code>abs(t)</code></td>
<td>当 <code>t.days &gt;= 0</code> 时等于 <code>+t</code>，而当 <code>t.days &lt; 0</code> 时等于 <code>-t</code>。 (2)</td>
</tr>
<tr>
<td><code>str(t)</code></td>
<td>返回一个形如 <code>[D day[s], ][H]H:MM:SS[.UUUUUU]</code> 的字符串，当 <code>t</code> 为负数的时候， D 也为负数。 (5)</td>
</tr>
<tr>
<td><code>repr(t)</code></td>
<td>返回一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code>timedelta</code></a> 对象的字符串表示形式，作为附带正规属性值的构造器调用。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="转化为秒数"><a href="#转化为秒数" class="headerlink" title="转化为秒数"></a>转化为秒数</h2><p><code>timedelta.total_seconds()</code></p>
<p>返回期间占用了多少秒。等价于 <code>td / timedelta(seconds=1)</code>。对于秒以外的间隔单位，直接使用除法形式 (例如 <code>td / timedelta(microseconds=1)</code>)。</p>
<p>需要注意的是，时间间隔较大时，这个方法的结果中的微秒将会失真（大多数平台上大于270年视为一个较大的时间间隔）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_seconds=delta.total_seconds()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The total_seconds of delta is :&#x27;</span>,total_seconds)</span><br><span class="line"><span class="comment"># 5558756.00001</span></span><br></pre></td></tr></table></figure>
<h1 id="datetime-date对象"><a href="#datetime-date对象" class="headerlink" title="datetime.date对象"></a>datetime.date对象</h1><p>首先，创建一个日期对象</p>
<h2 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h2><h3 id="创建日期对象-1"><a href="#创建日期对象-1" class="headerlink" title="创建日期对象"></a>创建日期对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个日期对象</span></span><br><span class="line">birth = datetime.date(<span class="number">2004</span>, <span class="number">2</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(birth)  <span class="comment"># Output: 2004-01-28</span></span><br></pre></td></tr></table></figure>
<h3 id="日期对象的表示范围"><a href="#日期对象的表示范围" class="headerlink" title="日期对象的表示范围"></a>日期对象的表示范围</h3><p>最小值是公元元年1月1日，最大值是公元9999年12月31日</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示范围</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;datetime.date的最大值：&#x27;</span>,datetime.date.<span class="built_in">max</span>)       <span class="comment"># 9999-12-31 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;datetime.date的最小值：&#x27;</span>,datetime.date.<span class="built_in">min</span>)       <span class="comment"># 0001-01-01</span></span><br></pre></td></tr></table></figure>
<h3 id="获取各个年-月-日"><a href="#获取各个年-月-日" class="headerlink" title="获取各个年/月/日"></a>获取各个年/月/日</h3><p>直接调用其属性，<code>year,month,day</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得各个部分</span></span><br><span class="line">y=birth.year</span><br><span class="line">m=birth.month</span><br><span class="line">d=birth.day</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The month of birth:&#x27;</span>,m)   <span class="comment"># 输出： 2</span></span><br></pre></td></tr></table></figure>
<h2 id="日期对象格式化为字符串、修改日期"><a href="#日期对象格式化为字符串、修改日期" class="headerlink" title="日期对象格式化为字符串、修改日期"></a>日期对象格式化为字符串、修改日期</h2><h3 id="使用strftime精细控制格式化"><a href="#使用strftime精细控制格式化" class="headerlink" title="使用strftime精细控制格式化"></a>使用strftime精细控制格式化</h3><p>使用方法是<code>mydate.strftime(&#39;格式化字符串&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用strftime精细控制,表示时、分或秒的格式代码值将为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;formated birth is :&quot;</span>,birth.strftime(<span class="string">&quot;%Y年%m月%d日&quot;</span>))</span><br><span class="line"><span class="comment"># 输出2004年02月18日</span></span><br></pre></td></tr></table></figure>
<h3 id="格式化为YYYY-MM-DD"><a href="#格式化为YYYY-MM-DD" class="headerlink" title="格式化为YYYY-MM-DD"></a>格式化为YYYY-MM-DD</h3><p>使用方法是<code>mydate.isoformat()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出iso8601日期格式字符串YYYY-MM-DD</span></span><br><span class="line">birth_iso_format=birth.isoformat()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;birth_iso_format is <span class="subst">&#123;birth_iso_format&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 2004-02-18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="格式化为-’Weekday-month-day-h-m-s-YYYY’"><a href="#格式化为-’Weekday-month-day-h-m-s-YYYY’" class="headerlink" title="格式化为:’Weekday month day h-m-s YYYY’"></a>格式化为:’Weekday month day h-m-s YYYY’</h3><p>使用方法是<code>mydate.ctime()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日期格式化为:&#x27;Wed Dec  4 00:00:00 2002&#x27;</span></span><br><span class="line">birth_ctime=birth.ctime()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;birth_ctime is <span class="subst">&#123;birth_ctime&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># Wed Feb 18 00:00:00 2004</span></span><br></pre></td></tr></table></figure>
<h3 id="修改日期"><a href="#修改日期" class="headerlink" title="修改日期"></a>修改日期</h3><p>  使用方法是<code>mydate.replace(year=newyear,month=newmonth,day=newday)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改日期</span></span><br><span class="line"><span class="comment"># newdate=date.replace(year=self.year, month=self.month, day=self.day)</span></span><br><span class="line">revised_birth= birth.replace(month=<span class="number">1</span>,day=<span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改了月份和天的birth是:&#x27;</span>,revised_birth)</span><br></pre></td></tr></table></figure>
<h2 id="关于周几和距离公元元年1月1日的距离"><a href="#关于周几和距离公元元年1月1日的距离" class="headerlink" title="关于周几和距离公元元年1月1日的距离"></a>关于周几和距离公元元年1月1日的距离</h2><h3 id="获取0-6表示的weekday"><a href="#获取0-6表示的weekday" class="headerlink" title="获取0~6表示的weekday"></a>获取0~6表示的weekday</h3><p><code>mydate.weekday()</code>返回一个整数代表星期几，星期一为0，星期天为6</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回一个整数代表星期几，星期一为0，星期天为6</span></span><br><span class="line">week = <span class="number">1</span> + birth.weekday()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;birth是周&#x27;</span>,week)</span><br></pre></td></tr></table></figure>
<h3 id="获取1-7表示的weekday"><a href="#获取1-7表示的weekday" class="headerlink" title="获取1~7表示的weekday"></a>获取1~7表示的weekday</h3><p><code>mydate.isoweekday()</code>返回一个整数代表星期几，星期一为1，星期天为7</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接用iso标准，1~7</span></span><br><span class="line">week=birth.isoweekday()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;birth是周&#x27;</span>,week)</span><br></pre></td></tr></table></figure>
<h3 id="获取『某年某周周几』是『某年某月某日』"><a href="#获取『某年某周周几』是『某年某月某日』" class="headerlink" title="获取『某年某周周几』是『某年某月某日』"></a>获取『某年某周周几』是『某年某月某日』</h3><p><code>mydate.fromisocalendar(YYYY,week,weekday)</code>返回确切的年月日</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取『某年某周周几』是『几月几日』</span></span><br><span class="line">day3=datetime.date.fromisocalendar(<span class="number">2024</span>,<span class="number">45</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2024年45周周一是:&#x27;</span>,day3)</span><br><span class="line"><span class="comment"># 2024-11-04</span></span><br></pre></td></tr></table></figure>
<h3 id="获取『某年某月某日』是『某年某周周几』"><a href="#获取『某年某月某日』是『某年某周周几』" class="headerlink" title="获取『某年某月某日』是『某年某周周几』"></a>获取『某年某月某日』是『某年某周周几』</h3><p><code>mydate.fromisocalendar(YYYY,week,weekday)</code>返回确切的年月日</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前日期的iso历法 ：year, week 和 weekday</span></span><br><span class="line">birth=datetime.date(<span class="number">2004</span>,<span class="number">2</span>,<span class="number">18</span>)</span><br><span class="line">birth_iso_cal=birth.isocalendar()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;2004-2-18 is <span class="subst">&#123;birth_iso_cal&#125;</span>&#x27;</span>)     <span class="comment">#datetime.IsoCalendarDate(year=2004, week=8, weekday=3)</span></span><br></pre></td></tr></table></figure>
<h2 id="其他-字符串解析为日期对象、修改日期、获取当前日期"><a href="#其他-字符串解析为日期对象、修改日期、获取当前日期" class="headerlink" title="其他(字符串解析为日期对象、修改日期、获取当前日期)"></a>其他(字符串解析为日期对象、修改日期、获取当前日期)</h2><h3 id="字符串解析为日期对象"><a href="#字符串解析为日期对象" class="headerlink" title="字符串解析为日期对象"></a>字符串解析为日期对象</h3><p>使用<code>datetime.datetime.striptime(myString,&#39;格式化字符串&#39;)</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字符串解析为日期对象</span></span><br><span class="line">str_date=<span class="string">&#x27;2004-01-28&#x27;</span></span><br><span class="line">obj_str_date=datetime.datetime.strptime(str_date,<span class="string">&quot;%Y-%m-%d&quot;</span>).date()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;obj_str_date的类型是:&#x27;</span>,<span class="built_in">type</span>(obj_str_date))   <span class="comment"># 输出 &lt;class &#x27;datetime.date&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="修改日期-1"><a href="#修改日期-1" class="headerlink" title="修改日期"></a>修改日期</h3><p>使用方法是<code>mydate.replace(year=newyear,month=newmonth,day=newday)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改日期</span></span><br><span class="line"><span class="comment"># newdate=date.replace(year=self.year, month=self.month, day=self.day)</span></span><br><span class="line">revised_birth= birth.replace(month=<span class="number">1</span>,day=<span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改了月份和天的birth是:&#x27;</span>,revised_birth)</span><br></pre></td></tr></table></figure>
<h3 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h3><p>使用<code>datetime.datetime.today</code>法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;datetime.datetime&#x27;</span>.center(<span class="number">40</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天是:&#x27;</span>,datetime.date.today())     <span class="comment"># 今天是: 2024-08-05</span></span><br></pre></td></tr></table></figure>
<h2 id="支持数学算术运算-1"><a href="#支持数学算术运算-1" class="headerlink" title="支持数学算术运算"></a>支持数学算术运算</h2><p>支持的运算：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>date2 = date1 + timedelta</code></td>
<td><code>date2</code> 将为 <code>date1</code> 之后的 <code>timedelta.days</code> 日。<strong>可以后退</strong> (1)</td>
</tr>
<tr>
<td><code>date2 = date1 - timedelta</code></td>
<td>计算 <code>date2</code> 使得 <code>date2 + timedelta == date1</code>。 (2)</td>
</tr>
<tr>
<td><code>timedelta = date1 - date2</code></td>
<td>(3）<strong>精确结果</strong></td>
</tr>
<tr>
<td><code>date1 == date2</code><br><br><code>date1 != date2</code></td>
<td>相等性比较。 (4)</td>
</tr>
<tr>
<td><code>date1 &lt; date2</code><br><br><code>date1 &gt; date2</code><br><br><code>date1 &lt;= date2</code><br><br><code>date1 &gt;= date2</code></td>
<td><strong>顺序比较</strong>。 (5)</td>
</tr>
</tbody>
</table>
</div>
<p>注释：</p>
<ol>
<li><p>如果 <code>timedelta.days &gt; 0</code> 则 <em>date2</em> 将在时间线上前进，如果 <code>timedelta.days &lt; 0</code> 则将后退。 操作完成后 <code>date2 - date1 == timedelta.days</code>。 <code>timedelta.seconds</code> 和 <code>timedelta.microseconds</code> 会被忽略。 如果 <code>date2.year</code> 将小于 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.MINYEAR" title="datetime.MINYEAR"><code>MINYEAR</code></a> 或大于 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.MAXYEAR" title="datetime.MAXYEAR"><code>MAXYEAR</code></a> 则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>。</p>
</li>
<li><p><code>timedelta.seconds</code> 和 <code>timedelta.microseconds</code> 会被忽略。</p>
</li>
<li><p>该值是<strong>精确的</strong>，且不会溢出。 运算后 <code>timedelta.seconds</code> 和 <code>timedelta.microseconds</code> 均为 0，且 <code>date2 + timedelta == date1</code>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a> 对象在表示相同的日期时相等。</p>
</li>
<li><p>当 <em>date1</em> 的时间在 <em>date2</em> 之前则认为 <em>date1</em> 小于 <em>date2</em>。 换句话说，当且仅当 <code>date1.toordinal() &lt; date2.toordinal()</code> 时 <code>date1 &lt; date2</code>。</p>
</li>
</ol>
<p>在布尔运算中，<strong>所有 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a> 对象都会被视为真值。</strong></p>
<h1 id="datetime-datetime"><a href="#datetime-datetime" class="headerlink" title="datetime.datetime"></a>datetime.datetime</h1><p>对象是包含来自 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a> 对象和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 对象的所有信息的单一对象。</p>
<p>与 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" title="datetime.date"><code>date</code></a> 对象一样，<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a> 假定当前的格列高利历向前后两个方向无限延伸；与 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 对象一样，<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" title="datetime.datetime"><code>datetime</code></a> 假定每一天恰好有 3600*24 秒。</p>
<p>构造器 ：</p>
<p><code>class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</code></p>
<p><strong><em>year</em>, <em>month</em> 和 <em>day</em> 参数是必须的</strong>。 <em>tzinfo</em> 可以是 <code>None</code> 或者是一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo"><code>tzinfo</code></a> 子类的实例。 其余的参数必须是在下面范围内的整数：</p>
<ul>
<li><p><code>MINYEAR &lt;= year &lt;= MAXYEAR</code>,</p>
</li>
<li><p><code>1 &lt;= month &lt;= 12</code>,</p>
</li>
<li><p><code>1 &lt;= day &lt;= 指定年月的天数</code>,</p>
</li>
<li><p><code>0 &lt;= hour &lt; 24</code>,</p>
</li>
<li><p><code>0 &lt;= minute &lt; 60</code>,</p>
</li>
<li><p><code>0 &lt;= second &lt; 60</code>,</p>
</li>
<li><p><code>0 &lt;= microsecond &lt; 1000000</code>,</p>
</li>
<li><p><code>fold in [0, 1]</code>.</p>
</li>
</ul>
<p>如果参数不在这些范围内，则抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> 异常。</p>
<h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><p>利用<code>datetime.datetime.today()</code>或者<code>datetime.datetime.now()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前日期和时间</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">today1=datetime.datetime.today()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天是:&#x27;</span>,today1)     <span class="comment"># 今天是: 2024-08-05 18:40:49.937493</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">today2=datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天是:&#x27;</span>,today2)     <span class="comment"># 今天是: 2024-08-05 18:42:38.699239</span></span><br></pre></td></tr></table></figure>
<h2 id="距离『公元元年1月1日』的距离"><a href="#距离『公元元年1月1日』的距离" class="headerlink" title="距离『公元元年1月1日』的距离"></a>距离『公元元年1月1日』的距离</h2><h3 id="获得距离『公元元年1月1日』指定天数的具体日期-某年某月某日』"><a href="#获得距离『公元元年1月1日』指定天数的具体日期-某年某月某日』" class="headerlink" title="获得距离『公元元年1月1日』指定天数的具体日期(某年某月某日』)"></a>获得距离『公元元年1月1日』指定天数的具体日期(某年某月某日』)</h3><p>利用<code>datetime.datetime.fromordinal(天数)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">after999999=datetime.datetime.fromordinal(<span class="number">999999</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;999999days after 1,1,1 is :&#x27;</span>,after999999)        <span class="comment"># 2738-11-27 00:00:00</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串解析为datetime对象"><a href="#字符串解析为datetime对象" class="headerlink" title="字符串解析为datetime对象"></a>字符串解析为datetime对象</h2><h3 id="用datetime-datetime-fromisoformat-yourString-方法。"><a href="#用datetime-datetime-fromisoformat-yourString-方法。" class="headerlink" title="用datetime.datetime.fromisoformat(yourString)方法。"></a>用datetime.datetime.fromisoformat(yourString)方法。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-11-04&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;20111104&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-11-04T00:05:23&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-11-04T00:05:23Z&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>, tzinfo=datetime.timezone.utc)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;20111104T000523&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-W01-2T00:05:23.283&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">283000</span>)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-11-04 00:05:23.283&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">283000</span>)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-11-04 00:05:23.283+00:00&#x27;</span>)</span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">283000</span>, tzinfo=datetime.timezone.utc)</span><br><span class="line">&gt;&gt;&gt;datetime.fromisoformat(<span class="string">&#x27;2011-11-04T00:05:23+04:00&#x27;</span>)   </span><br><span class="line">datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">23</span>,</span><br><span class="line">    tzinfo=datetime.timezone(datetime.timedelta(seconds=<span class="number">14400</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="strptime-方法将字符串解析为datetime-datetime对象"><a href="#strptime-方法将字符串解析为datetime-datetime对象" class="headerlink" title="strptime()方法将字符串解析为datetime.datetime对象"></a>strptime()方法将字符串解析为datetime.datetime对象</h3><p>用strptime()方法:</p>
<p><code>datetime.strptime(*date_string*, *format*)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">birth=<span class="string">&#x27;2004年2月18日&#x27;</span></span><br><span class="line">birth_datetime=datetime.datetime.strptime(birth,<span class="string">&#x27;%Y年%m月%d日&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;birth_datetime is:&#x27;</span>,birth_datetime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of birth_datetime is:&#x27;</span>,<span class="built_in">type</span>(birth_datetime))</span><br><span class="line"><span class="comment"># 2004-02-18 00:00:00</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="datetime类格式化为字符串、计算周几"><a href="#datetime类格式化为字符串、计算周几" class="headerlink" title="datetime类格式化为字符串、计算周几"></a>datetime类格式化为字符串、计算周几</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">birth=datetime.datetime(<span class="number">2004</span>,<span class="number">2</span>,<span class="number">18</span>)</span><br><span class="line">birth_1=birth.weekday()     <span class="comment"># 2</span></span><br><span class="line">birth_2=birth.isoweekday()      <span class="comment"># 3</span></span><br><span class="line">birth_3=birth.isocalendar()     <span class="comment"># datetime.IsoCalendarDate(year=2004, week=8, weekday=3)</span></span><br><span class="line">birth_4=birth.isoformat()       <span class="comment"># &#x27;2004-02-18T00:00:00&#x27;  </span></span><br><span class="line">birth_5=birth.ctime()     <span class="comment"># &#x27;Wed Feb 18 00:00:00 2004&#x27;</span></span><br><span class="line">birth_6=birth.strftime(<span class="string">&#x27;%Y年%m月%d日&#x27;</span>)        <span class="comment"># &#x27;2004年02月18日&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p><code>datetime.isoformat(*sep=&#39;T&#39;*, *timespec=&#39;auto&#39;*)</code><a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime.isoformat" title="Link to this definition"></a></p>
<p>返回一个以 ISO 8601 格式表示的日期和时间字符串：</p>
<ul>
<li><p><code>YYYY-MM-DDTHH:MM:SS.ffffff</code>，如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime.microsecond" title="datetime.datetime.microsecond"><code>microsecond</code></a> 不为 0</p>
</li>
<li><p><code>YYYY-MM-DDTHH:MM:SS</code>，如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime.microsecond" title="datetime.datetime.microsecond"><code>microsecond</code></a> 为 0</p>
</li>
</ul>
<h1 id="datetime-time"><a href="#datetime-time" class="headerlink" title="datetime.time"></a>datetime.time</h1><p>一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 对象代表某日的（本地）时间，它独立于任何特定日期，并可通过 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo"><code>tzinfo</code></a> 对象来调整。</p>
<p><em>class</em> datetime.time(<em>hour=0</em>, <em>minute=0</em>, <em>second=0</em>, <em>microsecond=0</em>, <em>tzinfo=None</em>, <em>**, </em>fold=0*)<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="Link to this definition"></a></p>
<p>所有参数都是可选的。 <em>tzinfo</em> 可以是 <code>None</code>，或者是一个 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo"><code>tzinfo</code></a> 子类的实例。 其余的参数必须是在下面范围内的整数：</p>
<ul>
<li><p><code>0 &lt;= hour &lt; 24</code>,</p>
</li>
<li><p><code>0 &lt;= minute &lt; 60</code>,</p>
</li>
<li><p><code>0 &lt;= second &lt; 60</code>,</p>
</li>
<li><p><code>0 &lt;= microsecond &lt; 1000000</code>,</p>
</li>
<li><p><code>fold in [0, 1]</code>.</p>
</li>
</ul>
<p>如果给出一个此范围以外的参数，则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。 所有参数默认值均为 0 但 <em>tzinfo</em> 除外，其默认值为 <code>None</code>。</p>
<p>类属性：</p>
<ul>
<li><code>time.min</code></li>
</ul>
<p>早最的可表示 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a>, <code>time(0, 0, 0, 0)</code>。</p>
<ul>
<li><code>time.max</code></li>
</ul>
<p>最晚的可表示 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a>, <code>time(23, 59, 59, 999999)</code>。</p>
<ul>
<li><code>time.resolution</code></li>
</ul>
<p>两个不相等的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 对象之间可能的最小间隔，<code>timedelta(microseconds=1)</code>，但是请注意 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 对象并不支持算术运算。</p>
<p>实例属性（只读）：</p>
<ul>
<li><code>time.hour</code></li>
</ul>
<p>取值范围是 <code>range(24)</code>。</p>
<ul>
<li><code>time.minute</code></li>
</ul>
<p>取值范围是 <code>range(60)</code>。</p>
<ul>
<li><code>time.second</code></li>
</ul>
<p>取值范围是 <code>range(60)</code>。</p>
<ul>
<li><code>time.microsecond</code></li>
</ul>
<p>取值范围是 <code>range(1000000)</code>。</p>
<h2 id="datetime-time对象格式化为字符串"><a href="#datetime-time对象格式化为字符串" class="headerlink" title="datetime.time对象格式化为字符串"></a>datetime.time对象格式化为字符串</h2><h3 id="使用time-isoformat-timespec-’auto’-方法"><a href="#使用time-isoformat-timespec-’auto’-方法" class="headerlink" title="使用time.isoformat(timespec=’auto’)方法"></a>使用time.isoformat(<em>timespec=’auto’</em>)方法</h3><p>返回表示为下列 ISO 8601 格式之一的时间字符串：</p>
<ul>
<li><p><code>HH:MM:SS.ffffff</code>，如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.microsecond" title="datetime.time.microsecond"><code>microsecond</code></a> 不为 0</p>
</li>
<li><p><code>HH:MM:SS</code>，如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.microsecond" title="datetime.time.microsecond"><code>microsecond</code></a> 为 0</p>
</li>
<li><p><code>HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]</code>，如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.utcoffset" title="datetime.time.utcoffset"><code>utcoffset()</code></a> 不返回 <code>None</code></p>
</li>
<li><p><code>HH:MM:SS+HH:MM[:SS[.ffffff]]</code>，如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.microsecond" title="datetime.time.microsecond"><code>microsecond</code></a> 为 0 并且 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.utcoffset" title="datetime.time.utcoffset"><code>utcoffset()</code></a> 不返回 <code>None</code></p>
</li>
</ul>
<p>可选参数 <em>timespec</em> 要包含的额外时间组件值 (默认为 <code>&#39;auto&#39;</code>)。它可以是以下值之一：</p>
<ul>
<li><p><code>&#39;auto&#39;</code>: 如果 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.microsecond" title="datetime.time.microsecond"><code>microsecond</code></a> 为 0 则与 <code>&#39;seconds&#39;</code> 相同，否则与 <code>&#39;microseconds&#39;</code> 相同。</p>
</li>
<li><p><code>&#39;hours&#39;</code>: 以两个数码的 <code>HH</code> 格式 包含 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.hour" title="datetime.time.hour"><code>hour</code></a>。</p>
</li>
<li><p><code>&#39;minutes&#39;</code>: 以 <code>HH:MM</code> 格式包含 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.hour" title="datetime.time.hour"><code>hour</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.minute" title="datetime.time.minute"><code>minute</code></a>。</p>
</li>
<li><p><code>&#39;seconds&#39;</code>: 以 <code>HH:MM:SS</code> 格式包含 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.hour" title="datetime.time.hour"><code>hour</code></a>, <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.minute" title="datetime.time.minute"><code>minute</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time.second" title="datetime.time.second"><code>second</code></a>。</p>
</li>
<li><p><code>&#39;milliseconds&#39;</code>: 包含完整时间，但将秒值的小数部分截断至毫秒。 格式为 <code>HH:MM:SS.sss</code>。</p>
</li>
<li><p><code>&#39;microseconds&#39;</code>: 以 <code>HH:MM:SS.ffffff</code> 格式包含完整时间。</p>
</li>
</ul>
<p>备注</p>
<p>排除掉的时间部分将被截断，而不是被舍入。</p>
<h3 id="使用-datetime-time-strftime-format-方法"><a href="#使用-datetime-time-strftime-format-方法" class="headerlink" title="使用 datetime.time.strftime(format)方法"></a>使用 datetime.time.strftime(<em>format</em>)方法</h3><p>方法参见<code>datetime.datetime</code>和<code>datetime.date</code>对象的方法</p>
<h2 id="字符串解析为datetime-time对象"><a href="#字符串解析为datetime-time对象" class="headerlink" title="字符串解析为datetime.time对象"></a>字符串解析为datetime.time对象</h2><h3 id="使用datetime-time-fromisoformat-‘string’-方法"><a href="#使用datetime-time-fromisoformat-‘string’-方法" class="headerlink" title="使用datetime.time.fromisoformat(‘string’)方法"></a>使用datetime.time.fromisoformat(‘string’)方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> datetime <span class="keyword">import</span> time</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;04:23:01&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;T04:23:01&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;T042301&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;04:23:01.000384&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">384</span>)</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;04:23:01,000384&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">384</span>)</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;04:23:01+04:00&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>, tzinfo=datetime.timezone(datetime.timedelta(seconds=<span class="number">14400</span>)))</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;04:23:01Z&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>, tzinfo=datetime.timezone.utc)</span><br><span class="line">&gt;&gt;&gt;time.fromisoformat(<span class="string">&#x27;04:23:01+00:00&#x27;</span>)</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">23</span>, <span class="number">1</span>, tzinfo=datetime.timezone.utc)</span><br></pre></td></tr></table></figure>
<h2 id="修改datetime-time类"><a href="#修改datetime-time类" class="headerlink" title="修改datetime.time类"></a>修改datetime.time类</h2><p><code>time.replace(*hour=self.hour*, *minute=self.minute*, *second=self.second*, *microsecond=self.microsecond*, *tzinfo=self.tzinfo*, ***, *fold=0*)</code></p>
<p>返回一个具有同样属性值的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a>，除非通过任何关键字参数指定了某些属性值。 请注意可以通过指定 <code>tzinfo=None</code> 从一个感知型 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a> 创建一个简单型 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" title="datetime.time"><code>time</code></a>，而不必转换时间数据。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior">https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-从欧拉角、旋转矩阵到四元数</title>
    <url>/2024/09/14/Robotics-%E4%BB%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E3%80%81%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%88%B0%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    <content><![CDATA[<h1 id="符号与说明"><a href="#符号与说明" class="headerlink" title="符号与说明"></a>符号与说明</h1><img src="/2024/09/14/Robotics-%E4%BB%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E3%80%81%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%88%B0%E5%9B%9B%E5%85%83%E6%95%B0/xyz.jpg" class="" title="xyz">
<ul>
<li><p>b：机体坐标系；e/i：地球固联坐标系；</p>
</li>
<li><p>NED：North-East-Down坐标系，三个单词依次为x轴、y轴、z轴；</p>
</li>
<li><p>ENU：East-North-Up坐标系，三个单词依次为x轴、y轴、z轴；</p>
</li>
<li><p>由于mark down中无法输入左上标和左下标，所以用上标和下标代替左上标和左下标。</p>
</li>
<li><p>记 $\overset{b}{b_1}=e_1=$$\begin{pmatrix}<br>1 \<br>0 \<br>0<br>\end{pmatrix}$,$b_2、b_3$依次类推，其中 $\overset{b}{b_1}$表示在 $b$ 参考系下，沿着第一个轴的单位向量。</p>
</li>
<li><p>一般，假定绕 $z$ 轴所转角度为 $\psi$ （偏航角）,绕 $y$ 轴所转角度为 $\theta$ （俯仰角）,绕 $x$ 轴所转角度为 $\phi$ （滚转角）</p>
</li>
<li><p>飞行器从固联坐标系到机体坐标系，采用的是 $e\to k\to n\to b$ 的顺序，从机体坐标系到固联坐标系，采用的是 $b\to n\to k\to e$ 的顺序；</p>
</li>
<li><p>旋转矩阵分为向量绕轴旋转和坐标系旋转，二者是逆的关系，前者是坐标系不变，向量转动 $\alpha$ ，后者是坐标轴转动 $\alpha$ 。注意，此处的旋转均满足右手定则，即旋转的时候，角速度方向是大拇指的方向即旋转轴的方向。</p>
</li>
<li><ul>
<li><p>在二维平面内向量的转动（绕z轴的转动），旋转矩阵为: $\left(\begin{matrix}  \cos \alpha &amp; -\sin\alpha \ \sin \alpha &amp; \cos\alpha \end{matrix}\right ) \label{1.1}$</p>
</li>
<li><p>在在二维平面内坐标轴的转动（绕z轴的转动），旋转矩阵为 $\left(\begin{matrix}  \cos \alpha &amp; \sin\alpha \-\sin \alpha &amp; \cos\alpha \end{matrix}\right ) \tag{1.1}$</p>
</li>
</ul>
</li>
</ul>
<h1 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h1><p>以 $ Z-Y-X$ 欧拉角为例，它表示的是坐标系从 $e$ 系出发，先绕 $Z$ 轴 $\psi$ ,到达 $k$ 系；再绕 $k$ 系中的 $Y$ 轴 $\theta$ ，到达 $n$ 系；最后再绕 $n$ 系中的 $X$ 轴 $\phi$ ，到达 $b$ 系，中间绕的 $Y$ 、$X$ 轴均为<strong>每次旋转后的新的坐标系下的轴，而不是原始的 $e$ 系中的坐标轴。</strong>（这种旋转方法称之为<strong>内旋</strong>，还有一种旋转方法是固定每次旋转的转轴，比如设置为固联坐标系下的坐标轴，此为外旋，下面介绍的是内旋）</p>
<script type="math/tex; mode=display">
e\to k\to n\to b</script><p>我们仿照二维坐标系中向量绕轴旋转，可以得到三次旋转的旋转矩阵如下:</p>
<script type="math/tex; mode=display">
\tag{1}
R_z(\psi)=\left(\begin{matrix} \cos \psi &\sin \psi &0\\
                        -\sin \psi &cos \psi &0\\
                        0 & 0& 1         \end{matrix}\right)\\
R_y(\theta)=\left(\begin{matrix} \cos \theta &0 &-\sin \theta\\
                                0 & 1& 0 \\
                                 \sin \theta&0 &\cos \theta 
                                \end{matrix}\right)    \\
R_x(\phi)=\left(\begin{matrix} 1 & 0& 0 \\
                                0 &\cos \phi&\sin \phi\\
                                0&-\sin \phi &cos \phi\\
                                        \end{matrix}\right)    \\</script><p>我们可以得到各个坐标系向 $b$ 系变换的公式,注意顺序是<strong>每次变换要左乘</strong>！</p>
<script type="math/tex; mode=display">
\tag{2}
\begin{align}
R_e^b&=R_x(\phi)R_y(\theta)R_z(\psi)\\
&=\left(\begin{matrix} \cos\psi\cos\theta& \cos\theta\sin\psi&-\sin\theta\\ 
\cos\psi\sin\phi\sin\theta- \cos\phi\sin\psi&\cos\phi\cos\psi+\sin\phi\sin\psi\sin\theta&\cos\theta\sin\phi\\
\sin\phi\sin\psi+ \cos\phi\cos\psi\sin\theta&\cos\phi\sin\psi\sin\theta- \cos\psi\sin\phi&\cos\phi\cos\theta
    \end{matrix}\right)\\

R_k^b&=R_x(\phi)R_y(\theta)\\
&=\left(\begin{matrix} \cos\theta & 0& -\sin\theta \\
        \sin \theta\sin \phi &\cos \phi&\cos\theta \sin\phi\\
        \sin \theta\cos \phi & -\sin \phi &\cos\theta \cos \phi\\
    \end{matrix}\right)\\

R_n^b&=R_x(\phi)\\
&=\left(\begin{matrix} 1 & 0& 0 \\
                      0 &\cos \phi&\sin \phi\\
                      0 &-\sin \phi &cos \phi\\
      \end{matrix}\right)\\
\end{align}</script><p>由于 $ Z-Y-X$ 欧拉角每次变换旋转的轴不固定，所以欧拉角的变化率 $\neq$ 机体角速度。为了推导出来每次的角速度，我们从定义出发:</p>
<blockquote>
<p>坐标系从 $e$ 系出发，先绕 $Z$ 轴 $\psi$ ,到达 $k$ 系；再绕 $k$ 系中的 $Y$ 轴 $\theta$ ，到达 $n$ 系；最后再绕 $n$ 系中的 $X$ 轴 $\phi$ ，到达 $b$ 系</p>
</blockquote>
<p>那么每次变换的时候有一个轴在旋转前后的坐标系中是相同的。即 $ \mathbf e_3=\mathbf k_3,\quad \mathbf k_2=\mathbf n_2,\quad \mathbf n_1=\mathbf b_1$</p>
<script type="math/tex; mode=display">
\tag{3}
\overset{b}{\overrightarrow {\omega}}=\dot{\psi}\overset{b}{\mathbf k_3}+\dot{\theta}\overset{b}{\mathbf n_2}+\dot{\phi}\overset{b}{\mathbf b_1}\\
or\\
\overset{b}{\overrightarrow {\omega}}=\dot{\psi}\overset{b}{\mathbf e_3}+\dot{\theta}\overset{b}{\mathbf k_2}+\dot{\phi}\overset{b}{\mathbf n_1}</script><p>我们采用第一种形式，将其写为矩阵，即:</p>
<script type="math/tex; mode=display">
\tag{4}
\begin {pmatrix}
\omega_{x_b}\\
\omega_{y_b}\\
\omega_{z_b}
\end {pmatrix}
=
\left(\begin{matrix} 1 & 0& -\sin\theta \\
                                0 &\cos \phi&\cos\theta \sin\phi\\
                                0&-\sin \phi &\cos\theta cos \phi\\
                                        \end{matrix}\right)    
\begin{pmatrix}
\dot{\phi}\\
\dot{\theta}\\
\dot{\psi}
\end {pmatrix}</script><p>上述矩阵中的 $3\times 3$矩阵即为<strong>欧拉矩阵</strong>。欧拉矩阵的推导方法就是把(3)式中的 $\mathbf k_3,\quad \mathbf n_2,\quad \mathbf b_1$ 当成一个简单的向量（注意是在自己的坐标系中），然后带入(2)式中，得到其在 $b$ 系下的表示， $\overset{b}{\mathbf k_3},\quad\overset{b}{\mathbf n_2},\quad\overset{b}{\mathbf b_1}$ 即可。</p>
<p>当 $\theta=90\degree$ 的时候，可以发现 $ \mathbf n_3=\mathbf k_1$，此时发生了<strong>“万向锁”</strong>，即绕三个轴旋转的效果可以用两个轴的旋转实现。即便绕着Z轴旋转了某一个角度，但是最后的结果仍然是相当于没有绕着Z轴旋转，损失了一个自由度。旋转的表示方法不再唯一。</p>
<h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><p>旋转矩阵是一个正交矩阵，因此其逆矩阵等于其转置，且其行列式等于 $1$.</p>
<p>从 $e$ 系到 $b$ 系的旋转矩阵为 $R_e^b$ ，从 $b$ 系到 $e$ 系的旋转矩阵为 $R_b^e$ ，二者互为逆矩阵。</p>
<p>既然 $R_e^b=R_x(\phi)R_y(\theta)R_z(\psi)$ ,那么:</p>
<script type="math/tex; mode=display">
\tag{5}
\begin{align}
R_b^e&=(R_x(\phi)R_y(\theta)R_z(\psi))^{-1}\\
&=R_z(\psi)^{-1}R_y(\theta)^{-1}(R_x(\phi)^{-1}\\
&=R_z(\psi)^{T}R_y(\theta)^{T}(R_x(\phi)^{T}\\
&=\left(\begin{matrix}\cos\theta\cos\phi&\sin\psi\sin\theta\cos\phi-\cos\psi\sin\phi&\cos\psi\sin\theta\cos\phi+\sin\psi\sin\phi\\\cos\theta\sin\phi&\sin\psi\sin\theta\sin\phi+\cos\psi\cos\phi&\cos\psi\sin\theta\sin\phi-\sin\psi\cos\phi\\-\sin\theta&\sin\psi\cos\theta&\cos\psi\cos\theta\end{matrix}\right)
\end{align}</script><p>由此我们可以得到 $\psi$ 、 $\theta$ 、 $\phi$ 的表达式</p>
<script type="math/tex; mode=display">
\begin{cases}
\psi=\arctan(\dfrac{r_{21}}{r_{11}})\\
\theta=\arcsin(r_{31})\\
\phi=\arctan(\dfrac{r_{32}}{r_{33}})\\
\end{cases}</script><p>取 $\cos\theta=0$ ,即 $\theta=\pm \frac{\pi}{2}$的时候，</p>
<script type="math/tex; mode=display">
\tag{6}


R_e^b=
\left(
\begin{matrix}
0&\sin (\psi\mp\phi)&\cos (\psi\mp\phi)\\
0&\cos (\psi\mp\phi)&\sin (\psi\mp\phi)\\
\mp1& 0&0
\end{matrix}
\right)</script><p>此时，给定旋转矩阵，$\psi$ 和 $\phi$ 的取值有无数种组合，<strong>奇异性仍然存在。</strong></p>
<p>接下来介绍叉乘的<strong>斜对称阵（反对称阵）</strong>表示</p>
<p>对于一个 $3\times 3$ 的矩阵 $\mathbf a=(\mathbf a_x,\mathbf a_y,\mathbf a_z)$ 而言，其<strong>斜对称阵</strong>定义为：</p>
<script type="math/tex; mode=display">
\tag{7}
[\mathbf a]_\text{x}\overset{def}{=}
\left(
\begin{matrix}
0&-\mathbf a_z &\mathbf a_y\\
\mathbf a_z&0&-\mathbf a_x\\
-\mathbf a_y&\mathbf a_x&0
\end{matrix}
\right)</script><p>斜对称阵可以用来简化叉乘，将叉乘变成点乘</p>
<script type="math/tex; mode=display">
\mathbf a \times\mathbf b=[\mathbf a]_\text{x}\cdot \mathbf b</script><p>刚体力学复习</p>
<p>从转动轴上取一点，这一点到刚体上面某一点的连线所构成的矢量是位矢，位矢对于时间的导数是线速度，线速度也等于角速度和位矢的外积，即:</p>
<script type="math/tex; mode=display">
\frac{\mathrm d \mathrm {\overset{e}{r}}} {\mathrm d t}={\overset{e}{\omega}}\times {\overset{e}{r}}</script><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><p>所谓四元数，指的是实部为 $q_0$ ，虚部为 $q_v=[q_1,q_2,q_3]^T$ 的向量。即:</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
q_w\\
\vec{q_v}
\end{matrix}
\right]
=
\left[
\begin{matrix}
q_w\\
q_1\\
q_2\\
q_3
\end{matrix}
\right]
=
q_w+q_1\vec{i}+q_2\vec{j}+q_3\vec{k}</script><p>其中向量 $i 、j、k $的运算规则如下:</p>
<script type="math/tex; mode=display">
ij=k\\
jk=i\\
ki=j\\
ji=-1\\
kj=-1\\
ik=-1\\
i^2=j^2=k^2=ijk=-1</script><h2 id="四元数加法和乘法"><a href="#四元数加法和乘法" class="headerlink" title="四元数加法和乘法"></a>四元数加法和乘法</h2><p>加法即对应元素相加，乘法可以展开后相乘，也可以利用下面的公式</p>
<script type="math/tex; mode=display">
q_a\otimes q_b=
\left[
\begin{matrix}
q_{aw}\\\vec{q_{av}}
\end{matrix}
\right]    \otimes
\left[
\begin{matrix}
q_{bw}\\\vec{q_{bv}}
\end{matrix}
\right]
=
\left[
\begin{matrix}
q_{aw}q_{bw}-\vec{q_{av}}^T\vec{q_{bv}}\\
\vec{q_{av}}\times \vec{q_{bv}}+q_{aw}\vec{q_{bv}}+q_{bw}\vec{q_{av}}

\end{matrix}
\right]</script><p>显然，四元数乘法不满足交换律。</p>
<p>但是，四元数乘法满足交换律和结合率:</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathbf{(p\otimes q)\otimes r=p\otimes(q\otimes r)} \\
\mathbf{p}\otimes(\mathbf{q}+\mathbf{r})=\mathbf{p}\otimes\mathbf{q}+\mathbf{p}\otimes\mathbf{r} \\
(\mathbf{p+q})\otimes\mathbf{r}=\mathbf{p}\otimes\mathbf{r}+\mathbf{q}\otimes\mathbf{r} 
\end{gathered}</script><h2 id="共轭、模和逆"><a href="#共轭、模和逆" class="headerlink" title="共轭、模和逆"></a>共轭、模和逆</h2><h3 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h3><p>共轭即对虚部取反，实部不变：</p>
<script type="math/tex; mode=display">
\mathbf{q}^*=\begin{bmatrix}q_w\\-\mathbf{q}_v\end{bmatrix}</script><p>四元数相乘的共轭可以拆开，和矩阵乘法之后的转置有一点像:</p>
<script type="math/tex; mode=display">
(\mathbf{p}\otimes\mathbf{q})^*=\mathbf{q}^*\otimes\mathbf{p}^*</script><p>四元数与自己的共轭相乘得到纯虚数</p>
<script type="math/tex; mode=display">
\mathbf{q}\otimes\mathbf{q}^*=\mathbf{q}^*\otimes\mathbf{q}=\begin{bmatrix}q_w^2+q_x^2+q_y^2+q_z^2\\0\end{bmatrix}</script><h3 id="模"><a href="#模" class="headerlink" title="模"></a>模</h3><p>四元数的模定义和相关性质如下：</p>
<script type="math/tex; mode=display">
\|\mathbf{q}\|=\sqrt{\mathbf{q}\otimes\mathbf{q}^*}=\sqrt{\mathbf{q}^*\otimes\mathbf{q}}=\sqrt{q_w^2+q_x^2+q_y^2+q_z^2}\\\|\mathbf{p}\otimes\mathbf{q}\|=\|\mathbf{q}\otimes\mathbf{p}\|=\|\mathbf{p}\|\|\mathbf{q}\|</script><h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>四元数的逆等于其共轭四元数除以模的平方:</p>
<script type="math/tex; mode=display">
\mathbf{q}^{-1}=\frac{\mathbf{q}^*}{\|\mathbf{q}\|^2}\\\mathbf{q}\otimes\mathbf{q}^{-1}=\mathbf{q}^{-1}\otimes\mathbf{q}=\mathbf{q}_1=\begin{bmatrix}1\\\mathbf{0}\end{bmatrix}</script><p>四元数和它的逆做乘法的时候满足交换律，且结果等于幺元</p>
<h2 id="交换子和幺元"><a href="#交换子和幺元" class="headerlink" title="交换子和幺元"></a>交换子和幺元</h2><p>交换子定义如下:</p>
<script type="math/tex; mode=display">
[\mathbf{p},\mathbf{q}]\triangleq\mathbf{p}\otimes\mathbf{q}-\mathbf{q}\otimes\mathbf{p}=\begin{bmatrix}0\\2\mathbf{p}_v\times\mathbf{q}_v\end{bmatrix}</script><p>幺元定义如下:</p>
<script type="math/tex; mode=display">
\mathbf{q}_1=\begin{bmatrix}1\\\mathbf{0}\end{bmatrix}\\\mathbf{q}_1\otimes\mathbf{q}=\mathbf{q}\otimes\mathbf{q}_1=\mathbf{q}</script><h2 id="四元数与旋转"><a href="#四元数与旋转" class="headerlink" title="四元数与旋转"></a>四元数与旋转</h2><p>在三位空间中，原来有一个点 $P=[x_0,y_0,z_0]^T$ ，假定此时点 $P$ 绕着某一个轴 $\mathbf{v}$ 旋转，旋转后得到点 $P’=[x_0,y_0,z_0]^T$。我们将  $\mathbf{v}$ 方向的单位矢量也用  $\mathbf{v}$ 表示，即 ： $||\mathbf{v}||=1$ 。</p>
]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>欧拉角</tag>
        <tag>四元数</tag>
        <tag>旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD奇异值分解</title>
    <url>/2024/09/05/SVD%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h1><p>设矩阵$\textbf{A}$是$n \times n$的<strong>实对称矩阵</strong>，则存在正交矩阵$\textbf{U}$，使得：</p>
<script type="math/tex; mode=display">
\textbf{A}=\textbf{U} \Lambda \textbf{U}^ \mathrm{T}</script><p>其中，$\Lambda=diag(\lambda_1,\lambda_2,\ldots \lambda_n$是以 的特征值为对角线元素的对角矩阵，$\textbf{U}=(u_1,u_2,\ldots u_n)$，$u_i$为对应的特征向量。</p>
<p>由于$\textbf{U}$的正交性，上述描述等价于：</p>
<script type="math/tex; mode=display">
\textbf{U}^{-1}\textbf{A}\textbf{U}= \Lambda</script><h1 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h1><p>特征值分解是针对<strong>方阵</strong>而言，那么对于普通的$m \times n$矩阵$\textbf{A}$，有没有分解的方法呢？</p>
<p>定义矩阵的奇异值分解（Singular Value Decomposition，SVD）为：</p>
<script type="math/tex; mode=display">
\textbf{A}=\textbf{U} \Sigma \textbf{V}^ \mathrm{T}</script><p>其中：</p>
<ul>
<li><p>$\textbf{A}$为$m \times n $的矩阵</p>
</li>
<li><p>$\Sigma$为$  r \times r$的对角矩阵$diag(\sigma_1,\sigma_2,\ldots，\sigma_r)$其中$r=rank(\textbf{A})$</p>
</li>
<li><p>$\textbf{U}$为$m \times m$的正交方阵，即<strong>左奇异向量矩阵</strong></p>
</li>
<li><p>$\textbf{V}$为$n \times n$的正交方阵，即<strong>右奇异向量矩阵</strong></p>
</li>
</ul>
<h2 id="如何求解U、V？"><a href="#如何求解U、V？" class="headerlink" title="如何求解U、V？"></a>如何求解U、V？</h2><p>考虑到$\textbf{A} \textbf{A} ^{T}$为实对称矩阵，同时$\textbf{V}$为正定阵，我们计算出来$\textbf{A} \textbf{A} ^{T}$。就可以把$\textbf{V}$消掉：</p>
<script type="math/tex; mode=display">
\begin{align} 
\textbf{A} \textbf{A} ^{T} & = \textbf{U} \Sigma \textbf{V}^ \mathrm{T}(\textbf{U} \Sigma \textbf{V}^ \mathrm{T})^{T}\\
& = \textbf{U} \Sigma \textbf{V}^ \mathrm{T}(\textbf{V} \Sigma \textbf{U}^ \mathrm{T})\\
& = \textbf{U} \Sigma (\textbf{V}^ \mathrm{T}\textbf{V}) \Sigma \textbf{U}^ \mathrm{T}\\
&=\textbf{U} \Sigma ^2\textbf{U}^\mathrm{T}
\end{align}</script><p>所以，我们就可以先计算出来$\textbf{A} \textbf{A} ^{T}$的特征值和对应的特征向量，这些特征向量就是构成$\textbf{U}=(u_1,u_2,\ldots u_n)$的列向量$u_1,u_2,\ldots u_n$,即<strong>左奇异向量</strong>。</p>
<p>同理，计算出来 $\textbf{A} ^{T}\textbf{A}$的特征值和对应的特征向量，这些特征向量就是构成$\textbf{V}=(v_1,v_2,\ldots v_n)$的列向量$v_1,v_2,\ldots v_n$,即<strong>右奇异向量</strong>。</p>
<h2 id="如何求解-Sigma"><a href="#如何求解-Sigma" class="headerlink" title="如何求解$\Sigma$?"></a>如何求解$\Sigma$?</h2><p>首先，$\textbf{A} \textbf{A} ^{T}$或者是必为<strong>半正定矩阵</strong>，原因如下：对于任意对任意向量 x，我们有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^T(\textbf{A}\textbf{A}^T)x&=(\textbf{A}^Tx)^T(\textbf{A}^Tx)\\
&=∥\textbf{A}^Tx∥2\\
&\geq 0
\end{aligned}</script><p>因此，矩阵 $AA^T $是半正定矩阵,其特征值$\lambda_1,\lambda_2,\ldots,\lambda_r$必定大于等于0。</p>
<p>注意到（4）式中，出现的$\Sigma ^2$，我们就可以得到$\Sigma ^2$是由$\textbf{A} \textbf{A} ^{T}$对应特征值为对角线元素构成的对角阵，于是，可以先求出来$\textbf{A} \textbf{A} ^{T}$的若干特征值$\lambda_1,\lambda_2,\ldots,\lambda_r$(因为$rank(\textbf{A})=rank(\textbf{A}\textbf{A} ^{T})$)，这些特征值是$\Sigma ^2$的对角线元素，对其开方，就可以得到$\Sigma$的对角线元素$\sigma_1,\sigma_2,\ldots,\sigma_r$,即：</p>
<script type="math/tex; mode=display">
\sigma_i=\sqrt{\lambda_i(\textbf{A} \textbf{A} ^{T})}=\sqrt{\lambda_i(\textbf{A} ^{T}\textbf{A} )}</script><p>值得注意的是，由于矩阵$\textbf{A}$不一定是方阵，所以求出来的$\Sigma $矩阵也未必是方阵，而是一个和$\textbf{A}$行数和列数相同的矩阵。即使$\textbf{A}$是方阵，也未必满秩，所以我们求出来的$\sigma_1,\sigma_2,\ldots,\sigma_r$仅仅是$\Sigma$的左上角的一部分，需要用$0$填充为$m \times n$矩阵，就得到了最后的$\Sigma$</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/pinard/p/6251584.html">奇异值分解(SVD)原理与在降维中的应用 - 刘建平Pinard - 博客园</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/399547902">奇异值分解（SVD）的定义、证明、求法（矩阵分解——3. 奇异值分解（SVD))</a></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
        <tag>特征值分解</tag>
        <tag>奇异值分解</tag>
        <tag>SVD</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-Relearning-os</title>
    <url>/2024/07/31/Python-Relearning-os-pathlib/</url>
    <content><![CDATA[<ul>
<li><p>sticky是<code>sticky</code> 值越大，顶置的文章越靠前</p>
</li>
<li><p>thumbnail: “IMAGE_LINK”</p>
<p>redefine对首页文章添加缩略图</p>
</li>
<li><p>摘要</p>
<p>excerpt: “这是文章摘要 This is the excerpt of the post”或者直接设置为false</p>
</li>
<li><p>massage: 文章的密码的提示，但是似乎没有什么用，总是显示Hey,password is required here.</p>
</li>
</ul>
<h1 id="查看Python版本"><a href="#查看Python版本" class="headerlink" title="查看Python版本"></a>查看Python版本</h1><h2 id="在命令行中"><a href="#在命令行中" class="headerlink" title="在命令行中"></a>在命令行中</h2><ul>
<li><h3 id="系统的Python版本"><a href="#系统的Python版本" class="headerlink" title="系统的Python版本"></a>系统的Python版本</h3><p><code>windows+R</code>打开<code>cmd</code>，输入<code>python -V</code>或者<code>python --version</code>，即可查看Python的版本，此版本是存入系统的环境变量的版本。</p>
</li>
<li><h3 id="anaconda-的Python版本"><a href="#anaconda-的Python版本" class="headerlink" title="anaconda 的Python版本"></a>anaconda 的Python版本</h3><p><code>Windows</code>键输入<code>anaconda</code>,调出来<code>anaconda prompt</code>的终端，此时进入到base环境中，可以输入 <code>conda env list</code>，就可以查看所有的虚拟环境。</p>
<p>然后输入<code>conda activate(空格)环境名</code>,比如<code>conda activate Python_relearning</code>就可以激活对应的环境，接着就可以重复”系统的Python版本“的查看方法，输入<code>python -V</code>或者<code>python --version</code>，即可查看Python的版本。</p>
<p>退出环境输入<code>conda deactivate</code> 即可,就可退出到base环境。</p>
</li>
</ul>
<h2 id="在python中查看"><a href="#在python中查看" class="headerlink" title="在python中查看"></a>在python中查看</h2><p>无论是在Pycharm中，还是在终端的python窗口中，都可以用下面的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.version_info)</span><br></pre></td></tr></table></figure>
<p>上述命令返回一个包含了版本号5个组成部分的元组，这5个部分分别是<strong>主要版本号（major）、次要版本号（minor）、微型版本号（micro）、发布级别（releaselevel）和序列号（serial）</strong></p>
<p>如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sys.version_info(major=3, minor=11, micro=0, releaselevel=&#x27;final&#x27;, serial=0)</span><br></pre></td></tr></table></figure>
<p>还可以直接用下面的简单的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.version)</span><br></pre></td></tr></table></figure>
<p>这个命令直接返回包含主版本和次版本的字符串，还包括发布公司等信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3.11</span><span class="number">.0</span> | packaged by Anaconda, Inc. | (main, Mar  <span class="number">1</span> <span class="number">2023</span>, <span class="number">18</span>:<span class="number">18</span>:<span class="number">21</span>) [MSC v<span class="number">.1916</span> <span class="number">64</span> bit (AMD64)]</span><br></pre></td></tr></table></figure>
<h2 id="使用platform模块"><a href="#使用platform模块" class="headerlink" title="使用platform模块"></a>使用platform模块</h2><p>详见本文的”platform模块“的内容</p>
<h1 id="Pycharm乱码问题解决"><a href="#Pycharm乱码问题解决" class="headerlink" title="Pycharm乱码问题解决"></a>Pycharm乱码问题解决</h1><h2 id="更改文件编码设置"><a href="#更改文件编码设置" class="headerlink" title="更改文件编码设置"></a>更改文件编码设置</h2><p>在Pycharm上方导航栏，找到文件，</p>
<p>文件——&gt;设置——&gt;编辑器——&gt;文件编码</p>
<p>将设置统一改为”utf-8”,并且设置为”不含BOOM“，如下图所示：</p>
<img src="/2024/07/31/Python-Relearning-os-pathlib/2024-08-01-10-33-04-image.png" class="">
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="更改Python文件模板"><a href="#更改Python文件模板" class="headerlink" title="更改Python文件模板"></a>更改Python文件模板</h2><p>在Pycharm上方导航栏，找到文件，</p>
<p>文件——&gt;设置——&gt;编辑器——&gt;文件和代码模板，在文件标签中找到”Python Script“</p>
<p>加入以下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<img src="/2024/07/31/Python-Relearning-os-pathlib/2024-08-01-10-36-32-image.png" class="">
<h2 id="检查默认编码信息"><a href="#检查默认编码信息" class="headerlink" title="检查默认编码信息"></a>检查默认编码信息</h2><p>使用sys库里面的函数<code>getdefaultencoding()</code>，即可查看编码信息:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default_encoding = sys.getdefaultencoding()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python解释器的默认编码：&quot;</span>,default_encoding)</span><br></pre></td></tr></table></figure>
<h1 id="platform模块"><a href="#platform模块" class="headerlink" title="platform模块"></a>platform模块</h1><p><code>platform</code>模块是Python标准库的一部分，因此无需额外安装。只需在Python脚本中导入即可开始使用。</p>
<h2 id="获取操作系统及计算机信息"><a href="#获取操作系统及计算机信息" class="headerlink" title="获取操作系统及计算机信息"></a>获取操作系统及计算机信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取操作系统名称</span></span><br><span class="line">os_name = platform.system()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取操作系统版本</span></span><br><span class="line">os_version = platform.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取计算机名称</span></span><br><span class="line">computer_name = platform.node()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取计算机处理器的名称</span></span><br><span class="line">processor_name = platform.processor()</span><br></pre></td></tr></table></figure>
<h2 id="获取python信息"><a href="#获取python信息" class="headerlink" title="获取python信息"></a>获取python信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Python版本，如返回&#x27;3.11.0&#x27;</span></span><br><span class="line">python_version = platform.python_version()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Python实现名称，如CPython、Jython或者IronPython</span></span><br><span class="line">python_implementation = platform.python_implementation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前Python解释器的编译器信息，如GCC、Clang或者Microsoft Visual C++</span></span><br><span class="line">python_compiler = platform.python_compiler()</span><br></pre></td></tr></table></figure>
<h1 id="路径的常识"><a href="#路径的常识" class="headerlink" title="路径的常识"></a>路径的常识</h1><p><strong>“./“：代表目前所在的目录。</strong></p>
<p><strong>“ . ./“代表上一层目录。</strong></p>
<p><strong>“/“：代表根目录。</strong>  </p>
<ul>
<li><p>路径最后加/，比如”mypath/“表示在mypath文件夹下面，不加/,比如”mypath”，表示在mypath的上一级目录中。</p>
</li>
<li><p>“root/a/../b/../file.txt”实际路径是”root/file.txt”,因为a,b都被后面的../省略了，</p>
</li>
<li><p>但是”root/a../b/../file.txt”路径却是”root/a../file.txt”，因为a后面的../返回前一级目录，但是并不存在前一级目录（相比于上面一个例子少了一个/）,所以把a..视为一个目录名字。</p>
</li>
<li></li>
</ul>
<h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><h2 id="os-path——常用的路径操作"><a href="#os-path——常用的路径操作" class="headerlink" title="os.path——常用的路径操作"></a>os.path——常用的路径操作</h2><h3 id="显示绝对路径"><a href="#显示绝对路径" class="headerlink" title="显示绝对路径"></a>显示绝对路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绝对路径显示1</span></span><br><span class="line">abspath=os.path.abspath(<span class="string">&#x27;os.path.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;本文件的绝对路径：&quot;</span>,abspath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径显示2</span></span><br><span class="line">abspath=os.path.normpath(os.path.join(os.getcwd()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前工作的的绝对路径：&quot;</span>,abspath)</span><br></pre></td></tr></table></figure>
<h3 id="连接两个或更多的路径名组件"><a href="#连接两个或更多的路径名组件" class="headerlink" title="连接两个或更多的路径名组件"></a>连接两个或更多的路径名组件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接两个或更多的路径名组件</span></span><br><span class="line">Path1 = <span class="string">&#x27;home&#x27;</span></span><br><span class="line">Path2 = <span class="string">&#x27;develop&#x27;</span></span><br><span class="line">Path3 = <span class="string">&#x27;code&#x27;</span></span><br><span class="line">path_a=os.path.join(Path1,Path2,Path3)</span><br><span class="line">path_b=os.path.join(Path1,Path2,Path3,<span class="string">&#x27;&#x27;</span>) <span class="comment"># 多加一个空字符，可以在最后多加一个\  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;末尾不带反斜杠：&#x27;</span>,path_a)  <span class="comment"># 输出home\develop\code</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;末尾带反斜杠：&#x27;</span>,path_b)  <span class="comment"># 输出 home\develop\</span></span><br><span class="line"><span class="comment"># 如果参数中存在绝对路径或者以 &quot; \ &quot; 或“ / ”开头的路径，</span></span><br><span class="line"><span class="comment"># os.path.join() 会按顺序取最后的绝对路径或者 &quot; \ &quot; 或 “ / ” 开头的路径作为基础，</span></span><br><span class="line"><span class="comment"># 并将其与其余的相对路径组合。</span></span><br></pre></td></tr></table></figure>
<p>如果参数中存在绝对路径或者以 “ \ “ 或“ / ”开头的路径，os.path.join() 会按顺序取最后的绝对路径或者 “ \ “ 或 “ / ” 开头的路径作为基础，并将其与其余的相对路径组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path1=<span class="string">&#x27;/a/b/c&#x27;</span></span><br><span class="line">path2=<span class="string">&#x27;/d/e&#x27;</span>  <span class="comment"># 最后一个“ / ” 开头的路径</span></span><br><span class="line">path3=<span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(os.path.join(path1,path2,path3))</span><br><span class="line"><span class="comment"># 输出：/d/e\f</span></span><br></pre></td></tr></table></figure>
<h3 id="检查指定的路径是否存在"><a href="#检查指定的路径是否存在" class="headerlink" title="检查指定的路径是否存在"></a>检查指定的路径是否存在</h3><p>返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exists = os.path.exists(<span class="string">r&#x27;E:\codes\Python\python_relearning&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(exists)</span><br></pre></td></tr></table></figure>
<h3 id="检查路径是否为文件"><a href="#检查路径是否为文件" class="headerlink" title="检查路径是否为文件"></a>检查路径是否为文件</h3><p>返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_file = os.path.isfile(<span class="string">r&#x27;E:\codes\Python\python_relearning&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(is_file)</span><br></pre></td></tr></table></figure>
<h3 id="检查路径是否为目录"><a href="#检查路径是否为目录" class="headerlink" title="检查路径是否为目录"></a>检查路径是否为目录</h3><p>返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_dir = os.path.isdir(<span class="string">r&#x27;E:\codes\Python\python_relearning&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(is_dir)</span><br></pre></td></tr></table></figure>
<h3 id="获取路径中的最后一级目录-（basename）"><a href="#获取路径中的最后一级目录-（basename）" class="headerlink" title="获取路径中的最后一级目录 （basename）"></a>获取路径中的最后一级目录 （basename）</h3><p>如果最后一个是文件，则返回文件名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_name = os.path.basename(<span class="string">r&#x27;E:\codes\Python\python_relearning&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_name:&#x27;</span>,base_name)</span><br></pre></td></tr></table></figure>
<h3 id="获取文件路径-dirname"><a href="#获取文件路径-dirname" class="headerlink" title="获取文件路径 (dirname)"></a>获取文件路径 (dirname)</h3><p>返回路径中的目录名。如果路径以目录名结尾，那么就是这个目录的路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dir_name1=os.path.dirname(<span class="string">r&#x27;E:\codes\Python\python_relearning&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dir_name1) <span class="comment"># 输出：E:\codes\Python  </span></span><br><span class="line"></span><br><span class="line">dir_name1=os.path.dirname(<span class="string">r&#x27;E:\codes\Python\python_relearning\os.path.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dir_name1) <span class="comment"># 输出：E:\codes\Python\python_relearning</span></span><br></pre></td></tr></table></figure>
<h3 id="分割目录名和文件名"><a href="#分割目录名和文件名" class="headerlink" title="分割目录名和文件名"></a>分割目录名和文件名</h3><p>仅仅是对于字符串的操作，<strong>以最后一个\为分隔符</strong>，返回元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dir_name, base_name = os.path.split(<span class="string">r&#x27;E:\codes\Python\python_relearning\os.path.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Directory: <span class="subst">&#123;dir_name&#125;</span>,\nBase Name: <span class="subst">&#123;base_name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 第一行输出E:\codes\Python\python_relearning,</span></span><br><span class="line"><span class="comment"># 第二行输出os.path.py</span></span><br></pre></td></tr></table></figure>
<h3 id="分离文件名和扩展名"><a href="#分离文件名和扩展名" class="headerlink" title="分离文件名和扩展名"></a>分离文件名和扩展名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename, extension = os.path.splitext(<span class="string">r&#x27;E:\codes\Python\python_relearning\os.path.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File name: <span class="subst">&#123;filename&#125;</span>&quot;</span>)   <span class="comment"># 输出：E:\codes\Python\python_relearning\os.path</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Extension: <span class="subst">&#123;extension&#125;</span>&quot;</span>)   <span class="comment"># 输出：.py</span></span><br></pre></td></tr></table></figure>
<h3 id="从绝对路径出发，找到相对路径"><a href="#从绝对路径出发，找到相对路径" class="headerlink" title="从绝对路径出发，找到相对路径"></a>从绝对路径出发，找到相对路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个参数加\</span></span><br><span class="line">relative_path = os.path.relpath(<span class="string">r&#x27;\os.path.py&#x27;</span>, <span class="string">r&#x27;E:\\codes&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Relative path: <span class="subst">&#123;relative_path&#125;</span>&quot;</span>)   <span class="comment"># 输出：..\os.path.py</span></span><br><span class="line"><span class="comment"># 第一个参数不加\</span></span><br><span class="line">relative_path = os.path.relpath(<span class="string">r&#x27;os.path.py&#x27;</span>, <span class="string">r&#x27;E:\\codes&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Relative path: <span class="subst">&#123;relative_path&#125;</span>&quot;</span>)   <span class="comment"># Python\python_relearning\os.path.py</span></span><br></pre></td></tr></table></figure>
<p>关于加不加\，下面是AI生成的回答：</p>
<blockquote>
<p>在您的代码示例中，您使用 <code>os.path.relpath()</code> 函数计算相对路径，但是您提供的第一个参数（目标路径）的形式影响了结果。这里需要理解 <code>os.path.relpath()</code> 函数如何处理相对路径和绝对路径。  </p>
<ol>
<li><p>当第一个参数（目标路径）以反斜杠 <code>\</code> 开头时，Python 在 Windows 系统上会将其解释为<strong>相对于当前驱动器的根目录的路径</strong>。因此，<code>r&#39;\os.path.py&#39;</code> 实际上表示的是一个从当前驱动器根目录开始的路径。<br>下面是您的第一个代码示例的详细解释：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relative_path = os.path.relpath(<span class="string">r&#x27;\os.path.py&#x27;</span>, <span class="string">r&#x27;E:\codes&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Relative path: <span class="subst">&#123;relative_path&#125;</span>&quot;</span>) <span class="comment"># 输出：..\os.path.py  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>r&#39;\os.path.py&#39;</code> 被解释为从当前驱动器的根目录开始的路径。  </li>
<li><code>r&#39;E:\\codes&#39;</code> 是一个绝对路径。  </li>
<li><code>os.path.relpath()</code> 计算从 <code>r&#39;E:\\codes&#39;</code> 到 <code>r&#39;\os.path.py&#39;</code> 的相对路径，结果是 <code>..\os.path.py</code>，因为 <code>os.path.py</code> 在 <code>E:\codes</code> 的上一级目录。  </li>
</ul>
<ol>
<li><p>当第一个参数（目标路径）不以反斜杠 <code>\</code> 开头时，它被视为相对于当前工作目录的路径。<br>下面是您的第二个代码示例的详细解释：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relative_path = os.path.relpath(<span class="string">r&#x27;os.path.py&#x27;</span>, <span class="string">r&#x27;E:\codes&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Relative path: <span class="subst">&#123;relative_path&#125;</span>&quot;</span>) <span class="comment"># 输出：Python\python_relearning\os.path.py  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>r&#39;os.path.py&#39;</code> 被解释为相对于当前工作目录的路径。  </li>
<li><code>r&#39;E:\\codes&#39;</code> 是一个绝对路径。  </li>
<li><code>os.path.relpath()</code> 计算从 <code>r&#39;E:\\codes&#39;</code> 到 <code>r&#39;os.path.py&#39;</code> 的相对路径。由于 <code>os.path.py</code> 被视为相对于当前工作目录的路径，假设当前工作目录是 <code>E:\codes\Python\python_relearning</code>，则结果是 <code>Python\python_relearning\os.path.py</code>。<br>请注意，第二个示例的输出取决于当前工作目录的实际位置。如果当前工作目录不是 <code>E:\codes\Python\python_relearning</code>，则输出会有所不同。<br>因此，确保您了解 <code>os.path.relpath()</code> 如何处理不同类型的路径，并正确提供目标路径和起始路径。</li>
</ul>
</blockquote>
<h3 id="规范路径"><a href="#规范路径" class="headerlink" title="规范路径"></a>规范路径</h3><p><code>os.path.normpath()</code> 函数用于规范化路径名，它将解析路径中的多余分隔符和上级目录引用（如 <code>..</code>）。下面是该函数的具体行为和规则：</p>
<ol>
<li><p><strong>解析路径分隔符</strong>：它会将路径中的多个连续路径分隔符（例如 <code>/</code> 或 <code>\</code>）替换为单个路径分隔符。</p>
</li>
<li><p><strong>解析当前目录引用</strong>：它会移除路径中的 <code>.</code>，这代表当前目录。</p>
</li>
<li><p><strong>解析上级目录引用</strong>：它会移除路径中的 <code>..</code>，这代表上级目录，同时也会移除 <code>..</code> 前面的目录名，除非 <code>..</code> 指向根目录。</p>
</li>
</ol>
<p>例程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">normalized_path = os.path.normpath(<span class="string">r&#x27;path/to\.\\ignored\..\test.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Normalized path: <span class="subst">&#123;normalized_path&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出path\to\test.txt</span></span><br></pre></td></tr></table></figure>
<p>更多例程： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">normalized_path_0 = os.path.normpath(<span class="string">r&#x27;a../b..\file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Normalized path: <span class="subst">&#123;normalized_path_0&#125;</span>&quot;</span>)  <span class="comment"># 输出 a..\b..\file.txt</span></span><br><span class="line"></span><br><span class="line">normalized_path_1 = os.path.normpath(<span class="string">r&#x27;root/a/../..\file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Normalized path: <span class="subst">&#123;normalized_path_1&#125;</span>&quot;</span>)  <span class="comment"># 输出root\a..\file.txt</span></span><br><span class="line"></span><br><span class="line">normalized_path_2 = os.path.normpath(<span class="string">r&#x27;root/a../\..\file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Normalized path: <span class="subst">&#123;normalized_path_2&#125;</span>&quot;</span>)  <span class="comment"># 输出root\file.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="OS模块其他功能"><a href="#OS模块其他功能" class="headerlink" title="OS模块其他功能"></a>OS模块其他功能</h2><h3 id="汇总-查找表"><a href="#汇总-查找表" class="headerlink" title="汇总 查找表"></a>汇总 查找表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mknod(<span class="string">&quot;text.txt&quot;</span>)：创建空文件</span><br><span class="line">os.system():运行shell命令</span><br><span class="line">os.exit():终止当前进程</span><br><span class="line">os.getcwd() 取得当前工作目录</span><br><span class="line">os.getenv()和os.putenv:分别用来读取和设置环境变量</span><br><span class="line">os.environ[<span class="string">&#x27;MY_USER&#x27;</span>]</span><br><span class="line">os.chdir(<span class="string">&#x27;dirname&#x27;</span>) 改变目录</span><br><span class="line">os.mkdir/makedirs(<span class="string">&#x27;dirname&#x27;</span>)创建目录/多层目录</span><br><span class="line">os.rmdir/removedirs(<span class="string">&#x27;dirname&#x27;</span>) 删除目录/多层目录</span><br><span class="line">os.remove(‘path/filename’) 删除文件</span><br><span class="line">os.rename(oldname, newname) 重命名文件</span><br><span class="line">os.walk() 生成目录树下的所有文件名</span><br><span class="line">os.stat（file）:获得文件属性</span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>) 列出指定目录的文件</span><br><span class="line">os.chmod() 改变目录权限  </span><br><span class="line">os.access(path, mode) <span class="comment"># 检测是否有访问权限的路径。</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(path) <span class="comment">#返回绝对路径</span></span><br><span class="line">os.path.basename(path) <span class="comment">#返回文件名</span></span><br><span class="line">os.path.commonprefix(<span class="built_in">list</span>) <span class="comment">#返回list(多个路径)中，所有path共有的最长的路径。&#x27;</span></span><br><span class="line">os.path.dirname(path) <span class="comment">#返回文件路径</span></span><br><span class="line">os.path.exists(path) <span class="comment">#路径存在则返回True,路径损坏返回False</span></span><br><span class="line">os.path.lexists              <span class="comment">#路径存在则返回True,路径损坏也返回True</span></span><br><span class="line">os.path.expanduser(path)    <span class="comment">#把path中包含的&quot;~&quot;和&quot;~user&quot;转换成用户目录</span></span><br><span class="line">os.path.expandvars(path)    <span class="comment">#根据环境变量的值替换path中包含的”$name”和”$&#123;name&#125;”</span></span><br><span class="line">os.path.getatime(path)      <span class="comment">#返回最后一次进入此path的时间。</span></span><br><span class="line">os.path.getmtime(path)      <span class="comment">#返回在此path下最后一次修改的时间。</span></span><br><span class="line">os.path.getctime(path)      <span class="comment">#返回path的大小</span></span><br><span class="line">os.path.getsize(path)       <span class="comment">#返回文件大小，如果文件不存在就返回错误</span></span><br><span class="line">os.path.isabs(path)         <span class="comment">#判断是否为绝对路径</span></span><br><span class="line">os.path.isfile(path)        <span class="comment">#判断路径是否为文件</span></span><br><span class="line">os.path.isdir(path)         <span class="comment">#判断路径是否为目录</span></span><br><span class="line">os.path.islink(path)        <span class="comment">#判断路径是否为链接</span></span><br><span class="line">os.path.ismount(path)       <span class="comment">#判断路径是否为挂载点（）</span></span><br><span class="line">os.path.join(path1[, path2[, ...]])         <span class="comment">#把目录和文件名合成一个路径&#x27;</span></span><br><span class="line">os.path.normcase(path)      <span class="comment">#转换path的大小写和斜杠</span></span><br><span class="line">os.path.normpath(path)      <span class="comment">#规范path字符串形式</span></span><br><span class="line">os.path.realpath(path)      <span class="comment">#返回path的真实路径</span></span><br><span class="line">os.path.relpath(path[, start])  <span class="comment">#从start开始计算相对路径&#x27;</span></span><br><span class="line">os.path.samefile(path1, path2)  <span class="comment">#判断目录或文件是否相同&#x27;</span></span><br><span class="line">os.path.sameopenfile(fp1, fp2)  <span class="comment">#判断fp1和fp2是否指向同一文件&#x27;</span></span><br><span class="line">os.path.samestat(stat1, stat2)  <span class="comment">#判断stat tuple stat1和stat2是否指向同一个文件&#x27;</span></span><br><span class="line">os.path.split(path)     <span class="comment">#把路径分割成dirname和basename，返回一个元组</span></span><br><span class="line">os.path.splitdrive(path)     <span class="comment">#一般用在windows下，返回驱动器名和路径组成的元组</span></span><br><span class="line">os.path.splitext(path)  <span class="comment">#分割路径，返回路径名和文件扩展名的元组</span></span><br><span class="line">os.path.splitunc(path)      <span class="comment">#把路径分割为加载点与文件</span></span><br><span class="line">os.path.walk(path, visit, arg)  <span class="comment">#遍历path，进入每个目录都调用visit函数，visit函数必须有&#x27;</span></span><br><span class="line"><span class="comment">#3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有</span></span><br><span class="line"><span class="comment">#文件名，args则为walk的第三个参数</span></span><br><span class="line">os.path.supports_unicode_filenames      <span class="comment">#设置是否支持unicode路径名</span></span><br><span class="line">os.sep:取代操作系统特定的路径分隔符</span><br><span class="line">os.name:指示你正在使用的工作平台。比如对于Windows，它是<span class="string">&#x27;nt&#x27;</span>，而对于Linux/Unix用户，它是<span class="string">&#x27;posix&#x27;</span>。</span><br></pre></td></tr></table></figure>
<h3 id="获取当前工作目录"><a href="#获取当前工作目录" class="headerlink" title="获取当前工作目录"></a>获取当前工作目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<p>返回<strong>绝对路径</strong></p>
<h3 id="列出目录下所有的文件和子目录"><a href="#列出目录下所有的文件和子目录" class="headerlink" title="列出目录下所有的文件和子目录"></a>列出目录下所有的文件和子目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.listdir(path)</span><br></pre></td></tr></table></figure>
<p><strong>返回</strong>指定的文件夹包含的文件或文件夹的名字的<strong>列表</strong>,<strong>列表以字母序</strong>。</p>
<h3 id="更改工作目录"><a href="#更改工作目录" class="headerlink" title="更改工作目录"></a>更改工作目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(path)</span><br></pre></td></tr></table></figure>
<p>如果允许访问返回 True , 否则返回False。</p>
<h3 id="创建一个新目录"><a href="#创建一个新目录" class="headerlink" title="创建一个新目录"></a>创建一个新目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(path)</span><br></pre></td></tr></table></figure>
<p>用于创建目录，而<strong>不能创建文件</strong></p>
<h3 id="递归创建多级目录"><a href="#递归创建多级目录" class="headerlink" title="递归创建多级目录"></a>递归创建多级目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(name, mode=<span class="number">511</span>, exist_ok=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>exist_ok</strong>：是否在目录存在时触发异常。如果 exist_ok 为 False（默认值），则在目标目录已存在的情况下触发 FileExistsError 异常；如果 exist_ok 为 True，则在目标目录已存在的情况下不会触发 FileExistsError 异常。</li>
<li>无返回值</li>
</ul>
<h3 id="删除空的目录"><a href="#删除空的目录" class="headerlink" title="删除空的目录"></a>删除空的目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir(path)</span><br></pre></td></tr></table></figure>
<p>用于删除指定路径的目录。<strong>仅当这是文件夹是空</strong>才可以, 否则, 抛出OSError。并且不能删除多级目录，如果传入参数是多级目录，<strong>仅仅会删除掉最后一级目录。</strong></p>
<h2 id="递归删除多级空目录"><a href="#递归删除多级空目录" class="headerlink" title="递归删除多级空目录"></a>递归删除多级空目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.removedirs(path)</span><br></pre></td></tr></table></figure>
<p>同样，<strong>要求目录为空</strong></p>
<h3 id="列出包含的文件或者文件夹列表"><a href="#列出包含的文件或者文件夹列表" class="headerlink" title="列出包含的文件或者文件夹列表"></a>列出包含的文件或者文件夹列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.listdir(path)</span><br></pre></td></tr></table></figure>
<p>列表以字母顺序。 它不包括 . 和 .. 即使它在文件夹中。</p>
<h3 id="删除指定路径的文件"><a href="#删除指定路径的文件" class="headerlink" title="删除指定路径的文件"></a>删除指定路径的文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(path)</span><br></pre></td></tr></table></figure>
<p>path指向的路径<strong>必须是文件</strong>，如果指定的路径是一个目录，将抛出OSError。</p>
<h3 id="重命名文件或者目录"><a href="#重命名文件或者目录" class="headerlink" title="重命名文件或者目录"></a>重命名文件或者目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(src, dst)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>src</strong> — 要修改的目录名或者文件路径</p>
</li>
<li><p><strong>dst</strong> — 修改后的目录名或者文件路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要创建的目录路径</span></span><br><span class="line">path = <span class="string">&quot;aa/bb/cc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">os.makedirs(path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改目录名称</span></span><br><span class="line">os.renames(path,<span class="string">&#x27;1/2/3&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="检查访问权限"><a href="#检查访问权限" class="headerlink" title="检查访问权限"></a>检查访问权限</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.access(path, mode);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>path</strong> — 要用来检测是否有访问权限的路径。</p>
</li>
<li><p><strong>mode</strong> — <code>mode</code>为<code>F_OK</code>，测试存在的路径，或者它可以是包含<code>R_OK</code>, <code>W_OK</code>和<code>X_OK</code>或者<code>R_OK</code>, <code>W_OK</code>和<code>X_OK</code>其中之一或者更多。</p>
<ul>
<li><strong>os.F_OK:</strong> 作为<code>access()</code>的<code>mode</code>参数，测试<code>path</code>是否存在。</li>
<li><strong>os.R_OK:</strong> 包含在<code>access()</code>的<code>mode</code>参数中 ， 测试<code>path</code>是否可读。</li>
<li><strong>os.W_OK</strong> 包含在<code>access()</code>的<code>mode</code>参数中 ， 测试<code>path</code>是否可写。</li>
<li><strong>os.X_OK</strong> 包含在<code>access()</code>的<code>mode</code>参数中 ，测试<code>path</code>是否可执行。</li>
</ul>
</li>
</ul>
<h3 id="更改文件或目录的权限"><a href="#更改文件或目录的权限" class="headerlink" title="更改文件或目录的权限"></a>更改文件或目录的权限</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chmod(path, mode)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>path</strong> — 文件名路径或目录路径。</p>
</li>
<li><p><strong>flags</strong> — 可用以下选项按位或操作生成， 目录的读权限表示可以获取目录里文件名列表， ，执行权限表示可以把工作目录切换到此目录 ，删除添加目录里的文件必须同时有写和执行权限 ，文件权限以用户id-&gt;组id-&gt;其它顺序检验,最先匹配的允许或禁止权限被应用。</p>
<ul>
<li><strong>stat.S_IXOTH:</strong> 其他用户有执行权0o001</li>
<li><strong>stat.S_IWOTH:</strong> 其他用户有写权限0o002</li>
<li><strong>stat.S_IROTH:</strong> 其他用户有读权限0o004</li>
<li><strong>stat.S_IRWXO:</strong> 其他用户有全部权限(权限掩码)0o007</li>
<li><strong>stat.S_IXGRP:</strong> 组用户有执行权限0o010</li>
<li><strong>stat.S_IWGRP:</strong> 组用户有写权限0o020</li>
<li><strong>stat.S_IRGRP:</strong> 组用户有读权限0o040</li>
<li><strong>stat.S_IRWXG:</strong> 组用户有全部权限(权限掩码)0o070</li>
<li><strong>stat.S_IXUSR:</strong> 拥有者具有执行权限0o100</li>
<li><strong>stat.S_IWUSR:</strong> 拥有者具有写权限0o200</li>
<li><strong>stat.S_IRUSR:</strong> 拥有者具有读权限0o400</li>
<li><strong>stat.S_IRWXU:</strong> 拥有者有全部权限(权限掩码)0o700</li>
<li><strong>stat.S_ISVTX:</strong> 目录里文件目录只有拥有者才可删除更改0o1000</li>
<li><strong>stat.S_ISGID:</strong> 执行此文件其进程有效组为文件所在组0o2000</li>
<li><strong>stat.S_ISUID:</strong> 执行此文件其进程有效用户为文件所有者0o4000</li>
<li><strong>stat.S_IREAD:</strong> windows下设为只读</li>
<li><strong>stat.S_IWRITE:</strong> windows下取消只读</li>
</ul>
</li>
</ul>
<h3 id="获取文件或者目录的状态信息"><a href="#获取文件或者目录的状态信息" class="headerlink" title="获取文件或者目录的状态信息"></a>获取文件或者目录的状态信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.stat(path)</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>stat 结构:</p>
<ul>
<li><strong>st_mode:</strong> inode 保护模式</li>
<li><strong>st_ino:</strong> inode 节点号。</li>
<li><strong>st_dev:</strong> inode 驻留的设备。</li>
<li><strong>st_nlink:</strong> inode 的链接数。</li>
<li><strong>st_uid:</strong> 所有者的用户ID。</li>
<li><strong>st_gid:</strong> 所有者的组ID。</li>
<li><strong>st_size:</strong> 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。</li>
<li><strong>st_atime:</strong> 上次访问的时间。</li>
<li><strong>st_mtime:</strong> 最后一次修改的时间。</li>
<li><strong>st_ctime:</strong> 由操作系统报告的”ctime”。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。</li>
</ul>
<h3 id="遍历指定目录及其所有子目录"><a href="#遍历指定目录及其所有子目录" class="headerlink" title="遍历指定目录及其所有子目录"></a>遍历指定目录及其所有子目录</h3><p><code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p><strong>top</strong> — 是你所要遍历的目录的地址, 返回的是一个三元组(root,dirs,files)。</p>
<ul>
<li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li>
<li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li>
<li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li>
</ul>
</li>
<li><p><strong>topdown</strong> —可选，为 True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。如果 topdown 参数为 True，walk 会遍历top文件夹，与top 文件夹中每一个子目录。</p>
</li>
<li><p><strong>onerror</strong> — 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。</p>
</li>
<li><p><strong>followlinks</strong> — 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。</p>
</li>
</ul>
<p><strong>返回生成器。</strong></p>
<p>假设我们有下面的目录结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+--A</span><br><span class="line">| +--B3</span><br><span class="line">| | +--C0</span><br><span class="line">| | | +--Dt0.txt</span><br><span class="line">| | +--Ct0.txt</span><br><span class="line">| | +--Ct1.txt</span><br><span class="line">| +--B4</span><br><span class="line">| | +--C1</span><br><span class="line">| | | +--Dt1.txt</span><br><span class="line">| | +--Ct2.txt</span><br><span class="line">| +--Bt0.txt</span><br><span class="line">| +--Bt1.txt</span><br></pre></td></tr></table></figure>
<p>其中A文件夹和执行程序的Python文件放在同一个目录下面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_path=<span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="comment"># 查看返回的三元组</span></span><br><span class="line">tri_tuple=os.walk(start_path)</span><br><span class="line">tri_tuple_list=<span class="built_in">list</span>(tri_tuple)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;返回的三元组转化为列表&#x27;</span>.center(<span class="number">20</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(tri_tuple_list)</span><br><span class="line"><span class="comment"># 输出：[(&#x27;A&#x27;, [&#x27;B3&#x27;, &#x27;B4&#x27;], [&#x27;Bt0.txt&#x27;, &#x27;Bt1.txt&#x27;]), (&#x27;A\\B3&#x27;, [&#x27;C0&#x27;], [&#x27;Ct0.txt&#x27;, &#x27;Ct1.txt&#x27;]), (&#x27;A\\B3\\C0&#x27;, [], [&#x27;Dt0.txt&#x27;]), (&#x27;A\\B4&#x27;, [&#x27;C1&#x27;], [&#x27;Ct2.txt&#x27;]), (&#x27;A\\B4\\C1&#x27;, [], [&#x27;Dt1.txt&#x27;])]</span></span><br></pre></td></tr></table></figure>
<h4 id="将三元组分别转化为列表打印输出"><a href="#将三元组分别转化为列表打印输出" class="headerlink" title="将三元组分别转化为列表打印输出"></a>将三元组分别转化为列表打印输出</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_path=<span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">root_list=[root <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(start_path)]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;root_list:&#x27;</span>,root_list)</span><br><span class="line"><span class="comment"># 输出:root_list: [&#x27;A&#x27;, &#x27;A\\B3&#x27;, &#x27;A\\B3\\C0&#x27;, &#x27;A\\B4&#x27;, &#x27;A\\B4\\C1&#x27;]</span></span><br><span class="line"></span><br><span class="line">dirs_list=[dirs <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(start_path)]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dirs_list:&#x27;</span>,dirs_list)</span><br><span class="line"><span class="comment"># 输出：dirs_list: [[&#x27;B3&#x27;, &#x27;B4&#x27;], [&#x27;C0&#x27;], [], [&#x27;C1&#x27;], []]</span></span><br><span class="line"></span><br><span class="line">files_list=[files <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(start_path)]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;files_list:&#x27;</span>,files_list)</span><br><span class="line"><span class="comment"># 输出：files_list: [[&#x27;Bt0.txt&#x27;, &#x27;Bt1.txt&#x27;], [&#x27;Ct0.txt&#x27;, &#x27;Ct1.txt&#x27;], [&#x27;Dt0.txt&#x27;], [&#x27;Ct2.txt&#x27;], [&#x27;Dt1.txt&#x27;]]</span></span><br></pre></td></tr></table></figure>
<h4 id="过滤特定格式文件"><a href="#过滤特定格式文件" class="headerlink" title="过滤特定格式文件"></a>过滤特定格式文件</h4><p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_path=<span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(start_path):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(os.path.join(root, file)</span><br></pre></td></tr></table></figure>
<h1 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h1><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><ul>
<li><p><a href="https://www.runoob.com/python3/python3-os-file-methods.html">Python3 OS 文件/目录方法 | 菜鸟教程</a></p>
</li>
<li><p><a href="https://geek-docs.com/python/python-os-module/os-module-python-examples.html">Python OS模块|极客教程</a></p>
</li>
<li><p><a href="https://it1314.top/article/936/">Pycharm 控制台中文乱码的四种解决方案，统一设置 UTF-8 - 计算机毕业设计源码网</a></p>
</li>
<li><p><a href="https://blog.csdn.net/miracleoa/article/details/106115730">【anaconda】conda创建、查看、删除虚拟环境（anaconda命令集）_conda 创建环境-CSDN博客</a></p>
</li>
<li><p><a href="https://geek-docs.com/python/python-ask-answer/128_tk_1704195262.html">Python platform模块|极客教程</a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/os.path.html">https://docs.python.org/zh-cn/3/library/os.path.html</a></p>
</li>
<li><p><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/io/file-path-formats">Windows 系统中的文件路径格式 - .NET | Microsoft Learn</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xixihahalelehehe/article/details/104253123?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8%3D">python os模块文件目录操作详解_python os加载目录-CSDN博客</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>os库</tag>
        <tag>pathlib库</tag>
        <tag>编码</tag>
        <tag>utf-8</tag>
        <tag>sys</tag>
        <tag>platfrom库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redefine文章加密测试</title>
    <url>/2024/07/28/Redefine%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="测试文章，仅仅用于加密"><a href="#测试文章，仅仅用于加密" class="headerlink" title="测试文章，仅仅用于加密"></a>测试文章，仅仅用于加密</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redefine</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>butterfly加密教程</title>
    <url>/2024/07/30/butterfly%E5%8A%A0%E5%AF%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考教程：</p>
<p><a href="https://ouoholly.github.io/post/my-custom-config-on-hexo-butterfly-theme/#%E7%89%88%E6%AC%8A%E6%A1%86%E5%85%A7%E7%9A%84%E5%AD%97%E5%8F%A5">butterfly文章加密教程</a></p>
<ul>
<li><p>首先，在根目录下按装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后再文章的font-matter加上password和massage就可以。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>加密</tag>
        <tag>测试</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>古詩</title>
    <url>/2024/10/07/%E5%8F%A4%E8%A9%A9/</url>
    <content><![CDATA[<h1 id="寫在前面"><a href="#寫在前面" class="headerlink" title="寫在前面"></a>寫在前面</h1><p>本文主要是對於我讀過古詩的摘抄。</p>

<div class="poem">
    春眠不觉晓，<br>
    处处闻啼鸟。<br>
    夜来风雨声，<br>
    花落知多少。
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br><span class="line">&#123;% poem &#123;擬古&#125;,&#123;李白&#125; %&#125;</span><br><span class="line">生者爲過客，死者爲歸人。</span><br><span class="line">天地一逆旅，同悲萬古塵。</span><br><span class="line">月兔空搗藥，扶桑已成薪。</span><br><span class="line">白骨寂無言，青松豈知春。</span><br><span class="line">前後更嘆息，浮榮安足珍。</span><br><span class="line">&#123;% endpoem %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% poem 孟冬寒气至,古詩十九首 %&#125;</span><br><span class="line"></span><br><span class="line">孟冬寒气至，北风何惨慄。</span><br><span class="line">愁多知夜长，仰观众星列。</span><br><span class="line">三五明月满，四五詹免缺。</span><br><span class="line">客从远方来，遗我一书札。</span><br><span class="line">上言长相思，下言久离别。</span><br><span class="line">置书怀袖中，三岁字不灭。</span><br><span class="line">一心抱区区别，惧君不识察。</span><br><span class="line">&#123;% endpoem %&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="擬古"><a href="#擬古" class="headerlink" title="擬古"></a>擬古</h1><h1 id="孟冬寒气至"><a href="#孟冬寒气至" class="headerlink" title="孟冬寒气至"></a>孟冬寒气至</h1><div class='poem'><div class='poem-title'>孟冬寒气至</div><div class='poem-author'>古詩十九首</div><p>孟冬寒气至，北风何惨慄。<br>愁多知夜长，仰观众星列。<br>三五明月满，四五詹免缺。<br>客从远方来，遗我一书札。<br>上言长相思，下言久离别。<br>置书怀袖中，三岁字不灭。<br>一心抱区区别，惧君不识察。</p>
</div>
<div style="text-align: center; font-size: 24px; color: #f13c22;">
    十五從軍征
</div>
<div style="text-align: center; font-size: 20px; color: #1ba784;">
    十五從軍征，八十始得歸。<br>
    道逢鄉里人：家中有阿誰？<br>
    遙望是君家，松柏冢累累。<br>
    兔從狗竇入，雉從梁上飛。<br>
    中庭生旅穀，井上生旅葵。<br>
    舂穀持作飯，采葵持作羹。<br>
    羹飯一時熟，不知貽阿誰！<br>
    出門東向看，淚落沾我衣。
</div>
]]></content>
      <categories>
        <category>余</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
        <tag>古诗</tag>
      </tags>
  </entry>
  <entry>
    <title>复变函数chap3——复积分</title>
    <url>/2024/07/07/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0chap3%E2%80%94%E2%80%94%E5%A4%8D%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<ul>
<li><h1 id="复积分的定义和计算"><a href="#复积分的定义和计算" class="headerlink" title="复积分的定义和计算"></a>复积分的定义和计算</h1><ul>
<li><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2></li>
</ul>
<script type="math/tex; mode=display">
\int_C f(z)\mathrm{d}z=\displaystyle \lim_{\lambda \to 0}\sum_{k=1}^n f(\zeta_k)\Delta z_k</script><ul>
<li><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ul>
<li><p>$\int_C f(z)\mathrm{d}z=\int_a^b f(z(t))z’(t)\mathrm{d}t$</p>
</li>
<li><p>$\int_C f(z)\mathrm{d}z=\int_C u\mathrm{d}x-v\mathrm{d}y+i\int_C v\mathrm{d}y+u\mathrm{d}y$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="闭路变形原理"><a href="#闭路变形原理" class="headerlink" title="闭路变形原理"></a>闭路变形原理</h1><p>区域内一个解析函数沿闭曲线的积分，不因闭曲线在区域内作连续变形而改变它的值，只要变形过程中不经过不解析的点。</p>
</li>
<li><h1 id="复合闭路定理"><a href="#复合闭路定理" class="headerlink" title="复合闭路定理"></a>复合闭路定理</h1><p>设$C$为多连通域$D$内的一条简单闭曲线,$C_1,C_2,…,C_n$是在C 内部的简单闭曲线,它们互不包含也互不相交,并且以$C1​,C2​,…,Cn​$为边界的区域全含于$ D$ 中(见图 3.5),如果 $f(z)$在$D$内解析,那么</p>
<ul>
<li><script type="math/tex; mode=display">
f(z)\mathrm{d}z=\displaystyle ∑_{k=1}^{n}\oint_{C_k}f(z)\mathrm{d}z</script><p>其中$C$及$C $均取正方向;    </p>
</li>
</ul>
</li>
<li><p>$\ f(z)dz=0$,这里$\Gamma$为由$C$及$C_k (k=1,2,…,)$所组成的复合闭路,其方向是$C $为逆时针方向, $C_k$为顺时针方向</p>
<p><img src="https://s2.loli.net/2024/07/08/3Mi61yqrxQhEO2z.jpg" title="" alt="" data-align="center"></p>
</li>
<li><h1 id="柯西-古萨定理"><a href="#柯西-古萨定理" class="headerlink" title="柯西-古萨定理"></a>柯西-古萨定理</h1><p>又叫做柯西积分定理</p>
<p>如果函数$f(z)$在单连通域 $B$内处处解析,那末函数$f(z)$沿 $B$内的任何一条封闭曲线$C$的积分为零:</p>
<script type="math/tex; mode=display">
\oint_C f(x) dz=0</script><h1 id="柯西积分公式"><a href="#柯西积分公式" class="headerlink" title="柯西积分公式"></a>柯西积分公式</h1></li>
<li><p>如果函数$f(z)$在区域 $D$内处处解析,$C$为$D$内的任何一条正向简单闭曲线,它的内部完全含于$D$,$z_0$为$C$内任一点，则：</p>
<script type="math/tex; mode=display">
f(z_0)=\frac{1}{2 \pi i}\oint_C \frac{f(z)}{z-z_0} dz</script></li>
<li><h1 id="解析函数的高阶导数"><a href="#解析函数的高阶导数" class="headerlink" title="解析函数的高阶导数"></a>解析函数的高阶导数</h1><p>解析函数 $f(z)$的导数仍为解析函数,它的$n$阶导数为：</p>
<script type="math/tex; mode=display">
f^{(n)}(z)=\frac{n!}{2 \pi i}\oint_C \frac{f(z)}{(z-z_0)^{n+1}}\mathrm{d}z \\(n=1,2,...)</script><p>其中$C$ 为在函数$f(z)$的解析区域 $D$内围绕$z$ 的任何一条正向简单闭曲线,而且它的内部全含于$D$.     </p>
</li>
<li><h1 id="柯西不等式"><a href="#柯西不等式" class="headerlink" title="柯西不等式"></a>柯西不等式</h1><p>设函数$f(z)$在$|z-z_0|&lt;R$区域内解析，且$|f(z)\leq M$在$|z-z_0|&lt;R $内成立,则下列不等式成立：</p>
<script type="math/tex; mode=display">
|f^{n}(z_0)|\leq \frac{n! M}{R^n},n=1,2,\cdots</script></li>
<li><h1 id="刘维尔定理"><a href="#刘维尔定理" class="headerlink" title="刘维尔定理"></a>刘维尔定理</h1><p>设$f(z)$在全平面上解析，并且有界，则$f(z)$为常数。</p>
</li>
<li><h1 id="调和函数-amp-共轭调和函数"><a href="#调和函数-amp-共轭调和函数" class="headerlink" title="调和函数&amp;共轭调和函数"></a>调和函数&amp;共轭调和函数</h1><ul>
<li><h2 id="调和函数"><a href="#调和函数" class="headerlink" title="调和函数"></a>调和函数</h2><p>有二阶连续偏导，且满足拉普拉斯方程的函数被称为调和函数</p>
<script type="math/tex; mode=display">
\frac{\partial^2 f}{\partial x_1^2}+\frac{\partial^2 f}{\partial x_1^2}+\cdots+\frac{\partial^2 f}{\partial x_n^2}=0</script><p>或者下面的表述：</p>
<p>$\nabla^2f=0$,即$\Delta f=0$</p>
<p>如果二元实函数$H(x,y)$在区域$D$内有二阶连续偏导数,且满足拉普拉斯方程$\Delta H=0$,则称$H(x,y)$为区域$D$内的调和函数</p>
</li>
</ul>
</li>
<li><h2 id="共轭调和函数"><a href="#共轭调和函数" class="headerlink" title="共轭调和函数"></a>共轭调和函数</h2><p>对于$u(x,y)$,如果存在$v(x,y)$,使得$f(z)=u+vi$为解析函数，则$v$为$u$的共轭调和函数。（共轭调和函数并不是对称的，上述定义中，$u$未必是$v$的共轭调和函数） </p>
</li>
<li><h2 id="共轭调和函数和解析函数的性质"><a href="#共轭调和函数和解析函数的性质" class="headerlink" title="共轭调和函数和解析函数的性质"></a>共轭调和函数和解析函数的性质</h2><center>$f(z)=u(x,y)+iu(x,y)$在区域$ D$内解析 </center>

<script type="math/tex; mode=display">
\iff</script><center> 在区域$D$内$v(x,y)$是$u(x,y)$的共轭调和函数</center>
</li>
<li><h2 id="求解共轭调和函数"><a href="#求解共轭调和函数" class="headerlink" title="求解共轭调和函数"></a>求解共轭调和函数</h2><p>有以下三种思路：</p>
<ul>
<li><h3 id="偏积分法"><a href="#偏积分法" class="headerlink" title="偏积分法"></a>偏积分法</h3><p>根据柯西-黎曼方程，$\frac{\partial v}{\partial y}=\frac{\partial u}{\partial x}$,于是对$y$积分，得到</p>
<script type="math/tex; mode=display">
v=\int \frac{\partial u}{\partial x} \mathrm {d}y+g(x) \tag{1}</script><p>其中$g(x)$是一个关于$x$的函数。</p>
<p>再由柯西-黎曼方程，</p>
<script type="math/tex; mode=display">
\frac{\partial v}{\partial x}=-\frac{\partial u}{\partial y} \tag{2}</script></li>
<li><h3 id="不定积分法"><a href="#不定积分法" class="headerlink" title="不定积分法"></a>不定积分法</h3><p>根据柯西-黎曼方程，</p>
<script type="math/tex; mode=display">
f(z)=\frac{\partial u}{\partial x}+i\frac{\partial v}{\partial x} \tag{3}</script><p>或者</p>
<script type="math/tex; mode=display">
f(z)=\frac{\partial v}{\partial y}-i\frac{\partial v}{\partial y}\tag{4}</script><p>在$(3)$或者$(4)$中任意一个式子，把$x$和$y$用下面的方程代换为$z$:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">x=<span class="keyword">\frac</span>&#123;z+<span class="keyword">\bar</span>&#123;z&#125;&#125;&#123;2&#125;<span class="keyword">\\</span></span><br><span class="line">y=<span class="keyword">\frac</span>&#123;z-<span class="keyword">\bar</span>&#123;z&#125;&#125;&#123;2i&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
x=\frac{z+\bar{z}}{2}\\
y=\frac{z-\bar{z}}{2i}\\
\end{aligned}
\right.</script><p>就可以得到一个$U(z)$或者$V(z)$，此时只需要对$U(z)$或者$V(z)$积分，即可得到$f(z)$,有了$f(z)$,$v(z)$也就可以得到了 。   </p>
</li>
<li><h3 id="全微分法"><a href="#全微分法" class="headerlink" title="全微分法"></a>全微分法</h3><p>这个方法类似于微分方程中的全微分法，考察观察能力。</p>
<p>在已经知道$u(x,y)$的情况下，对$u$全微分，结合柯西-黎曼方程，得到下面的式子：</p>
<script type="math/tex; mode=display">
\mathrm{d}v=\frac{\partial v}{\partial x}\mathrm{d}x+\frac{\partial v}{\partial y}\mathrm{d}y=-\frac{\partial u}{\partial y}\mathrm{d}x+\frac{\partial u}{\partial x}\mathrm{d}y</script><p>如果可以观察出$-\frac{\partial u}{\partial y}\mathrm{d}x+\frac{\partial u}{\partial x}\mathrm{d}y$是哪个二元函数的全微分，就可以直接得出答案。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>柯西-黎曼方程</tag>
        <tag>复积分</tag>
        <tag>调和函数</tag>
        <tag>调和共轭</tag>
        <tag>刘维尔定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Tableau学习笔记</title>
    <url>/2024/08/16/Tableau%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>sticky是<code>sticky</code> 值越大，顶置的文章越靠前</p>
</li>
<li><p>thumbnail: “IMAGE_LINK”</p>
<p>redefine对首页文章添加缩略图</p>
</li>
<li><p>摘要</p>
<p>excerpt: “这是文章摘要 This is the excerpt of the post”或者直接设置为false</p>
</li>
<li><p>massage: 文章的密码的提示，但是似乎没有什么用，总是显示Hey,password is required here.</p>
</li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><p>导入数据之后要新建工作表，工作表是一切的基础</p>
</li>
<li><p>工作表中，左侧的数据，有维度型和度量型之分，分别是字符串类型和数值类型。</p>
</li>
<li><p>工作表中，列对应横坐标，行对应纵坐标</p>
</li>
<li><p>清除工作表点上方的x</p>
</li>
<li><p>右键点击下面一个工作表，拷贝就是简单的复制，复制是复制之后粘贴了，作为一个新的工作表。</p>
</li>
<li><p>如果要更改轴上刻度的名称，可以右键，编辑别名。</p>
</li>
<li><p>自动拆分：导入数据后点击一个sheet，预览之后，可以右键点击一列，如果你的这一列数据满足特定格式(比如“姓名-学号”)可以自动拆分。新增两列。</p>
</li>
<li><p>还可以自定义拆分</p>
</li>
<li><p>删除缺失数据，在轴的刻度，找到Null，右键，排除</p>
</li>
<li><p>改变轴标签：双击你要改的轴的轴标签，在轴标题中更改。</p>
</li>
<li><p>做标记：在需要做标记的点或者是区域，右键，添加注释，标记。可以设置参数，包括字体，大小，线形，箭头，颜色等。</p>
</li>
<li><p>如果有某一个量本来应该是度量值，但是是在维度值得区域，可以直接拖放。</p>
</li>
<li><p>标记的数字如果位数太长了，可以在标记栏中选择你添加的量，右键，设置格式，默认值，数字(自定义)，显示单位，改成一个较大的单位就可以了。</p>
</li>
<li><p>关于日期</p>
<ul>
<li>一旦将一个量改成日期格式，在工作表中拖动的时候，可以改成按照月份显示，如果我们在很多年中筛选出了某一年，想观察更加细微的变化，可以用这个操作。</li>
</ul>
</li>
<li><p>在起始页添加新的excel文件，不会使得两个文件合并。</p>
</li>
<li><p>编辑说明，在标记栏的灰色区域，右键，说明，即可显示说明，双击说明区域，即可编辑。</p>
</li>
<li><p>导出文件，可以在最上方的点击工作表，导出，选择你要导出的部分，即可。</p>
</li>
<li><p>想要编辑标签的字体，大小，可以在标记栏中，找到标签，单击 即可。</p>
</li>
</ul>
<h1 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h1><ul>
<li><p>统计频次，找不到对应的量，可以用度量型数据中的记录数表示。</p>
</li>
<li><p>上方图标可以选择降序升序排列。</p>
</li>
<li><p>交换行和列可以让图变成横着的条形图</p>
</li>
<li><p>如果显示的是“其他地区”，而没有显示全部的地区，可以在图标栏将“标准”改为“整个视图”，以显示所有</p>
</li>
<li><p>如果条形图中，每一个小条条上面光秃秃，没有具体的数值，需要显示话，可以把“记录数”拖放到“标记”栏中的“标签”</p>
</li>
<li><p>如果发现数值过大，可能是纵轴的量，求的是总和，这时候需要在拖放到行的哪个绿色的量，右键，度量，选择平均值。</p>
<p>如果标签的数值，也是求得平均值，也可以在标签栏中，按照上述操作。</p>
</li>
</ul>
<h1 id="堆积柱形图"><a href="#堆积柱形图" class="headerlink" title="堆积柱形图"></a>堆积柱形图</h1><p>先建立好条形图，复制之后，在新的条形图中，把你要堆积的量，拖动到“标记”栏中的“颜色”</p>
<h1 id="直方图（统计分布区间）"><a href="#直方图（统计分布区间）" class="headerlink" title="直方图（统计分布区间）"></a>直方图（统计分布区间）</h1><p>直方图只能竖着看。</p>
<p>绘制步骤：</p>
<p>把你要统计的量右键单击，选择创建，数据桶，设定好参数之后，如果名字是”xxx(数据桶）”，就找到创建好的”xxx(数据桶）”拖放到列，把记录数拖放到行，即可创建。</p>
<p>下面的轴刻度默认是左闭右开区间的左端点。</p>
<h1 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h1><p>可以自动拖放，如果想把两个折线放到一个图里面，可以直接拖放两个到行字段。</p>
<p>如果想设置双轴，一左一右，可以直接完成上一行的操作后，随便点一个轴，右键，双轴，即可。</p>
<h1 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h1><p>将需要绘制饼图的量拖动到列，将记录数拖动到行，此时软件会默认绘制出来条形图，点击右上角的智能显示，找到饼图图标，单击，即可。</p>
<p>添加标签之后，如果想修改标签为百分比，而不是具体的数值，需要在标记栏中找到总和（记录数），右键，快速表计算，合计百分比，即可。</p>
<h1 id="环形图"><a href="#环形图" class="headerlink" title="环形图"></a>环形图</h1><h2 id="方法一（手动）"><a href="#方法一（手动）" class="headerlink" title="方法一（手动）"></a>方法一（手动）</h2><p>先做饼图，在标记选择“饼图”，把这个量拖放到标记栏中的“颜色”。此时的饼图是N等分的。然后将“记录数”拖放到标记栏中的“角度”</p>
<p>接着我们要做两个一样的圆，把记录数放到行，度量选择最小值（最大值也行），然后重复这样的操作，得到行里面是有两个一样的记录数，然后在标记栏里找到其中的一个图，调整的大一点，回到工作表，接着选择双轴，于是这两个图重合。</p>
<p>然后在标记栏中找到较小的那个图，删除掉你要现实的那个量（而不是总和（记录数）），于是右侧的图中间变成灰色。接着在左侧标记栏中，选择颜色，改为白色就可以了。</p>
<p>如果想外侧显示百分比，内侧显示总的数量，外侧的标签还是正常操作，内侧的总和数量，需要把“记录数”拖放到标记栏中较小的哪个图的“标签”中</p>
<p><style>.fxnbkmnyvnyt{}</style><img src="/2024/08/16/Tableau%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2024-08-23-13-08-42-image.png" class="fxnbkmnyvnyt"></p>
<h2 id="智能显示"><a href="#智能显示" class="headerlink" title="智能显示"></a>智能显示</h2><p>和手动的大同小异，只不过需要在标记栏中，拖动好两个最小的记录数后，把这两个图中的有大小关联的记录数清除掉。</p>
<p><style>.crtrbczeycqq{}</style><img src="/2024/08/16/Tableau%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2024-08-23-13-21-06-image.png" class="crtrbczeycqq"></p>
<h1 id="基本表和凸显表"><a href="#基本表和凸显表" class="headerlink" title="基本表和凸显表"></a>基本表和凸显表</h1><h2 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h2><p>把显示的地区拖放到行，把记录数拖放到标记栏中的文本。</p>
<h2 id="凸显表"><a href="#凸显表" class="headerlink" title="凸显表"></a>凸显表</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>创建基本表后，在智能显示中，选择凸显表。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>创建基本表后，把记录数拖放到标记栏中的颜色，把形状改为方形。</p>
<h2 id="二级凸显表"><a href="#二级凸显表" class="headerlink" title="二级凸显表"></a>二级凸显表</h2><p>即以某一个值为分界线，两种颜色的凸显表。</p>
<p>需要选择方形。</p>
<p>编辑栏中选择颜色，色板中选择一个带有“发散”字样的颜色，勾选渐变颜色后，阶数就是颜色一共有多少种，中心勾选后中心就是分界线。</p>
<h1 id="树状图"><a href="#树状图" class="headerlink" title="树状图"></a>树状图</h1><p>类似于七巧板。</p>
<p>也支持把数值拖放到标记栏中的标签。</p>
<h2 id="两个维度"><a href="#两个维度" class="headerlink" title="两个维度"></a>两个维度</h2><p>类似于绘制好条形图之后，在智能显示中，选择树形图，就可以了。如果选择了维度是2，那么矩形的面积和颜色深浅都是由第二个维度决定的。</p>
<h3 id="三个维度的树状图"><a href="#三个维度的树状图" class="headerlink" title="三个维度的树状图"></a>三个维度的树状图</h3><p>以“不同类型的典型数量和票房”为例，可以先做出来类型和数量的树状图，然后再左侧的标记栏中，把颜色的数量标记给删除，把票房标记，拖动到颜色中，即可。</p>
<h2 id="有的矩形太小了"><a href="#有的矩形太小了" class="headerlink" title="有的矩形太小了"></a>有的矩形太小了</h2><p>矩形太小，可以用筛选器，直接右键，单击筛选器，便可以拖动调整范围。</p>
<h1 id="气泡图"><a href="#气泡图" class="headerlink" title="气泡图"></a>气泡图</h1><p>智能显示中选择“气泡图”就行，其他的不用改。</p>
<h2 id="动态气泡图"><a href="#动态气泡图" class="headerlink" title="动态气泡图"></a>动态气泡图</h2><p>指定一个随时间变化的量，比如说日期，把他拖放到“页面”中，然后把需要显示的横轴和纵轴 分别拖动到列和行，然后标记选择形状后，在多出来的形状点击，选择空心圆。</p>
<p>在显示历史标记，如果勾选，可以显示轨迹。</p>
<h2 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h2><p>生成气泡图后，在标记栏里面把形状改成“文本”即可。</p>
<h1 id="标靶图"><a href="#标靶图" class="headerlink" title="标靶图"></a>标靶图</h1><p>选中某一个轴的标签，右键，添加参考线，可以添加。</p>
<p>每一个区代表拖动到行里面的每一个量</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Tableau</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式测试</title>
    <url>/2024/07/08/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>测试下面的公式是否可以正常运行</p>
<p>$\sin(x+y)=\sin x \cos y+\cos x \sin y$</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>级数</tag>
        <tag>洛朗级数</tag>
      </tags>
  </entry>
  <entry>
    <title>复变函数chap4——级数</title>
    <url>/2024/07/08/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0chap4%E2%80%94%E2%80%94%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<h1 id="收敛的条件"><a href="#收敛的条件" class="headerlink" title="收敛的条件"></a>收敛的条件</h1><h2 id="充要条件"><a href="#充要条件" class="headerlink" title="充要条件"></a>充要条件</h2><p>级数$\displaystyle\sum<em>{n=1}^{\infty}z_n$收敛的充要条件是$\displaystyle\sum</em>{n=1}^{\infty}x<em>n$和$\displaystyle\sum</em>{n=1}^{\infty}y_n$都收敛</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>级数$\displaystyle\sum<em>{n=1}^{\infty}z_n$收敛的必要条件是$\displaystyle\lim</em>{n \to \infty}z_n=0$</p>
<h1 id="两种判别法"><a href="#两种判别法" class="headerlink" title="两种判别法"></a>两种判别法</h1><h2 id="比值判别法"><a href="#比值判别法" class="headerlink" title="比值判别法"></a>比值判别法</h2><p>若$\displaystyle\lim<em>{n \to \infty}\lvert \dfrac{C</em>{n+1}}{C<em>n}\rvert=\lambda$，则$\displaystyle\sum</em>{n=1}^{\infty}C_n(z-z_0)^n$的收敛半径$R=\dfrac{1}{\lambda}$</p>
<h2 id="根值判别法"><a href="#根值判别法" class="headerlink" title="根值判别法"></a>根值判别法</h2><p>设$\displaystyle \lim<em>{n \to \infty}\sqrt[n]{\lvert C_n\rvert}=\lambda$,则级数$\displaystyle\sum</em>{n=1}^{\infty}C_n(z-z_0)^n$的收敛半径为$R=\dfrac{1}{\lambda}$</p>
<h1 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h1><h2 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h2><p>设函数$f(z)$在区域$D$内解析，$z_0$为$D$内的一点，$R$为$z_0$ 到$D$的边界上各点的<strong>最短距离</strong>，则当$\lvert z-z_0 \rvert &lt;R$时，$f(z)$可以展开为幂级数：</p>
<script type="math/tex; mode=display">
\displaystyle f(z)=\displaystyle\sum_{n=1}^{\infty}C_n(z-z_0)^n</script><p>其中$C_n=\dfrac{1}{n!}f^{(n)}(z_0) ,n=0,1,2,\cdots$</p>
<h2 id="解析性和幂级数"><a href="#解析性和幂级数" class="headerlink" title="解析性和幂级数"></a>解析性和幂级数</h2><p>函数在一点解析的<strong>充要条件</strong>是它在这一点的邻域内可以展开为幂级数。</p>
<h2 id="若干函数的麦克劳林展开"><a href="#若干函数的麦克劳林展开" class="headerlink" title="若干函数的麦克劳林展开"></a>若干函数的麦克劳林展开</h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><script type="math/tex; mode=display">
\displaystyle \sin z=\sum_{n=0}^{\infty}(-1)^n \dfrac{z^{2n+1}}{(2n+1)!} \qquad\lvert z\rvert<+\infty</script><h3 id="余弦函数"><a href="#余弦函数" class="headerlink" title="余弦函数"></a>余弦函数</h3><script type="math/tex; mode=display">
\displaystyle \cos z=\sum_{n=0}^{\infty}(-1)^n \dfrac{z^{2n}}{(2n)!}\qquad\lvert z\rvert<+\infty</script><h3 id="displaystyle-dfrac-1-1-z-和-displaystyle-dfrac-1-1-z"><a href="#displaystyle-dfrac-1-1-z-和-displaystyle-dfrac-1-1-z" class="headerlink" title="$\displaystyle \dfrac{1}{1-z}$和$\displaystyle \dfrac{1}{1+z}$"></a>$\displaystyle \dfrac{1}{1-z}$和$\displaystyle \dfrac{1}{1+z}$</h3><script type="math/tex; mode=display">
\displaystyle \dfrac{1}{1-z}=\sum_{n=0}^{\infty} z^n\qquad \lvert z\rvert<+\infty</script><script type="math/tex; mode=display">
\displaystyle \dfrac{1}{1+z}=\sum_{n=0}^{\infty}(-1)^n z^n\qquad \lvert z\rvert<+\infty</script><h3 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h3><script type="math/tex; mode=display">
\displaystyle \mathrm{e}^z=\sum_{n=0}^{\infty} \dfrac{z^n}{n!}\qquad \lvert z\rvert<+\infty</script><h3 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h3><script type="math/tex; mode=display">
\displaystyle \ln(1+z)=\sum_{n=0}^{\infty} (-1)^n\dfrac{z^{n+1}}{n+1}\qquad \lvert z\rvert<1</script><h1 id="阿贝尔定理"><a href="#阿贝尔定理" class="headerlink" title="阿贝尔定理"></a>阿贝尔定理</h1><p>和实变函数中的定理基本一致。</p>
<h1 id="洛朗级数"><a href="#洛朗级数" class="headerlink" title="洛朗级数"></a>洛朗级数</h1><h2 id="罗朗定理"><a href="#罗朗定理" class="headerlink" title="罗朗定理"></a>罗朗定理</h2><p>设函数$f(z)$在圆环域$R_1&lt;\lvert z-z_0\rvert&lt;R_2 $内处处解析，则$f(z)$一定可以在此圆环域中展开为：</p>
<script type="math/tex; mode=display">
\displaystyle f(z)=\sum_{n=-\infty}^{+\infty}C_n(z-z_0)^n</script><p>其中</p>
<script type="math/tex; mode=display">
\displaystyle C_n=\dfrac{1}{2\pi i}\oint_C\dfrac{f(\zeta)}{(\zeta-z_0)^{n+1}}\mathrm{d}\zeta \qquad n=0,\pm 1,\pm 2,\cdots</script><h1 id="解析的等价条件总结"><a href="#解析的等价条件总结" class="headerlink" title="解析的等价条件总结"></a>解析的等价条件总结</h1><ul>
<li><p>函数$f(z)$在区域$D$内可导；</p>
</li>
<li><p>$u、v$在区域$D$内可微，且满足$C-R$条件；</p>
</li>
<li><p>函数$f(z)$在区域D内连续，且积分与路径无关(Merera定理)；</p>
</li>
<li><p>函数$f(z)$在区域$D$内可以展开为幂级数。</p>
</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><blockquote>
<p>把函数$\dfrac{1}{(1+z)^2}$级数展开成$z$的幂级数。</p>
</blockquote>
<p>利用$-\dfrac{1}{1+z}$的导数是$\dfrac{1}{(1+z)^2}$，而$-\dfrac{1}{1+z}$展开显然可以。</p>
<h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><ul>
<li><p>$\cos(in)=\cosh(n)$</p>
</li>
<li><p>$\sin(n)=-\sinh(n)$</p>
</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cdots</span></span><br><span class="line"><span class="keyword">\displaystyle</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;n <span class="keyword">\to</span> <span class="keyword">\infty</span>&#125;<span class="keyword">\lvert</span> <span class="keyword">\dfrac</span>&#123;C<span class="built_in">_</span>&#123;n+1&#125;&#125;&#123;C<span class="built_in">_</span>n&#125;<span class="keyword">\rvert</span>=<span class="keyword">\lambda</span></span><br><span class="line"><span class="keyword">\sqrt</span>[n]&#123;<span class="keyword">\lvert</span> C<span class="built_in">_</span>n<span class="keyword">\rvert</span>&#125;4</span><br><span class="line"><span class="keyword">\qquad</span><span class="keyword">\lvert</span> z<span class="keyword">\rvert</span>&lt;+<span class="keyword">\infty</span></span><br><span class="line">n=0,<span class="keyword">\pm</span> 1,<span class="keyword">\pm</span> 2,<span class="keyword">\cdots</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>级数</tag>
        <tag>洛朗级数</tag>
      </tags>
  </entry>
  <entry>
    <title>插入图片测试</title>
    <url>/2024/07/02/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>如标题所述，这篇文章用于测试图片是否可以正常插入</p>
<ul>
<li><h1 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h1></li>
</ul>
<img src="/2024/07/02/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/test.jpg" class="">
<ul>
<li><h1 id="来自于url的图片"><a href="#来自于url的图片" class="headerlink" title="来自于url的图片"></a>来自于url的图片</h1><p>83</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个markdown</title>
    <url>/2024/07/05/%E7%AC%AC%E4%B8%80%E4%B8%AAmarkdown/</url>
    <content><![CDATA[<p>[TOC]不支持捏</p>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>$\int<em>{\partial \Omega} (\mathbf{F} \cdot \mathbf{n}) dS = \int</em>{\Omega} \nabla \cdot \mathbf{F} dV\int<em>{\partial \Omega} (\mathbf{F} \cdot \mathbf{n}) dS = \int</em>{\Omega} \nabla \cdot \mathbf{F} dV$</p>
<p>$e^{ix} = \cos{x} + i\sin{x}$</p>
<p>$\frac{\partial u}{\partial x} = \frac{\partial v}{\partial y}, \quad \frac{\partial u}{\partial y} = -\frac{\partial v}{\partial x}$</p>
<p>$\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla) \mathbf{u} = -\frac{1}{\rho} \nabla p + \nu \nabla^2 \mathbf{u}$</p>
<p>$\nabla \cdot \mathbf{E} = \frac{\rho}{\varepsilon_0}, \quad \nabla \cdot \mathbf{B} = 0, \quad \nabla \times \mathbf{E} = -\frac{\partial \mathbf{B}}{\partial t}, \quad \nabla \times \mathbf{B} = \mu_0 \mathbf{J} + \mu_0 \varepsilon_0 \frac{\partial \mathbf{E}}{\partial t}$</p>
<p>$\oint<em>{\partial V} \mathbf{E} \cdot d\mathbf{S} = \frac{1}{\varepsilon_0} \int</em>{V} \rho dV, \quad \oint<em>{\partial S} \mathbf{B} \cdot d\mathbf{A} = 0, \quad \oint</em>{C} \mathbf{E} \cdot d\mathbf{l} = - \int<em>{S} \frac{\partial \mathbf{B}}{\partial t} \cdot d\mathbf{A}, \quad \oint</em>{C} \mathbf{B} \cdot d\mathbf{l} = \mu<em>0 \int</em>{S} \mathbf{J} \cdot d\mathbf{A} + \mu<em>0 \varepsilon_0 \int</em>{S} \frac{\partial \mathbf{E}}{\partial t} \cdot d\mathbf{A}$</p>
<p>$f(\mathbf{x}) = \frac{1}{(2\pi)^{k/2} |\mathbf{\Sigma}|^{1/2}} \exp \left( -\frac{1}{2} (\mathbf{x} - \mathbf{\mu})^T \mathbf{\Sigma}^{-1} (\mathbf{x} - \mathbf{\mu}) \right)$</p>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><img src="/2024/07/05/%E7%AC%AC%E4%B8%80%E4%B8%AAmarkdown/top_image.jpeg" class="" title="情书">
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://markdown.com.cn/editor/ ”可交互“">在线markdown编辑器</a></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p>鲁迅说过：”选择DUT，你会度过一个相对成功的人生“</p>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr>
<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><ul>
<li><p>fir</p>
</li>
<li><p>sec</p>
</li>
<li><p>thi</p>
</li>
<li><ul>
<li><p>thi1</p>
</li>
<li><ul>
<li><p>time</p>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p><a href="1">脚注名字</a></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>feature</th>
<th>label</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>positive</td>
<td>0</td>
</tr>
<tr>
<td>02</td>
<td>positive</td>
<td>1</td>
</tr>
<tr>
<td>03</td>
<td>negative</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;helle!world&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p><del>不需要的文字</del></p>
<h1 id="特殊的格式"><a href="#特殊的格式" class="headerlink" title="特殊的格式"></a>特殊的格式</h1><p><strong>粗体两个星号</strong></p>
<p><em>斜体一个星号</em></p>
<p><strong><em>三个星号又粗又斜</em></strong></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>数学公式</tag>
      </tags>
  </entry>
</search>
